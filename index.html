<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0c1929">
  <meta name="description" content="Mission Aircrew Toolkit (MAT) - Civil Air Patrol flight operations tool">
  <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQ0FQIE9ic2VydmVyIExvZyIsInNob3J0X25hbWUiOiJDQVAgTG9nIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwYzE5MjkiLCJ0aGVtZV9jb2xvciI6IiMwYzE5MjkiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgMTAwIDEwMCc+PGNpcmNsZSBjeD0nNTAnIGN5PSc1MCcgcj0nNDUnIGZpbGw9JyVjNTMwMzAnLz48dGV4dCB4PSc1MCcgeT0nNjUnIGZvbnQtc2l6ZT0nMzAnIHRleHQtYW5jaG9yPSdtaWRkbGUnIGZpbGw9J3doaXRlJz5DQVA8L3RleHQ+PC9zdmc+Iiwic2l6ZXMiOiI5Nng5NiIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn1dfQ==">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23c53030'/><text x='50' y='65' font-size='30' text-anchor='middle' fill='white'>CAP</text></svg>">
  <title>Mission Aircrew Toolkit</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
  <link rel="stylesheet" href="css/mat-styles.css">
</head>
<body>
  <div id="root"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="data/demo-module.js"></script>
  <script src="js/mat-geo.js"></script>
  <script src="js/mat-patterns.js"></script>
  <script src="js/mat-fpl.js"></script>
  <script src="js/mat-elt.js"></script>
  <script src="data/reference-data.js"></script>
  <script src="data/emergency-data.js"></script>
  <script src="data/state-comms/state-comms-loader.js"></script>
  <script src="data/state-comms/co-comms.js"></script>
  <script src="data/proficiency-data.js"></script>
  <script>
    // Verify Leaflet loaded
    if (typeof L === 'undefined') {
      console.error('Leaflet failed to load from CDN');
      window.L = null;
    } else {
      console.log('Leaflet loaded successfully, version:', L.version);
    }
    // Verify JSZip loaded
    if (typeof JSZip === 'undefined') {
      console.warn('JSZip failed to load - KMZ support may be limited');
    } else {
      console.log('JSZip loaded successfully');
    }
    // Verify Demo Data loaded
    if (typeof window.DEMO_DATA === 'undefined') {
      console.warn('Demo data not loaded - demos may require web server');
      window.DEMO_DATA = {};
    }
  </script>
  <script>
// === REACT 18 PRODUCTION ===
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(){'use strict';(function(c,x){"object"===typeof exports&&"undefined"!==typeof module?x(exports):"function"===typeof define&&define.amd?define(["exports"],x):(c=c||self,x(c.React={}))})(this,function(c){function x(a){if(null===a||"object"!==typeof a)return null;a=V&&a[V]||a["@@iterator"];return"function"===typeof a?a:null}function w(a,b,e){this.props=a;this.context=b;this.refs=W;this.updater=e||X}function Y(){}function K(a,b,e){this.props=a;this.context=b;this.refs=W;this.updater=e||X}function Z(a,b,
e){var m,d={},c=null,h=null;if(null!=b)for(m in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(c=""+b.key),b)aa.call(b,m)&&!ba.hasOwnProperty(m)&&(d[m]=b[m]);var l=arguments.length-2;if(1===l)d.children=e;else if(1<l){for(var f=Array(l),k=0;k<l;k++)f[k]=arguments[k+2];d.children=f}if(a&&a.defaultProps)for(m in l=a.defaultProps,l)void 0===d[m]&&(d[m]=l[m]);return{$$typeof:y,type:a,key:c,ref:h,props:d,_owner:L.current}}function oa(a,b){return{$$typeof:y,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}
function M(a){return"object"===typeof a&&null!==a&&a.$$typeof===y}function pa(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}function N(a,b){return"object"===typeof a&&null!==a&&null!=a.key?pa(""+a.key):b.toString(36)}function B(a,b,e,m,d){var c=typeof a;if("undefined"===c||"boolean"===c)a=null;var h=!1;if(null===a)h=!0;else switch(c){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case y:case qa:h=!0}}if(h)return h=a,d=d(h),a=""===m?"."+
N(h,0):m,ca(d)?(e="",null!=a&&(e=a.replace(da,"$&/")+"/"),B(d,b,e,"",function(a){return a})):null!=d&&(M(d)&&(d=oa(d,e+(!d.key||h&&h.key===d.key?"":(""+d.key).replace(da,"$&/")+"/")+a)),b.push(d)),1;h=0;m=""===m?".":m+":";if(ca(a))for(var l=0;l<a.length;l++){c=a[l];var f=m+N(c,l);h+=B(c,b,e,f,d)}else if(f=x(a),"function"===typeof f)for(a=f.call(a),l=0;!(c=a.next()).done;)c=c.value,f=m+N(c,l++),h+=B(c,b,e,f,d);else if("object"===c)throw b=String(a),Error("Objects are not valid as a React child (found: "+
("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}function C(a,b,e){if(null==a)return a;var c=[],d=0;B(a,c,"","",function(a){return b.call(e,a,d++)});return c}function ra(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=
0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}function O(a,b){var e=a.length;a.push(b);a:for(;0<e;){var c=e-1>>>1,d=a[c];if(0<D(d,b))a[c]=b,a[e]=d,e=c;else break a}}function p(a){return 0===a.length?null:a[0]}function E(a){if(0===a.length)return null;var b=a[0],e=a.pop();if(e!==b){a[0]=e;a:for(var c=0,d=a.length,k=d>>>1;c<k;){var h=2*(c+1)-1,l=a[h],f=h+1,g=a[f];if(0>D(l,e))f<d&&0>D(g,l)?(a[c]=g,a[f]=e,c=f):(a[c]=l,a[h]=e,c=h);else if(f<d&&0>D(g,e))a[c]=g,a[f]=e,c=f;else break a}}return b}
function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function P(a){for(var b=p(r);null!==b;){if(null===b.callback)E(r);else if(b.startTime<=a)E(r),b.sortIndex=b.expirationTime,O(q,b);else break;b=p(r)}}function Q(a){z=!1;P(a);if(!u)if(null!==p(q))u=!0,R(S);else{var b=p(r);null!==b&&T(Q,b.startTime-a)}}function S(a,b){u=!1;z&&(z=!1,ea(A),A=-1);F=!0;var c=k;try{P(b);for(n=p(q);null!==n&&(!(n.expirationTime>b)||a&&!fa());){var m=n.callback;if("function"===typeof m){n.callback=null;
k=n.priorityLevel;var d=m(n.expirationTime<=b);b=v();"function"===typeof d?n.callback=d:n===p(q)&&E(q);P(b)}else E(q);n=p(q)}if(null!==n)var g=!0;else{var h=p(r);null!==h&&T(Q,h.startTime-b);g=!1}return g}finally{n=null,k=c,F=!1}}function fa(){return v()-ha<ia?!1:!0}function R(a){G=a;H||(H=!0,I())}function T(a,b){A=ja(function(){a(v())},b)}function ka(a){throw Error("act(...) is not supported in production builds of React.");}var y=Symbol.for("react.element"),qa=Symbol.for("react.portal"),sa=Symbol.for("react.fragment"),
ta=Symbol.for("react.strict_mode"),ua=Symbol.for("react.profiler"),va=Symbol.for("react.provider"),wa=Symbol.for("react.context"),xa=Symbol.for("react.forward_ref"),ya=Symbol.for("react.suspense"),za=Symbol.for("react.memo"),Aa=Symbol.for("react.lazy"),V=Symbol.iterator,X={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,m){},enqueueSetState:function(a,b,c,m){}},la=Object.assign,W={};w.prototype.isReactComponent={};w.prototype.setState=function(a,
b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};Y.prototype=w.prototype;var t=K.prototype=new Y;t.constructor=K;la(t,w.prototype);t.isPureReactComponent=!0;var ca=Array.isArray,aa=Object.prototype.hasOwnProperty,L={current:null},
ba={key:!0,ref:!0,__self:!0,__source:!0},da=/\/+/g,g={current:null},J={transition:null};if("object"===typeof performance&&"function"===typeof performance.now){var Ba=performance;var v=function(){return Ba.now()}}else{var ma=Date,Ca=ma.now();v=function(){return ma.now()-Ca}}var q=[],r=[],Da=1,n=null,k=3,F=!1,u=!1,z=!1,ja="function"===typeof setTimeout?setTimeout:null,ea="function"===typeof clearTimeout?clearTimeout:null,na="undefined"!==typeof setImmediate?setImmediate:null;"undefined"!==typeof navigator&&
void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var H=!1,G=null,A=-1,ia=5,ha=-1,U=function(){if(null!==G){var a=v();ha=a;var b=!0;try{b=G(!0,a)}finally{b?I():(H=!1,G=null)}}else H=!1};if("function"===typeof na)var I=function(){na(U)};else if("undefined"!==typeof MessageChannel){t=new MessageChannel;var Ea=t.port2;t.port1.onmessage=U;I=function(){Ea.postMessage(null)}}else I=function(){ja(U,0)};t={ReactCurrentDispatcher:g,
ReactCurrentOwner:L,ReactCurrentBatchConfig:J,Scheduler:{__proto__:null,unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=k;k=a;try{return b()}finally{k=c}},unstable_next:function(a){switch(k){case 1:case 2:case 3:var b=3;break;default:b=k}var c=k;k=b;try{return a()}finally{k=c}},unstable_scheduleCallback:function(a,
b,c){var e=v();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?e+c:e):c=e;switch(a){case 1:var d=-1;break;case 2:d=250;break;case 5:d=1073741823;break;case 4:d=1E4;break;default:d=5E3}d=c+d;a={id:Da++,callback:b,priorityLevel:a,startTime:c,expirationTime:d,sortIndex:-1};c>e?(a.sortIndex=c,O(r,a),null===p(q)&&a===p(r)&&(z?(ea(A),A=-1):z=!0,T(Q,c-e))):(a.sortIndex=d,O(q,a),u||F||(u=!0,R(S)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=
k;return function(){var c=k;k=b;try{return a.apply(this,arguments)}finally{k=c}}},unstable_getCurrentPriorityLevel:function(){return k},unstable_shouldYield:fa,unstable_requestPaint:function(){},unstable_continueExecution:function(){u||F||(u=!0,R(S))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return p(q)},get unstable_now(){return v},unstable_forceFrameRate:function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):
ia=0<a?Math.floor(1E3/a):5},unstable_Profiling:null}};c.Children={map:C,forEach:function(a,b,c){C(a,function(){b.apply(this,arguments)},c)},count:function(a){var b=0;C(a,function(){b++});return b},toArray:function(a){return C(a,function(a){return a})||[]},only:function(a){if(!M(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};c.Component=w;c.Fragment=sa;c.Profiler=ua;c.PureComponent=K;c.StrictMode=ta;c.Suspense=ya;c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=
t;c.act=ka;c.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var e=la({},a.props),d=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=L.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var l=a.type.defaultProps;for(f in b)aa.call(b,f)&&!ba.hasOwnProperty(f)&&(e[f]=void 0===b[f]&&void 0!==l?l[f]:b[f])}var f=arguments.length-2;if(1===f)e.children=c;else if(1<f){l=
Array(f);for(var g=0;g<f;g++)l[g]=arguments[g+2];e.children=l}return{$$typeof:y,type:a.type,key:d,ref:k,props:e,_owner:h}};c.createContext=function(a){a={$$typeof:wa,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:va,_context:a};return a.Consumer=a};c.createElement=Z;c.createFactory=function(a){var b=Z.bind(null,a);b.type=a;return b};c.createRef=function(){return{current:null}};c.forwardRef=function(a){return{$$typeof:xa,
render:a}};c.isValidElement=M;c.lazy=function(a){return{$$typeof:Aa,_payload:{_status:-1,_result:a},_init:ra}};c.memo=function(a,b){return{$$typeof:za,type:a,compare:void 0===b?null:b}};c.startTransition=function(a,b){b=J.transition;J.transition={};try{a()}finally{J.transition=b}};c.unstable_act=ka;c.useCallback=function(a,b){return g.current.useCallback(a,b)};c.useContext=function(a){return g.current.useContext(a)};c.useDebugValue=function(a,b){};c.useDeferredValue=function(a){return g.current.useDeferredValue(a)};
c.useEffect=function(a,b){return g.current.useEffect(a,b)};c.useId=function(){return g.current.useId()};c.useImperativeHandle=function(a,b,c){return g.current.useImperativeHandle(a,b,c)};c.useInsertionEffect=function(a,b){return g.current.useInsertionEffect(a,b)};c.useLayoutEffect=function(a,b){return g.current.useLayoutEffect(a,b)};c.useMemo=function(a,b){return g.current.useMemo(a,b)};c.useReducer=function(a,b,c){return g.current.useReducer(a,b,c)};c.useRef=function(a){return g.current.useRef(a)};
c.useState=function(a){return g.current.useState(a)};c.useSyncExternalStore=function(a,b,c){return g.current.useSyncExternalStore(a,b,c)};c.useTransition=function(){return g.current.useTransition()};c.version="18.3.1"});
})();

  </script>
  <script>
// === REACT-DOM 18 PRODUCTION ===
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(){/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(Q,zb){"object"===typeof exports&&"undefined"!==typeof module?zb(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],zb):(Q=Q||self,zb(Q.ReactDOM={},Q.React))})(this,function(Q,zb){function m(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function mb(a,b){Ab(a,b);Ab(a+"Capture",b)}function Ab(a,b){$b[a]=b;for(a=0;a<b.length;a++)cg.add(b[a])}function bj(a){if(Zd.call(dg,a))return!0;if(Zd.call(eg,a))return!1;if(cj.test(a))return dg[a]=!0;eg[a]=!0;return!1}function dj(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function ej(a,b,c,d){if(null===
b||"undefined"===typeof b||dj(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function Y(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}function $d(a,b,c,d){var e=R.hasOwnProperty(b)?R[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==
b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])ej(b,c,e,d)&&(c=null),d||null===e?bj(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}function ac(a){if(null===a||"object"!==typeof a)return null;a=fg&&a[fg]||a["@@iterator"];return"function"===typeof a?a:null}function bc(a,b,
c){if(void 0===ae)try{throw Error();}catch(d){ae=(b=d.stack.trim().match(/\n( *(at )?)/))&&b[1]||""}return"\n"+ae+a}function be(a,b){if(!a||ce)return"";ce=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(n){var d=n}Reflect.construct(a,[],b)}else{try{b.call()}catch(n){d=n}a.call(b.prototype)}else{try{throw Error();
}catch(n){d=n}a()}}catch(n){if(n&&d&&"string"===typeof n.stack){for(var e=n.stack.split("\n"),f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{ce=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?bc(a):
""}function fj(a){switch(a.tag){case 5:return bc(a.type);case 16:return bc("Lazy");case 13:return bc("Suspense");case 19:return bc("SuspenseList");case 0:case 2:case 15:return a=be(a.type,!1),a;case 11:return a=be(a.type.render,!1),a;case 1:return a=be(a.type,!0),a;default:return""}}function de(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Bb:return"Fragment";case Cb:return"Portal";case ee:return"Profiler";case fe:return"StrictMode";
case ge:return"Suspense";case he:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case gg:return(a.displayName||"Context")+".Consumer";case hg:return(a._context.displayName||"Context")+".Provider";case ie:var b=a.render;a=a.displayName;a||(a=b.displayName||b.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case je:return b=a.displayName||null,null!==b?b:de(a.type)||"Memo";case Ta:b=a._payload;a=a._init;try{return de(a(b))}catch(c){}}return null}function gj(a){var b=a.type;
switch(a.tag){case 24:return"Cache";case 9:return(b.displayName||"Context")+".Consumer";case 10:return(b._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return b;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return de(b);case 8:return b===fe?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";
case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Ua(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return""}}function ig(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===
b)}function hj(a){var b=ig(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function Pc(a){a._valueTracker||(a._valueTracker=hj(a))}function jg(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=ig(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Qc(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function ke(a,b){var c=b.checked;return E({},b,{defaultChecked:void 0,defaultValue:void 0,
value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function kg(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Ua(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function lg(a,b){b=b.checked;null!=b&&$d(a,"checked",b,!1)}function le(a,b){lg(a,b);var c=Ua(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=
c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?me(a,b.type,c):b.hasOwnProperty("defaultValue")&&me(a,b.type,Ua(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function mg(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;
c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function me(a,b,c){if("number"!==b||Qc(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function Db(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=
!0)}else{c=""+Ua(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function ne(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(m(91));return E({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function ng(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(m(92));if(cc(c)){if(1<c.length)throw Error(m(93));
c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Ua(c)}}function og(a,b){var c=Ua(b.value),d=Ua(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function pg(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}function qg(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}
function oe(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?qg(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function rg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||dc.hasOwnProperty(a)&&dc[a]?(""+b).trim():b+"px"}function sg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=rg(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function pe(a,b){if(b){if(ij[a]&&
(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(m(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(m(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(m(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(m(62));}}function qe(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function re(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function tg(a){if(a=ec(a)){if("function"!==typeof se)throw Error(m(280));var b=a.stateNode;b&&(b=Rc(b),se(a.stateNode,a.type,b))}}function ug(a){Eb?Fb?Fb.push(a):Fb=[a]:Eb=a}function vg(){if(Eb){var a=Eb,b=Fb;Fb=Eb=null;tg(a);if(b)for(a=0;a<b.length;a++)tg(b[a])}}function wg(a,b,c){if(te)return a(b,c);te=!0;try{return xg(a,b,c)}finally{if(te=
!1,null!==Eb||null!==Fb)yg(),vg()}}function fc(a,b){var c=a.stateNode;if(null===c)return null;var d=Rc(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;
if(c&&"function"!==typeof c)throw Error(m(231,b,typeof c));return c}function jj(a,b,c,d,e,f,g,h,k){gc=!1;Sc=null;kj.apply(lj,arguments)}function mj(a,b,c,d,e,f,g,h,k){jj.apply(this,arguments);if(gc){if(gc){var n=Sc;gc=!1;Sc=null}else throw Error(m(198));Tc||(Tc=!0,ue=n)}}function nb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function zg(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,
null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Ag(a){if(nb(a)!==a)throw Error(m(188));}function nj(a){var b=a.alternate;if(!b){b=nb(a);if(null===b)throw Error(m(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Ag(e),a;if(f===d)return Ag(e),b;f=f.sibling}throw Error(m(188));}if(c.return!==d.return)c=e,d=f;
else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(m(189));}}if(c.alternate!==d)throw Error(m(190));}if(3!==c.tag)throw Error(m(188));return c.stateNode.current===c?a:b}function Bg(a){a=nj(a);return null!==a?Cg(a):null}function Cg(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=Cg(a);if(null!==b)return b;a=a.sibling}return null}
function oj(a,b){if(Ca&&"function"===typeof Ca.onCommitFiberRoot)try{Ca.onCommitFiberRoot(Uc,a,void 0,128===(a.current.flags&128))}catch(c){}}function pj(a){a>>>=0;return 0===a?32:31-(qj(a)/rj|0)|0}function hc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&
4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return a}}function Vc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=hc(h):(f&=g,0!==f&&(d=hc(f)))}else g=c&~e,0!==g?d=hc(g):0!==f&&(d=hc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&
(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-ta(b),e=1<<c,d|=a[c],b&=~e;return d}function sj(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;
case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function tj(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-ta(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=sj(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function ve(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function Dg(){var a=Wc;Wc<<=1;0===(Wc&4194240)&&(Wc=64);return a}function we(a){for(var b=[],c=0;31>c;c++)b.push(a);
return b}function ic(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-ta(b);a[b]=c}function uj(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-ta(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}function xe(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-ta(c),e=1<<d;e&b|a[d]&
b&&(a[d]|=b);c&=~e}}function Eg(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}function Fg(a,b){switch(a){case "focusin":case "focusout":Va=null;break;case "dragenter":case "dragleave":Wa=null;break;case "mouseover":case "mouseout":Xa=null;break;case "pointerover":case "pointerout":jc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":kc.delete(b.pointerId)}}function lc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,
nativeEvent:f,targetContainers:[e]},null!==b&&(b=ec(b),null!==b&&Gg(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}function vj(a,b,c,d,e){switch(b){case "focusin":return Va=lc(Va,a,b,c,d,e),!0;case "dragenter":return Wa=lc(Wa,a,b,c,d,e),!0;case "mouseover":return Xa=lc(Xa,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;jc.set(f,lc(jc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,kc.set(f,lc(kc.get(f)||null,a,b,
c,d,e)),!0}return!1}function Hg(a){var b=ob(a.target);if(null!==b){var c=nb(b);if(null!==c)if(b=c.tag,13===b){if(b=zg(c),null!==b){a.blockedOn=b;wj(a.priority,function(){xj(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=ye(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;
var d=new c.constructor(c.type,c);ze=d;c.target.dispatchEvent(d);ze=null}else return b=ec(c),null!==b&&Gg(b),a.blockedOn=c,!1;b.shift()}return!0}function Ig(a,b,c){Xc(a)&&c.delete(b)}function yj(){Ae=!1;null!==Va&&Xc(Va)&&(Va=null);null!==Wa&&Xc(Wa)&&(Wa=null);null!==Xa&&Xc(Xa)&&(Xa=null);jc.forEach(Ig);kc.forEach(Ig)}function mc(a,b){a.blockedOn===b&&(a.blockedOn=null,Ae||(Ae=!0,Jg(Kg,yj)))}function nc(a){if(0<Yc.length){mc(Yc[0],a);for(var b=1;b<Yc.length;b++){var c=Yc[b];c.blockedOn===a&&(c.blockedOn=
null)}}null!==Va&&mc(Va,a);null!==Wa&&mc(Wa,a);null!==Xa&&mc(Xa,a);b=function(b){return mc(b,a)};jc.forEach(b);kc.forEach(b);for(b=0;b<Ya.length;b++)c=Ya[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Ya.length&&(b=Ya[0],null===b.blockedOn);)Hg(b),null===b.blockedOn&&Ya.shift()}function zj(a,b,c,d){var e=z,f=Gb.transition;Gb.transition=null;try{z=1,Be(a,b,c,d)}finally{z=e,Gb.transition=f}}function Aj(a,b,c,d){var e=z,f=Gb.transition;Gb.transition=null;try{z=4,Be(a,b,c,d)}finally{z=e,Gb.transition=
f}}function Be(a,b,c,d){if(Zc){var e=ye(a,b,c,d);if(null===e)Ce(a,b,d,$c,c),Fg(a,d);else if(vj(e,a,b,c,d))d.stopPropagation();else if(Fg(a,d),b&4&&-1<Bj.indexOf(a)){for(;null!==e;){var f=ec(e);null!==f&&Cj(f);f=ye(a,b,c,d);null===f&&Ce(a,b,d,$c,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else Ce(a,b,d,null,c)}}function ye(a,b,c,d){$c=null;a=re(d);a=ob(a);if(null!==a)if(b=nb(a),null===b)a=null;else if(c=b.tag,13===c){a=zg(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===
b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);$c=a;return null}function Lg(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;
case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;case "message":switch(Dj()){case De:return 1;case Mg:return 4;case ad:case Ej:return 16;case Ng:return 536870912;default:return 16}default:return 16}}function Og(){if(bd)return bd;
var a,b=Ee,c=b.length,d,e="value"in Za?Za.value:Za.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return bd=e.slice(a,1<d?1-d:void 0)}function cd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function dd(){return!0}function Pg(){return!1}function ka(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;
for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?dd:Pg;this.isPropagationStopped=Pg;return this}E(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=dd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():
"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=dd)},persist:function(){},isPersistent:dd});return b}function Fj(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Gj[a])?!!b[a]:!1}function Fe(a){return Fj}function Qg(a,b){switch(a){case "keyup":return-1!==Hj.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function Rg(a){a=a.detail;return"object"===typeof a&&
"data"in a?a.data:null}function Ij(a,b){switch(a){case "compositionend":return Rg(b);case "keypress":if(32!==b.which)return null;Sg=!0;return Tg;case "textInput":return a=b.data,a===Tg&&Sg?null:a;default:return null}}function Jj(a,b){if(Hb)return"compositionend"===a||!Ge&&Qg(a,b)?(a=Og(),bd=Ee=Za=null,Hb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return Ug&&"ko"!==b.locale?null:b.data;default:return null}}function Vg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Kj[a.type]:"textarea"===b?!0:!1}function Lj(a){if(!Ia)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Wg(a,b,c,d){ug(d);b=ed(b,"onChange");0<b.length&&(c=new He("onChange","change",null,c,d),a.push({event:c,listeners:b}))}function Mj(a){Xg(a,
0)}function fd(a){var b=Ib(a);if(jg(b))return a}function Nj(a,b){if("change"===a)return b}function Yg(){oc&&(oc.detachEvent("onpropertychange",Zg),pc=oc=null)}function Zg(a){if("value"===a.propertyName&&fd(pc)){var b=[];Wg(b,pc,a,re(a));wg(Mj,b)}}function Oj(a,b,c){"focusin"===a?(Yg(),oc=b,pc=c,oc.attachEvent("onpropertychange",Zg)):"focusout"===a&&Yg()}function Pj(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return fd(pc)}function Qj(a,b){if("click"===a)return fd(b)}function Rj(a,b){if("input"===
a||"change"===a)return fd(b)}function Sj(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function qc(a,b){if(ua(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!Zd.call(b,e)||!ua(a[e],b[e]))return!1}return!0}function $g(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ah(a,b){var c=$g(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;
if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=$g(c)}}function bh(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?bh(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function ch(){for(var a=window,b=Qc();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;
b=Qc(a.document)}return b}function Ie(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function Tj(a){var b=ch(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&bh(c.ownerDocument.documentElement,c)){if(null!==d&&Ie(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);
else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=ah(c,f);var g=ah(c,d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),
a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}function dh(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Je||null==Jb||Jb!==Qc(d)||(d=Jb,"selectionStart"in d&&Ie(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d=
{anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),rc&&qc(rc,d)||(rc=d,d=ed(Ke,"onSelect"),0<d.length&&(b=new He("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Jb)))}function gd(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function hd(a){if(Le[a])return Le[a];if(!Kb[a])return a;var b=Kb[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in eh)return Le[a]=b[c];return a}function $a(a,
b){fh.set(a,b);mb(b,[a])}function gh(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;mj(d,b,void 0,a);a.currentTarget=null}function Xg(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,n=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;gh(e,h,n);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;n=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;
gh(e,h,n);f=k}}}if(Tc)throw a=ue,Tc=!1,ue=null,a;}function B(a,b){var c=b[Me];void 0===c&&(c=b[Me]=new Set);var d=a+"__bubble";c.has(d)||(hh(b,a,2,!1),c.add(d))}function Ne(a,b,c){var d=0;b&&(d|=4);hh(c,a,d,b)}function sc(a){if(!a[id]){a[id]=!0;cg.forEach(function(b){"selectionchange"!==b&&(Uj.has(b)||Ne(b,!1,a),Ne(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[id]||(b[id]=!0,Ne("selectionchange",!1,b))}}function hh(a,b,c,d,e){switch(Lg(b)){case 1:e=zj;break;case 4:e=Aj;break;default:e=
Be}c=e.bind(null,b,c,a);e=void 0;!Oe||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}function Ce(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;
if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=ob(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}wg(function(){var d=f,e=re(c),g=[];a:{var h=fh.get(a);if(void 0!==h){var k=He,m=a;switch(a){case "keypress":if(0===cd(c))break a;case "keydown":case "keyup":k=Vj;break;case "focusin":m="focus";k=Pe;break;case "focusout":m="blur";k=Pe;break;case "beforeblur":case "afterblur":k=Pe;break;
case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=ih;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=Wj;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Xj;break;case jh:case kh:case lh:k=Yj;break;case mh:k=Zj;break;case "scroll":k=ak;break;case "wheel":k=bk;break;case "copy":case "cut":case "paste":k=
ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=nh}var l=0!==(b&4),p=!l&&"scroll"===a,w=l?null!==h?h+"Capture":null:h;l=[];for(var A=d,t;null!==A;){t=A;var M=t.stateNode;5===t.tag&&null!==M&&(t=M,null!==w&&(M=fc(A,w),null!=M&&l.push(tc(A,M,t))));if(p)break;A=A.return}0<l.length&&(h=new k(h,m,null,c,e),g.push({event:h,listeners:l}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===
a;k="mouseout"===a||"pointerout"===a;if(h&&c!==ze&&(m=c.relatedTarget||c.fromElement)&&(ob(m)||m[Ja]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(m=c.relatedTarget||c.toElement,k=d,m=m?ob(m):null,null!==m&&(p=nb(m),m!==p||5!==m.tag&&6!==m.tag))m=null}else k=null,m=d;if(k!==m){l=ih;M="onMouseLeave";w="onMouseEnter";A="mouse";if("pointerout"===a||"pointerover"===a)l=nh,M="onPointerLeave",w="onPointerEnter",A="pointer";p=null==k?h:Ib(k);t=null==
m?h:Ib(m);h=new l(M,A+"leave",k,c,e);h.target=p;h.relatedTarget=t;M=null;ob(e)===d&&(l=new l(w,A+"enter",m,c,e),l.target=t,l.relatedTarget=p,M=l);p=M;if(k&&m)b:{l=k;w=m;A=0;for(t=l;t;t=Lb(t))A++;t=0;for(M=w;M;M=Lb(M))t++;for(;0<A-t;)l=Lb(l),A--;for(;0<t-A;)w=Lb(w),t--;for(;A--;){if(l===w||null!==w&&l===w.alternate)break b;l=Lb(l);w=Lb(w)}l=null}else l=null;null!==k&&oh(g,h,k,l,!1);null!==m&&null!==p&&oh(g,p,m,l,!0)}}}a:{h=d?Ib(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===
k&&"file"===h.type)var ma=Nj;else if(Vg(h))if(ph)ma=Rj;else{ma=Pj;var va=Oj}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(ma=Qj);if(ma&&(ma=ma(a,d))){Wg(g,ma,c,e);break a}va&&va(a,h,d);"focusout"===a&&(va=h._wrapperState)&&va.controlled&&"number"===h.type&&me(h,"number",h.value)}va=d?Ib(d):window;switch(a){case "focusin":if(Vg(va)||"true"===va.contentEditable)Jb=va,Ke=d,rc=null;break;case "focusout":rc=Ke=Jb=null;break;case "mousedown":Je=!0;break;case "contextmenu":case "mouseup":case "dragend":Je=
!1;dh(g,c,e);break;case "selectionchange":if(dk)break;case "keydown":case "keyup":dh(g,c,e)}var ab;if(Ge)b:{switch(a){case "compositionstart":var da="onCompositionStart";break b;case "compositionend":da="onCompositionEnd";break b;case "compositionupdate":da="onCompositionUpdate";break b}da=void 0}else Hb?Qg(a,c)&&(da="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(da="onCompositionStart");da&&(Ug&&"ko"!==c.locale&&(Hb||"onCompositionStart"!==da?"onCompositionEnd"===da&&Hb&&(ab=Og()):(Za=e,Ee=
"value"in Za?Za.value:Za.textContent,Hb=!0)),va=ed(d,da),0<va.length&&(da=new qh(da,a,null,c,e),g.push({event:da,listeners:va}),ab?da.data=ab:(ab=Rg(c),null!==ab&&(da.data=ab))));if(ab=ek?Ij(a,c):Jj(a,c))d=ed(d,"onBeforeInput"),0<d.length&&(e=new fk("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=ab)}Xg(g,b)})}function tc(a,b,c){return{instance:a,listener:b,currentTarget:c}}function ed(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==
f&&(e=f,f=fc(a,c),null!=f&&d.unshift(tc(a,f,e)),f=fc(a,b),null!=f&&d.push(tc(a,f,e)));a=a.return}return d}function Lb(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}function oh(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,n=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==n&&(h=n,e?(k=fc(c,f),null!=k&&g.unshift(tc(c,k,h))):e||(k=fc(c,f),null!=k&&g.push(tc(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}function rh(a){return("string"===
typeof a?a:""+a).replace(gk,"\n").replace(hk,"")}function jd(a,b,c,d){b=rh(b);if(rh(a)!==b&&c)throw Error(m(425));}function kd(){}function Qe(a,b){return"textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function ik(a){setTimeout(function(){throw a;})}function Re(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=
e.data,"/$"===c){if(0===d){a.removeChild(e);nc(b);return}d--}else"$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e}while(c);nc(b)}function Ka(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}function sh(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}function ob(a){var b=a[Da];
if(b)return b;for(var c=a.parentNode;c;){if(b=c[Ja]||c[Da]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=sh(a);null!==a;){if(c=a[Da])return c;a=sh(a)}return b}a=c;c=a.parentNode}return null}function ec(a){a=a[Da]||a[Ja];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Ib(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(m(33));}function Rc(a){return a[uc]||null}function bb(a){return{current:a}}function v(a,b){0>Mb||(a.current=Se[Mb],Se[Mb]=null,Mb--)}
function y(a,b,c){Mb++;Se[Mb]=a.current;a.current=b}function Nb(a,b){var c=a.type.contextTypes;if(!c)return cb;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function ea(a){a=a.childContextTypes;return null!==a&&void 0!==a}function th(a,b,c){if(J.current!==cb)throw Error(m(168));
y(J,b);y(S,c)}function uh(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(m(108,gj(a)||"Unknown",e));return E({},c,d)}function ld(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||cb;pb=J.current;y(J,a);y(S,S.current);return!0}function vh(a,b,c){var d=a.stateNode;if(!d)throw Error(m(169));c?(a=uh(a,b,pb),d.__reactInternalMemoizedMergedChildContext=a,v(S),v(J),y(J,a)):v(S);
y(S,c)}function wh(a){null===La?La=[a]:La.push(a)}function jk(a){md=!0;wh(a)}function db(){if(!Te&&null!==La){Te=!0;var a=0,b=z;try{var c=La;for(z=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}La=null;md=!1}catch(e){throw null!==La&&(La=La.slice(a+1)),xh(De,db),e;}finally{z=b,Te=!1}}return null}function qb(a,b){Ob[Pb++]=nd;Ob[Pb++]=od;od=a;nd=b}function yh(a,b,c){na[oa++]=Ma;na[oa++]=Na;na[oa++]=rb;rb=a;var d=Ma;a=Na;var e=32-ta(d)-1;d&=~(1<<e);c+=1;var f=32-ta(b)+e;if(30<f){var g=e-e%5;
f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;Ma=1<<32-ta(b)+e|c<<e|d;Na=f+a}else Ma=1<<f|c<<e|d,Na=a}function Ue(a){null!==a.return&&(qb(a,1),yh(a,1,0))}function Ve(a){for(;a===od;)od=Ob[--Pb],Ob[Pb]=null,nd=Ob[--Pb],Ob[Pb]=null;for(;a===rb;)rb=na[--oa],na[oa]=null,Na=na[--oa],na[oa]=null,Ma=na[--oa],na[oa]=null}function zh(a,b){var c=pa(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}function Ah(a,b){switch(a.tag){case 5:var c=
a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,la=a,fa=Ka(b.firstChild),!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,la=a,fa=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==rb?{id:Ma,overflow:Na}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=pa(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,la=a,fa=null,!0):!1;default:return!1}}function We(a){return 0!==
(a.mode&1)&&0===(a.flags&128)}function Xe(a){if(D){var b=fa;if(b){var c=b;if(!Ah(a,b)){if(We(a))throw Error(m(418));b=Ka(c.nextSibling);var d=la;b&&Ah(a,b)?zh(d,c):(a.flags=a.flags&-4097|2,D=!1,la=a)}}else{if(We(a))throw Error(m(418));a.flags=a.flags&-4097|2;D=!1;la=a}}}function Bh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;la=a}function pd(a){if(a!==la)return!1;if(!D)return Bh(a),D=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Qe(a.type,
a.memoizedProps));if(b&&(b=fa)){if(We(a)){for(a=fa;a;)a=Ka(a.nextSibling);throw Error(m(418));}for(;b;)zh(a,b),b=Ka(b.nextSibling)}Bh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(m(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){fa=Ka(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}fa=null}}else fa=la?Ka(a.stateNode.nextSibling):null;return!0}function Qb(){fa=la=null;D=!1}function Ye(a){null===
wa?wa=[a]:wa.push(a)}function vc(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(m(309));var d=c.stateNode}if(!d)throw Error(m(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if("string"!==typeof a)throw Error(m(284));if(!c._owner)throw Error(m(290,a));}return a}function qd(a,b){a=
Object.prototype.toString.call(b);throw Error(m(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function Ch(a){var b=a._init;return b(a._payload)}function Dh(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=eb(a,b);a.index=
0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&null===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Ze(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===Bb)return l(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ta&&
Ch(f)===b.type))return d=e(b,c.props),d.ref=vc(a,b,c),d.return=a,d;d=rd(c.type,c.key,c.props,null,a.mode,d);d.ref=vc(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=$e(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=sb(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function u(a,b,c){if("string"===
typeof b&&""!==b||"number"===typeof b)return b=Ze(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case sd:return c=rd(b.type,b.key,b.props,null,a.mode,c),c.ref=vc(a,null,b),c.return=a,c;case Cb:return b=$e(b,a.mode,c),b.return=a,b;case Ta:var d=b._init;return u(a,d(b._payload),c)}if(cc(b)||ac(b))return b=sb(b,a.mode,c,null),b.return=a,b;qd(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==
e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case sd:return c.key===e?k(a,b,c,d):null;case Cb:return c.key===e?n(a,b,c,d):null;case Ta:return e=c._init,r(a,b,e(c._payload),d)}if(cc(c)||ac(c))return null!==e?null:l(a,b,c,d,null);qd(a,c)}return null}function p(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case sd:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,
e);case Cb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e);case Ta:var f=d._init;return p(a,b,c,f(d._payload),e)}if(cc(d)||ac(d))return a=a.get(c)||null,l(b,a,d,e,null);qd(b,d)}return null}function x(e,g,h,k){for(var n=null,m=null,l=g,t=g=0,q=null;null!==l&&t<h.length;t++){l.index>t?(q=l,l=null):q=l.sibling;var A=r(e,l,h[t],k);if(null===A){null===l&&(l=q);break}a&&l&&null===A.alternate&&b(e,l);g=f(A,g,t);null===m?n=A:m.sibling=A;m=A;l=q}if(t===h.length)return c(e,l),D&&qb(e,t),n;if(null===l){for(;t<
h.length;t++)l=u(e,h[t],k),null!==l&&(g=f(l,g,t),null===m?n=l:m.sibling=l,m=l);D&&qb(e,t);return n}for(l=d(e,l);t<h.length;t++)q=p(l,e,t,h[t],k),null!==q&&(a&&null!==q.alternate&&l.delete(null===q.key?t:q.key),g=f(q,g,t),null===m?n=q:m.sibling=q,m=q);a&&l.forEach(function(a){return b(e,a)});D&&qb(e,t);return n}function I(e,g,h,k){var n=ac(h);if("function"!==typeof n)throw Error(m(150));h=n.call(h);if(null==h)throw Error(m(151));for(var l=n=null,q=g,t=g=0,A=null,w=h.next();null!==q&&!w.done;t++,w=
h.next()){q.index>t?(A=q,q=null):A=q.sibling;var x=r(e,q,w.value,k);if(null===x){null===q&&(q=A);break}a&&q&&null===x.alternate&&b(e,q);g=f(x,g,t);null===l?n=x:l.sibling=x;l=x;q=A}if(w.done)return c(e,q),D&&qb(e,t),n;if(null===q){for(;!w.done;t++,w=h.next())w=u(e,w.value,k),null!==w&&(g=f(w,g,t),null===l?n=w:l.sibling=w,l=w);D&&qb(e,t);return n}for(q=d(e,q);!w.done;t++,w=h.next())w=p(q,e,t,w.value,k),null!==w&&(a&&null!==w.alternate&&q.delete(null===w.key?t:w.key),g=f(w,g,t),null===l?n=w:l.sibling=
w,l=w);a&&q.forEach(function(a){return b(e,a)});D&&qb(e,t);return n}function v(a,d,f,h){"object"===typeof f&&null!==f&&f.type===Bb&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case sd:a:{for(var k=f.key,n=d;null!==n;){if(n.key===k){k=f.type;if(k===Bb){if(7===n.tag){c(a,n.sibling);d=e(n,f.props.children);d.return=a;a=d;break a}}else if(n.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ta&&Ch(k)===n.type){c(a,n.sibling);d=e(n,f.props);d.ref=vc(a,
n,f);d.return=a;a=d;break a}c(a,n);break}else b(a,n);n=n.sibling}f.type===Bb?(d=sb(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=rd(f.type,f.key,f.props,null,a.mode,h),h.ref=vc(a,d,f),h.return=a,a=h)}return g(a);case Cb:a:{for(n=f.key;null!==d;){if(d.key===n)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=$e(f,a.mode,h);d.return=a;
a=d}return g(a);case Ta:return n=f._init,v(a,d,n(f._payload),h)}if(cc(f))return x(a,d,f,h);if(ac(f))return I(a,d,f,h);qd(a,f)}return"string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Ze(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return v}function af(){bf=Rb=td=null}function cf(a,b){b=ud.current;v(ud);a._currentValue=b}function df(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=
b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}function Sb(a,b){td=a;bf=Rb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(ha=!0),a.firstContext=null)}function qa(a){var b=a._currentValue;if(bf!==a)if(a={context:a,memoizedValue:b,next:null},null===Rb){if(null===td)throw Error(m(308));Rb=a;td.dependencies={lanes:0,firstContext:a}}else Rb=Rb.next=a;return b}function ef(a){null===tb?tb=[a]:tb.push(a)}function Eh(a,b,c,d){var e=b.interleaved;
null===e?(c.next=c,ef(b)):(c.next=e.next,e.next=c);b.interleaved=c;return Oa(a,d)}function Oa(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}function ff(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Fh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue=
{baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function Pa(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}function fb(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(p&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return kk(a,c)}e=d.interleaved;null===e?(b.next=b,ef(d)):(b.next=e.next,e.next=b);d.interleaved=b;return Oa(a,c)}function vd(a,b,c){b=
b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;xe(a,c)}}function Gh(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,
shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=b;c.lastBaseUpdate=b}function wd(a,b,c,d){var e=a.updateQueue;gb=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,n=k.next;k.next=null;null===g?f=n:g.next=n;g=k;var l=a.alternate;null!==l&&(l=l.updateQueue,h=l.lastBaseUpdate,h!==g&&(null===h?l.firstBaseUpdate=n:h.next=n,l.lastBaseUpdate=k))}if(null!==f){var m=e.baseState;g=0;l=
n=k=null;h=f;do{var r=h.lane,p=h.eventTime;if((d&r)===r){null!==l&&(l=l.next={eventTime:p,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,next:null});a:{var x=a,v=h;r=b;p=c;switch(v.tag){case 1:x=v.payload;if("function"===typeof x){m=x.call(p,m,r);break a}m=x;break a;case 3:x.flags=x.flags&-65537|128;case 0:x=v.payload;r="function"===typeof x?x.call(p,m,r):x;if(null===r||void 0===r)break a;m=E({},m,r);break a;case 2:gb=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=
[h]:r.push(h))}else p={eventTime:p,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===l?(n=l=p,k=m):l=l.next=p,g|=r;h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===l&&(k=m);e.baseState=k;e.firstBaseUpdate=n;e.lastBaseUpdate=l;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);ra|=g;a.lanes=g;a.memoizedState=m}}function Hh(a,
b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(m(191,e));e.call(d)}}}function ub(a){if(a===wc)throw Error(m(174));return a}function gf(a,b){y(xc,b);y(yc,a);y(Ea,wc);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:oe(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=oe(b,a)}v(Ea);y(Ea,b)}function Tb(a){v(Ea);v(yc);v(xc)}function Ih(a){ub(xc.current);
var b=ub(Ea.current);var c=oe(b,a.type);b!==c&&(y(yc,a),y(Ea,c))}function hf(a){yc.current===a&&(v(Ea),v(yc))}function xd(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=
b.return;b=b.sibling}return null}function jf(){for(var a=0;a<kf.length;a++)kf[a]._workInProgressVersionPrimary=null;kf.length=0}function V(){throw Error(m(321));}function lf(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!ua(a[c],b[c]))return!1;return!0}function mf(a,b,c,d,e,f){vb=f;C=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;yd.current=null===a||null===a.memoizedState?lk:mk;a=c(d,e);if(zc){f=0;do{zc=!1;Ac=0;if(25<=f)throw Error(m(301));f+=1;N=K=null;b.updateQueue=null;
yd.current=nk;a=c(d,e)}while(zc)}yd.current=zd;b=null!==K&&null!==K.next;vb=0;N=K=C=null;Ad=!1;if(b)throw Error(m(300));return a}function nf(){var a=0!==Ac;Ac=0;return a}function Fa(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===N?C.memoizedState=N=a:N=N.next=a;return N}function sa(){if(null===K){var a=C.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===N?C.memoizedState:N.next;if(null!==b)N=b,K=a;else{if(null===a)throw Error(m(310));K=a;
a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===N?C.memoizedState=N=a:N=N.next=a}return N}function Bc(a,b){return"function"===typeof b?b(a):b}function of(a,b,c){b=sa();c=b.queue;if(null===c)throw Error(m(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,n=f;do{var l=n.lane;if((vb&
l)===l)null!==k&&(k=k.next={lane:0,action:n.action,hasEagerState:n.hasEagerState,eagerState:n.eagerState,next:null}),d=n.hasEagerState?n.eagerState:a(d,n.action);else{var u={lane:l,action:n.action,hasEagerState:n.hasEagerState,eagerState:n.eagerState,next:null};null===k?(h=k=u,g=d):k=k.next=u;C.lanes|=l;ra|=l}n=n.next}while(null!==n&&n!==f);null===k?g=d:k.next=h;ua(d,b.memoizedState)||(ha=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=
e.lane,C.lanes|=f,ra|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}function pf(a,b,c){b=sa();c=b.queue;if(null===c)throw Error(m(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);ua(f,b.memoizedState)||(ha=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function Jh(a,b,c){}function Kh(a,b,c){c=C;var d=sa(),
e=b(),f=!ua(d.memoizedState,e);f&&(d.memoizedState=e,ha=!0);d=d.queue;qf(Lh.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==N&&N.memoizedState.tag&1){c.flags|=2048;Cc(9,Mh.bind(null,c,d,e,b),void 0,null);if(null===O)throw Error(m(349));0!==(vb&30)||Nh(c,b,e)}return e}function Nh(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=C.updateQueue;null===b?(b={lastEffect:null,stores:null},C.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}function Mh(a,b,c,d){b.value=c;b.getSnapshot=
d;Oh(b)&&Ph(a)}function Lh(a,b,c){return c(function(){Oh(b)&&Ph(a)})}function Oh(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!ua(a,c)}catch(d){return!0}}function Ph(a){var b=Oa(a,1);null!==b&&xa(b,a,1,-1)}function Qh(a){var b=Fa();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Bc,lastRenderedState:a};b.queue=a;a=a.dispatch=ok.bind(null,C,a);return[b.memoizedState,a]}function Cc(a,b,c,d){a={tag:a,create:b,
destroy:c,deps:d,next:null};b=C.updateQueue;null===b?(b={lastEffect:null,stores:null},C.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function Rh(a){return sa().memoizedState}function Bd(a,b,c,d){var e=Fa();C.flags|=a;e.memoizedState=Cc(1|b,c,void 0,void 0===d?null:d)}function Cd(a,b,c,d){var e=sa();d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&lf(d,g.deps)){e.memoizedState=
Cc(b,c,f,d);return}}C.flags|=a;e.memoizedState=Cc(1|b,c,f,d)}function Sh(a,b){return Bd(8390656,8,a,b)}function qf(a,b){return Cd(2048,8,a,b)}function Th(a,b){return Cd(4,2,a,b)}function Uh(a,b){return Cd(4,4,a,b)}function Vh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function Wh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Cd(4,4,Vh.bind(null,b,a),c)}function rf(a,b){}function Xh(a,b){var c=
sa();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&lf(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function Yh(a,b){var c=sa();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&lf(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Zh(a,b,c){if(0===(vb&21))return a.baseState&&(a.baseState=!1,ha=!0),a.memoizedState=c;ua(c,b)||(c=Dg(),C.lanes|=c,ra|=c,a.baseState=!0);return b}function pk(a,b,c){c=z;z=0!==c&&4>c?c:4;a(!0);var d=sf.transition;sf.transition=
{};try{a(!1),b()}finally{z=c,sf.transition=d}}function $h(){return sa().memoizedState}function qk(a,b,c){var d=hb(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(ai(a))bi(b,c);else if(c=Eh(a,b,c,d),null!==c){var e=Z();xa(c,a,d,e);ci(c,b,d)}}function ok(a,b,c){var d=hb(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(ai(a))bi(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(ua(h,g)){var k=b.interleaved;null===k?(e.next=e,ef(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(n){}finally{}c=Eh(a,b,e,d);null!==c&&(e=Z(),xa(c,a,d,e),ci(c,b,d))}}function ai(a){var b=a.alternate;return a===C||null!==b&&b===C}function bi(a,b){zc=Ad=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function ci(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;xe(a,c)}}function ya(a,b){if(a&&
a.defaultProps){b=E({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}function tf(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:E({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}function di(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!qc(c,d)||!qc(e,f):!0}function ei(a,b,c){var d=!1,e=cb;var f=b.contextType;"object"===typeof f&&
null!==f?f=qa(f):(e=ea(b)?pb:J.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Nb(a,e):cb);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Dd;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function fi(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&
b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Dd.enqueueReplaceState(b,b.state,null)}function uf(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs={};ff(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=qa(f):(f=ea(b)?pb:J.current,e.context=Nb(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(tf(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==
typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Dd.enqueueReplaceState(e,e.state,null),wd(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308)}function Ub(a,b){try{var c="",d=b;do c+=fj(d),d=d.return;while(d);var e=c}catch(f){e="\nError generating stack: "+f.message+
"\n"+f.stack}return{value:a,source:b,stack:e,digest:null}}function vf(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}function wf(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}function gi(a,b,c){c=Pa(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Ed||(Ed=!0,xf=d);wf(a,b)};return c}function hi(a,b,c){c=Pa(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};
c.callback=function(){wf(a,b)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){wf(a,b);"function"!==typeof d&&(null===ib?ib=new Set([this]):ib.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ii(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new rk;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=sk.bind(null,a,b,c),b.then(a,a))}function ji(a){do{var b;
if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}function ki(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=Pa(-1,1),b.tag=2,fb(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}function aa(a,b,c,d){b.child=null===a?li(b,null,c,d):Vb(b,a.child,c,d)}function mi(a,b,c,d,e){c=c.render;var f=b.ref;Sb(b,e);d=mf(a,b,c,d,f,
e);c=nf();if(null!==a&&!ha)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Qa(a,b,e);D&&c&&Ue(b);b.flags|=1;aa(a,b,d,e);return b.child}function ni(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!yf(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,oi(a,b,f,d,e);a=rd(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:qc;if(c(g,d)&&a.ref===
b.ref)return Qa(a,b,e)}b.flags|=1;a=eb(f,d);a.ref=b.ref;a.return=b;return b.child=a}function oi(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(qc(f,d)&&a.ref===b.ref)if(ha=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(ha=!0);else return b.lanes=a.lanes,Qa(a,b,e)}return zf(a,b,c,d,e)}function pi(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},y(Ga,ba),ba|=c;
else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,y(Ga,ba),ba|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;y(Ga,ba);ba|=d}else null!==f?(d=f.baseLanes|c,b.memoizedState=null):d=c,y(Ga,ba),ba|=d;aa(a,b,e,c);return b.child}function qi(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function zf(a,
b,c,d,e){var f=ea(c)?pb:J.current;f=Nb(b,f);Sb(b,e);c=mf(a,b,c,d,f,e);d=nf();if(null!==a&&!ha)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Qa(a,b,e);D&&d&&Ue(b);b.flags|=1;aa(a,b,c,e);return b.child}function ri(a,b,c,d,e){if(ea(c)){var f=!0;ld(b)}else f=!1;Sb(b,e);if(null===b.stateNode)Fd(a,b),ei(b,c,d),uf(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=qa(n):(n=ea(c)?pb:J.current,n=Nb(b,
n));var l=c.getDerivedStateFromProps,m="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate;m||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==n)&&fi(b,g,d,n);gb=!1;var r=b.memoizedState;g.state=r;wd(b,d,g,e);k=b.memoizedState;h!==d||r!==k||S.current||gb?("function"===typeof l&&(tf(b,c,l,d),k=b.memoizedState),(h=gb||di(b,c,h,d,r,k,n))?(m||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||
("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.flags|=4194308)):("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;Fh(a,b);h=b.memoizedProps;n=b.type===b.elementType?h:ya(b.type,h);g.props=
n;m=b.pendingProps;r=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=qa(k):(k=ea(c)?pb:J.current,k=Nb(b,k));var p=c.getDerivedStateFromProps;(l="function"===typeof p||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==m||r!==k)&&fi(b,g,d,k);gb=!1;r=b.memoizedState;g.state=r;wd(b,d,g,e);var x=b.memoizedState;h!==m||r!==x||S.current||gb?("function"===typeof p&&(tf(b,c,p,d),x=b.memoizedState),
(n=gb||di(b,c,n,d,r,x,k)||!1)?(l||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,x,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=
4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=k,d=n):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return Af(a,b,c,d,f,e)}function Af(a,b,c,d,e,f){qi(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&vh(b,c,!1),
Qa(a,b,f);d=b.stateNode;tk.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Vb(b,a.child,null,f),b.child=Vb(b,null,h,f)):aa(a,b,h,f);b.memoizedState=d.state;e&&vh(b,c,!0);return b.child}function si(a){var b=a.stateNode;b.pendingContext?th(a,b.pendingContext,b.pendingContext!==b.context):b.context&&th(a,b.context,!1);gf(a,b.containerInfo)}function ti(a,b,c,d,e){Qb();Ye(e);b.flags|=256;aa(a,b,c,d);return b.child}function Bf(a){return{baseLanes:a,
cachePool:null,transitions:null}}function ui(a,b,c){var d=b.pendingProps,e=F.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;y(F,e&1);if(null===a){Xe(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:"hidden",children:g},0===(d&1)&&null!==
f?(f.childLanes=0,f.pendingProps=g):f=Gd(g,d,0,null),a=sb(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=Bf(c),b.memoizedState=Cf,a):Df(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return uk(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:"hidden",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=eb(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=eb(h,f):(f=
sb(f,g,c,null),f.flags|=2);f.return=b;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?Bf(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=Cf;return d}f=a.child;a=f.sibling;d=eb(f,{mode:"visible",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}
function Df(a,b,c){b=Gd({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function Hd(a,b,c,d){null!==d&&Ye(d);Vb(b,a.child,null,c);a=Df(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}function uk(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=vf(Error(m(422))),Hd(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=Gd({mode:"visible",children:d.children},e,0,null);f=sb(f,e,g,null);f.flags|=2;d.return=
b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Vb(b,a.child,null,g);b.child.memoizedState=Bf(g);b.memoizedState=Cf;return f}if(0===(b.mode&1))return Hd(a,b,g,null);if("$!"===e.data){d=e.nextSibling&&e.nextSibling.dataset;if(d)var h=d.dgst;d=h;f=Error(m(419));d=vf(f,d,void 0);return Hd(a,b,g,d)}h=0!==(g&a.childLanes);if(ha||h){d=O;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=
32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;0!==e&&e!==f.retryLane&&(f.retryLane=e,Oa(a,e),xa(d,a,e,-1))}Ef();d=vf(Error(m(421)));return Hd(a,b,g,d)}if("$?"===e.data)return b.flags|=128,b.child=a.child,b=vk.bind(null,a),e._reactRetry=b,null;a=f.treeContext;fa=Ka(e.nextSibling);la=b;D=!0;wa=null;null!==a&&(na[oa++]=Ma,na[oa++]=Na,na[oa++]=rb,Ma=a.id,Na=a.overflow,rb=b);b=Df(b,d.children);b.flags|=4096;return b}function vi(a,b,c){a.lanes|=b;var d=a.alternate;
null!==d&&(d.lanes|=b);df(a.return,b,c)}function Ff(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}function wi(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;aa(a,b,d.children,c);d=F.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&
vi(a,c,b);else if(19===a.tag)vi(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(F,d);if(0===(b.mode&1))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===xd(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ff(b,!1,e,c,f);break;case "backwards":c=
null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===xd(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ff(b,!0,c,null,f);break;case "together":Ff(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}function Fd(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function Qa(a,b,c){null!==a&&(b.dependencies=a.dependencies);ra|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(m(153));if(null!==
b.child){a=b.child;c=eb(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=eb(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}function wk(a,b,c){switch(b.tag){case 3:si(b);Qb();break;case 5:Ih(b);break;case 1:ea(b.type)&&ld(b);break;case 4:gf(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;y(ud,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return y(F,F.current&
1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return ui(a,b,c);y(F,F.current&1);a=Qa(a,b,c);return null!==a?a.sibling:null}y(F,F.current&1);break;case 19:d=0!==(c&b.childLanes);if(0!==(a.flags&128)){if(d)return wi(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);y(F,F.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,pi(a,b,c)}return Qa(a,b,c)}function Dc(a,b){if(!D)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==
b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function W(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,
d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}function xk(a,b,c){var d=b.pendingProps;Ve(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return W(b),null;case 1:return ea(b.type)&&(v(S),v(J)),W(b),null;case 3:d=b.stateNode;Tb();v(S);v(J);jf();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)pd(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&
256)||(b.flags|=1024,null!==wa&&(Gf(wa),wa=null));xi(a,b);W(b);return null;case 5:hf(b);var e=ub(xc.current);c=b.type;if(null!==a&&null!=b.stateNode)yk(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(m(166));W(b);return null}a=ub(Ea.current);if(pd(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Da]=b;d[uc]=f;a=0!==(b.mode&1);switch(c){case "dialog":B("cancel",d);B("close",d);break;case "iframe":case "object":case "embed":B("load",d);break;
case "video":case "audio":for(e=0;e<Ec.length;e++)B(Ec[e],d);break;case "source":B("error",d);break;case "img":case "image":case "link":B("error",d);B("load",d);break;case "details":B("toggle",d);break;case "input":kg(d,f);B("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};B("invalid",d);break;case "textarea":ng(d,f),B("invalid",d)}pe(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&
jd(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(!0!==f.suppressHydrationWarning&&jd(d.textContent,h,a),e=["children",""+h]):$b.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&B("scroll",d)}switch(c){case "input":Pc(d);mg(d,f,!0);break;case "textarea":Pc(d);pg(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=kd)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===
a&&(a=qg(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Da]=b;a[uc]=d;zk(a,b,!1,!1);b.stateNode=a;a:{g=qe(c,d);switch(c){case "dialog":B("cancel",a);B("close",a);e=d;break;case "iframe":case "object":case "embed":B("load",a);e=d;break;
case "video":case "audio":for(e=0;e<Ec.length;e++)B(Ec[e],a);e=d;break;case "source":B("error",a);e=d;break;case "img":case "image":case "link":B("error",a);B("load",a);e=d;break;case "details":B("toggle",a);e=d;break;case "input":kg(a,d);e=ke(a,d);B("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=E({},d,{value:void 0});B("invalid",a);break;case "textarea":ng(a,d);e=ne(a,d);B("invalid",a);break;default:e=d}pe(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=
h[f];"style"===f?sg(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&yi(a,k)):"children"===f?"string"===typeof k?("textarea"!==c||""!==k)&&Fc(a,k):"number"===typeof k&&Fc(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&($b.hasOwnProperty(f)?null!=k&&"onScroll"===f&&B("scroll",a):null!=k&&$d(a,f,k,g))}switch(c){case "input":Pc(a);mg(a,d,!1);break;case "textarea":Pc(a);pg(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Ua(d.value));
break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?Db(a,!!d.multiple,f,!1):null!=d.defaultValue&&Db(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof e.onClick&&(a.onclick=kd)}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}W(b);return null;case 6:if(a&&null!=b.stateNode)Ak(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===
b.stateNode)throw Error(m(166));c=ub(xc.current);ub(Ea.current);if(pd(b)){d=b.stateNode;c=b.memoizedProps;d[Da]=b;if(f=d.nodeValue!==c)if(a=la,null!==a)switch(a.tag){case 3:jd(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&jd(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Da]=b,b.stateNode=d}W(b);return null;case 13:v(F);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(D&&
null!==fa&&0!==(b.mode&1)&&0===(b.flags&128)){for(f=fa;f;)f=Ka(f.nextSibling);Qb();b.flags|=98560;f=!1}else if(f=pd(b),null!==d&&null!==d.dehydrated){if(null===a){if(!f)throw Error(m(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(m(317));f[Da]=b}else Qb(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;W(b);f=!1}else null!==wa&&(Gf(wa),wa=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&
d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(F.current&1)?0===L&&(L=3):Ef()));null!==b.updateQueue&&(b.flags|=4);W(b);return null;case 4:return Tb(),xi(a,b),null===a&&sc(b.stateNode.containerInfo),W(b),null;case 10:return cf(b.type._context),W(b),null;case 17:return ea(b.type)&&(v(S),v(J)),W(b),null;case 19:v(F);f=b.memoizedState;if(null===f)return W(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Dc(f,!1);else{if(0!==L||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=
xd(a);if(null!==g){b.flags|=128;Dc(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,
f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;y(F,F.current&1|2);return b.child}a=a.sibling}null!==f.tail&&P()>Hf&&(b.flags|=128,d=!0,Dc(f,!1),b.lanes=4194304)}else{if(!d)if(a=xd(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Dc(f,!0),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!D)return W(b),null}else 2*P()-f.renderingStartTime>Hf&&1073741824!==c&&(b.flags|=
128,d=!0,Dc(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=b,f.tail=b.sibling,f.renderingStartTime=P(),b.sibling=null,c=F.current,y(F,d?c&1|2:c&1),b;W(b);return null;case 22:case 23:return ba=Ga.current,v(Ga),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(ba&1073741824)&&(W(b),b.subtreeFlags&6&&(b.flags|=8192)):W(b),null;case 24:return null;
case 25:return null}throw Error(m(156,b.tag));}function Bk(a,b,c){Ve(b);switch(b.tag){case 1:return ea(b.type)&&(v(S),v(J)),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return Tb(),v(S),v(J),jf(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return hf(b),null;case 13:v(F);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(m(340));Qb()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return v(F),null;case 4:return Tb(),
null;case 10:return cf(b.type._context),null;case 22:case 23:return ba=Ga.current,v(Ga),null;case 24:return null;default:return null}}function Wb(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null)}catch(d){G(a,b,d)}else c.current=null}function If(a,b,c){try{c()}catch(d){G(a,b,d)}}function Ck(a,b){Jf=Zc;a=ch();if(Ie(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();
if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(M){c=null;break a}var g=0,h=-1,k=-1,n=0,q=0,u=a,r=null;b:for(;;){for(var p;;){u!==c||0!==e&&3!==u.nodeType||(h=g+e);u!==f||0!==d&&3!==u.nodeType||(k=g+d);3===u.nodeType&&(g+=u.nodeValue.length);if(null===(p=u.firstChild))break;r=u;u=p}for(;;){if(u===a)break b;r===c&&++n===e&&(h=g);r===f&&++q===d&&(k=g);if(null!==(p=u.nextSibling))break;u=r;r=u.parentNode}u=p}c=-1===h||-1===k?null:
{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Kf={focusedElem:a,selectionRange:c};Zc=!1;for(l=b;null!==l;)if(b=l,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,l=a;else for(;null!==l;){b=l;try{var x=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;case 1:if(null!==x){var v=x.memoizedProps,z=x.memoizedState,w=b.stateNode,A=w.getSnapshotBeforeUpdate(b.elementType===b.type?v:ya(b.type,v),z);w.__reactInternalSnapshotBeforeUpdate=A}break;case 3:var t=
b.stateNode.containerInfo;1===t.nodeType?t.textContent="":9===t.nodeType&&t.documentElement&&t.removeChild(t.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(m(163));}}catch(M){G(b,b.return,M)}a=b.sibling;if(null!==a){a.return=b.return;l=a;break}l=b.return}x=zi;zi=!1;return x}function Gc(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&If(b,c,f)}e=e.next}while(e!==d)}}
function Id(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Lf(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}"function"===typeof b?b(a):b.current=a}}function Ai(a){var b=a.alternate;null!==b&&(a.alternate=null,Ai(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Da],delete b[uc],delete b[Me],delete b[Dk],
delete b[Ek]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Bi(a){return 5===a.tag||3===a.tag||4===a.tag}function Ci(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Bi(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&
2))return a.stateNode}}function Mf(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=kd));else if(4!==d&&(a=a.child,null!==a))for(Mf(a,b,c),a=a.sibling;null!==a;)Mf(a,b,c),a=a.sibling}function Nf(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);
else if(4!==d&&(a=a.child,null!==a))for(Nf(a,b,c),a=a.sibling;null!==a;)Nf(a,b,c),a=a.sibling}function jb(a,b,c){for(c=c.child;null!==c;)Di(a,b,c),c=c.sibling}function Di(a,b,c){if(Ca&&"function"===typeof Ca.onCommitFiberUnmount)try{Ca.onCommitFiberUnmount(Uc,c)}catch(h){}switch(c.tag){case 5:X||Wb(c,b);case 6:var d=T,e=za;T=null;jb(a,b,c);T=d;za=e;null!==T&&(za?(a=T,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):T.removeChild(c.stateNode));break;case 18:null!==T&&(za?
(a=T,c=c.stateNode,8===a.nodeType?Re(a.parentNode,c):1===a.nodeType&&Re(a,c),nc(a)):Re(T,c.stateNode));break;case 4:d=T;e=za;T=c.stateNode.containerInfo;za=!0;jb(a,b,c);T=d;za=e;break;case 0:case 11:case 14:case 15:if(!X&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?If(c,b,g):0!==(f&4)&&If(c,b,g));e=e.next}while(e!==d)}jb(a,b,c);break;case 1:if(!X&&(Wb(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=
c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){G(c,b,h)}jb(a,b,c);break;case 21:jb(a,b,c);break;case 22:c.mode&1?(X=(d=X)||null!==c.memoizedState,jb(a,b,c),X=d):jb(a,b,c);break;default:jb(a,b,c)}}function Ei(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Fk);b.forEach(function(b){var d=Gk.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Aa(a,b,c){c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=
c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:T=h.stateNode;za=!1;break a;case 3:T=h.stateNode.containerInfo;za=!0;break a;case 4:T=h.stateNode.containerInfo;za=!0;break a}h=h.return}if(null===T)throw Error(m(160));Di(f,g,e);T=null;za=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(n){G(e,b,n)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)Fi(b,a),b=b.sibling}function Fi(a,b,c){var d=a.alternate;c=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:Aa(b,a);
Ha(a);if(c&4){try{Gc(3,a,a.return),Id(3,a)}catch(I){G(a,a.return,I)}try{Gc(5,a,a.return)}catch(I){G(a,a.return,I)}}break;case 1:Aa(b,a);Ha(a);c&512&&null!==d&&Wb(d,d.return);break;case 5:Aa(b,a);Ha(a);c&512&&null!==d&&Wb(d,d.return);if(a.flags&32){var e=a.stateNode;try{Fc(e,"")}catch(I){G(a,a.return,I)}}if(c&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==d?d.memoizedProps:f,h=a.type,k=a.updateQueue;a.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&lg(e,f);
qe(h,g);var n=qe(h,f);for(g=0;g<k.length;g+=2){var q=k[g],u=k[g+1];"style"===q?sg(e,u):"dangerouslySetInnerHTML"===q?yi(e,u):"children"===q?Fc(e,u):$d(e,q,u,n)}switch(h){case "input":le(e,f);break;case "textarea":og(e,f);break;case "select":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var p=f.value;null!=p?Db(e,!!f.multiple,p,!1):r!==!!f.multiple&&(null!=f.defaultValue?Db(e,!!f.multiple,f.defaultValue,!0):Db(e,!!f.multiple,f.multiple?[]:"",!1))}e[uc]=f}catch(I){G(a,a.return,
I)}}break;case 6:Aa(b,a);Ha(a);if(c&4){if(null===a.stateNode)throw Error(m(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(I){G(a,a.return,I)}}break;case 3:Aa(b,a);Ha(a);if(c&4&&null!==d&&d.memoizedState.isDehydrated)try{nc(b.containerInfo)}catch(I){G(a,a.return,I)}break;case 4:Aa(b,a);Ha(a);break;case 13:Aa(b,a);Ha(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||null!==e.alternate&&null!==e.alternate.memoizedState||(Of=P()));c&4&&Ei(a);break;case 22:q=
null!==d&&null!==d.memoizedState;a.mode&1?(X=(n=X)||q,Aa(b,a),X=n):Aa(b,a);Ha(a);if(c&8192){n=null!==a.memoizedState;if((a.stateNode.isHidden=n)&&!q&&0!==(a.mode&1))for(l=a,q=a.child;null!==q;){for(u=l=q;null!==l;){r=l;p=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Gc(4,r,r.return);break;case 1:Wb(r,r.return);var x=r.stateNode;if("function"===typeof x.componentWillUnmount){c=r;b=r.return;try{d=c,x.props=d.memoizedProps,x.state=d.memoizedState,x.componentWillUnmount()}catch(I){G(c,b,I)}}break;
case 5:Wb(r,r.return);break;case 22:if(null!==r.memoizedState){Gi(u);continue}}null!==p?(p.return=r,l=p):Gi(u)}q=q.sibling}a:for(q=null,u=a;;){if(5===u.tag){if(null===q){q=u;try{e=u.stateNode,n?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=u.stateNode,k=u.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=rg("display",g))}catch(I){G(a,a.return,I)}}}else if(6===u.tag){if(null===q)try{u.stateNode.nodeValue=
n?"":u.memoizedProps}catch(I){G(a,a.return,I)}}else if((22!==u.tag&&23!==u.tag||null===u.memoizedState||u===a)&&null!==u.child){u.child.return=u;u=u.child;continue}if(u===a)break a;for(;null===u.sibling;){if(null===u.return||u.return===a)break a;q===u&&(q=null);u=u.return}q===u&&(q=null);u.sibling.return=u.return;u=u.sibling}}break;case 19:Aa(b,a);Ha(a);c&4&&Ei(a);break;case 21:break;default:Aa(b,a),Ha(a)}}function Ha(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Bi(c)){var d=c;
break a}c=c.return}throw Error(m(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(Fc(e,""),d.flags&=-33);var f=Ci(a);Nf(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Ci(a);Mf(a,h,g);break;default:throw Error(m(161));}}catch(k){G(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function Hk(a,b,c){l=a;Hi(a,b,c)}function Hi(a,b,c){for(var d=0!==(a.mode&1);null!==l;){var e=l,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Jd;if(!g){var h=e.alternate,k=null!==h&&null!==
h.memoizedState||X;h=Jd;var n=X;Jd=g;if((X=k)&&!n)for(l=e;null!==l;)g=l,k=g.child,22===g.tag&&null!==g.memoizedState?Ii(e):null!==k?(k.return=g,l=k):Ii(e);for(;null!==f;)l=f,Hi(f,b,c),f=f.sibling;l=e;Jd=h;X=n}Ji(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,l=f):Ji(a,b,c)}}function Ji(a,b,c){for(;null!==l;){b=l;if(0!==(b.flags&8772)){c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:X||Id(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!X)if(null===c)d.componentDidMount();
else{var e=b.elementType===b.type?c.memoizedProps:ya(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&Hh(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=b.child.stateNode;break;case 1:c=b.child.stateNode}Hh(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&
c.focus();break;case "img":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var n=b.alternate;if(null!==n){var q=n.memoizedState;if(null!==q){var p=q.dehydrated;null!==p&&nc(p)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(m(163));}X||b.flags&512&&Lf(b)}catch(r){G(b,b.return,r)}}if(b===a){l=null;break}c=b.sibling;if(null!==c){c.return=b.return;l=c;break}l=b.return}}function Gi(a){for(;null!==l;){var b=l;if(b===
a){l=null;break}var c=b.sibling;if(null!==c){c.return=b.return;l=c;break}l=b.return}}function Ii(a){for(;null!==l;){var b=l;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Id(4,b)}catch(k){G(b,c,k)}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){G(b,e,k)}}var f=b.return;try{Lf(b)}catch(k){G(b,f,k)}break;case 5:var g=b.return;try{Lf(b)}catch(k){G(b,g,k)}}}catch(k){G(b,b.return,k)}if(b===a){l=null;break}var h=b.sibling;
if(null!==h){h.return=b.return;l=h;break}l=b.return}}function Hc(){Hf=P()+500}function Z(){return 0!==(p&6)?P():-1!==Kd?Kd:Kd=P()}function hb(a){if(0===(a.mode&1))return 1;if(0!==(p&2)&&0!==U)return U&-U;if(null!==Ik.transition)return 0===Ld&&(Ld=Dg()),Ld;a=z;if(0!==a)return a;a=window.event;a=void 0===a?16:Lg(a.type);return a}function xa(a,b,c,d){if(50<Ic)throw Ic=0,Pf=null,Error(m(185));ic(a,c,d);if(0===(p&2)||a!==O)a===O&&(0===(p&2)&&(Md|=c),4===L&&kb(a,U)),ia(a,d),1===c&&0===p&&0===(b.mode&1)&&
(Hc(),md&&db())}function ia(a,b){var c=a.callbackNode;tj(a,b);var d=Vc(a,a===O?U:0);if(0===d)null!==c&&Ki(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&Ki(c);if(1===b)0===a.tag?jk(Li.bind(null,a)):wh(Li.bind(null,a)),Jk(function(){0===(p&6)&&db()}),c=null;else{switch(Eg(d)){case 1:c=De;break;case 4:c=Mg;break;case 16:c=ad;break;case 536870912:c=Ng;break;default:c=ad}c=Mi(c,Ni.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}function Ni(a,b){Kd=-1;
Ld=0;if(0!==(p&6))throw Error(m(327));var c=a.callbackNode;if(Xb()&&a.callbackNode!==c)return null;var d=Vc(a,a===O?U:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Nd(a,d);else{b=d;var e=p;p|=2;var f=Oi();if(O!==a||U!==b)Ra=null,Hc(),wb(a,b);do try{Kk();break}catch(h){Pi(a,h)}while(1);af();Od.current=f;p=e;null!==H?b=0:(O=null,U=0,b=L)}if(0!==b){2===b&&(e=ve(a),0!==e&&(d=e,b=Qf(a,e)));if(1===b)throw c=Jc,wb(a,0),kb(a,d),ia(a,P()),c;if(6===b)kb(a,d);else{e=a.current.alternate;
if(0===(d&30)&&!Lk(e)&&(b=Nd(a,d),2===b&&(f=ve(a),0!==f&&(d=f,b=Qf(a,f))),1===b))throw c=Jc,wb(a,0),kb(a,d),ia(a,P()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(m(345));case 2:xb(a,ja,Ra);break;case 3:kb(a,d);if((d&130023424)===d&&(b=Of+500-P(),10<b)){if(0!==Vc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){Z();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Rf(xb.bind(null,a,ja,Ra),b);break}xb(a,ja,Ra);break;case 4:kb(a,d);if((d&4194240)===d)break;b=a.eventTimes;
for(e=-1;0<d;){var g=31-ta(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=P()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*Mk(d/1960))-d;if(10<d){a.timeoutHandle=Rf(xb.bind(null,a,ja,Ra),d);break}xb(a,ja,Ra);break;case 5:xb(a,ja,Ra);break;default:throw Error(m(329));}}}ia(a,P());return a.callbackNode===c?Ni.bind(null,a):null}function Qf(a,b){var c=Kc;a.current.memoizedState.isDehydrated&&(wb(a,b).flags|=256);a=Nd(a,b);2!==a&&(b=ja,ja=c,null!==b&&Gf(b));return a}function Gf(a){null===
ja?ja=a:ja.push.apply(ja,a)}function Lk(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!ua(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}function kb(a,b){b&=~Sf;b&=~Md;a.suspendedLanes|=b;a.pingedLanes&=
~b;for(a=a.expirationTimes;0<b;){var c=31-ta(b),d=1<<c;a[c]=-1;b&=~d}}function Li(a){if(0!==(p&6))throw Error(m(327));Xb();var b=Vc(a,0);if(0===(b&1))return ia(a,P()),null;var c=Nd(a,b);if(0!==a.tag&&2===c){var d=ve(a);0!==d&&(b=d,c=Qf(a,d))}if(1===c)throw c=Jc,wb(a,0),kb(a,b),ia(a,P()),c;if(6===c)throw Error(m(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;xb(a,ja,Ra);ia(a,P());return null}function Tf(a,b){var c=p;p|=1;try{return a(b)}finally{p=c,0===p&&(Hc(),md&&db())}}function yb(a){null!==
lb&&0===lb.tag&&0===(p&6)&&Xb();var b=p;p|=1;var c=ca.transition,d=z;try{if(ca.transition=null,z=1,a)return a()}finally{z=d,ca.transition=c,p=b,0===(p&6)&&db()}}function wb(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Nk(c));if(null!==H)for(c=H.return;null!==c;){var d=c;Ve(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(v(S),v(J));break;case 3:Tb();v(S);v(J);jf();break;case 5:hf(d);break;case 4:Tb();break;case 13:v(F);break;
case 19:v(F);break;case 10:cf(d.type._context);break;case 22:case 23:ba=Ga.current,v(Ga)}c=c.return}O=a;H=a=eb(a.current,null);U=ba=b;L=0;Jc=null;Sf=Md=ra=0;ja=Kc=null;if(null!==tb){for(b=0;b<tb.length;b++)if(c=tb[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}tb=null}return a}function Pi(a,b){do{var c=H;try{af();yd.current=zd;if(Ad){for(var d=C.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Ad=
!1}vb=0;N=K=C=null;zc=!1;Ac=0;Uf.current=null;if(null===c||null===c.return){L=1;Jc=b;H=null;break}a:{var f=a,g=c.return,h=c,k=b;b=U;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var n=k,l=h,p=l.tag;if(0===(l.mode&1)&&(0===p||11===p||15===p)){var r=l.alternate;r?(l.updateQueue=r.updateQueue,l.memoizedState=r.memoizedState,l.lanes=r.lanes):(l.updateQueue=null,l.memoizedState=null)}var v=ji(g);if(null!==v){v.flags&=-257;ki(v,g,h,f,b);v.mode&1&&ii(f,n,b);b=v;k=n;var x=b.updateQueue;
if(null===x){var z=new Set;z.add(k);b.updateQueue=z}else x.add(k);break a}else{if(0===(b&1)){ii(f,n,b);Ef();break a}k=Error(m(426))}}else if(D&&h.mode&1){var y=ji(g);if(null!==y){0===(y.flags&65536)&&(y.flags|=256);ki(y,g,h,f,b);Ye(Ub(k,h));break a}}f=k=Ub(k,h);4!==L&&(L=2);null===Kc?Kc=[f]:Kc.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;b&=-b;f.lanes|=b;var w=gi(f,k,b);Gh(f,w);break a;case 1:h=k;var A=f.type,t=f.stateNode;if(0===(f.flags&128)&&("function"===typeof A.getDerivedStateFromError||
null!==t&&"function"===typeof t.componentDidCatch&&(null===ib||!ib.has(t)))){f.flags|=65536;b&=-b;f.lanes|=b;var B=hi(f,h,b);Gh(f,B);break a}}f=f.return}while(null!==f)}Qi(c)}catch(ma){b=ma;H===c&&null!==c&&(H=c=c.return);continue}break}while(1)}function Oi(){var a=Od.current;Od.current=zd;return null===a?zd:a}function Ef(){if(0===L||3===L||2===L)L=4;null===O||0===(ra&268435455)&&0===(Md&268435455)||kb(O,U)}function Nd(a,b){var c=p;p|=2;var d=Oi();if(O!==a||U!==b)Ra=null,wb(a,b);do try{Ok();break}catch(e){Pi(a,
e)}while(1);af();p=c;Od.current=d;if(null!==H)throw Error(m(261));O=null;U=0;return L}function Ok(){for(;null!==H;)Ri(H)}function Kk(){for(;null!==H&&!Pk();)Ri(H)}function Ri(a){var b=Qk(a.alternate,a,ba);a.memoizedProps=a.pendingProps;null===b?Qi(a):H=b;Uf.current=null}function Qi(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=xk(c,b,ba),null!==c){H=c;return}}else{c=Bk(c,b);if(null!==c){c.flags&=32767;H=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;
else{L=6;H=null;return}}b=b.sibling;if(null!==b){H=b;return}H=b=a}while(null!==b);0===L&&(L=5)}function xb(a,b,c){var d=z,e=ca.transition;try{ca.transition=null,z=1,Rk(a,b,c,d)}finally{ca.transition=e,z=d}return null}function Rk(a,b,c,d){do Xb();while(null!==lb);if(0!==(p&6))throw Error(m(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(m(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;
uj(a,f);a===O&&(H=O=null,U=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||Pd||(Pd=!0,Mi(ad,function(){Xb();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=ca.transition;ca.transition=null;var g=z;z=1;var h=p;p|=4;Uf.current=null;Ck(a,c);Fi(c,a);Tj(Kf);Zc=!!Jf;Kf=Jf=null;a.current=c;Hk(c,a,e);Sk();p=h;z=g;ca.transition=f}else a.current=c;Pd&&(Pd=!1,lb=a,Qd=e);f=a.pendingLanes;0===f&&(ib=null);oj(c.stateNode,d);ia(a,P());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=
b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Ed)throw Ed=!1,a=xf,xf=null,a;0!==(Qd&1)&&0!==a.tag&&Xb();f=a.pendingLanes;0!==(f&1)?a===Pf?Ic++:(Ic=0,Pf=a):Ic=0;db();return null}function Xb(){if(null!==lb){var a=Eg(Qd),b=ca.transition,c=z;try{ca.transition=null;z=16>a?16:a;if(null===lb)var d=!1;else{a=lb;lb=null;Qd=0;if(0!==(p&6))throw Error(m(331));var e=p;p|=4;for(l=a.current;null!==l;){var f=l,g=f.child;if(0!==(l.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var n=
h[k];for(l=n;null!==l;){var q=l;switch(q.tag){case 0:case 11:case 15:Gc(8,q,f)}var u=q.child;if(null!==u)u.return=q,l=u;else for(;null!==l;){q=l;var r=q.sibling,v=q.return;Ai(q);if(q===n){l=null;break}if(null!==r){r.return=v;l=r;break}l=v}}}var x=f.alternate;if(null!==x){var y=x.child;if(null!==y){x.child=null;do{var C=y.sibling;y.sibling=null;y=C}while(null!==y)}}l=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,l=g;else b:for(;null!==l;){f=l;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Gc(9,
f,f.return)}var w=f.sibling;if(null!==w){w.return=f.return;l=w;break b}l=f.return}}var A=a.current;for(l=A;null!==l;){g=l;var t=g.child;if(0!==(g.subtreeFlags&2064)&&null!==t)t.return=g,l=t;else b:for(g=A;null!==l;){h=l;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Id(9,h)}}catch(ma){G(h,h.return,ma)}if(h===g){l=null;break b}var B=h.sibling;if(null!==B){B.return=h.return;l=B;break b}l=h.return}}p=e;db();if(Ca&&"function"===typeof Ca.onPostCommitFiberRoot)try{Ca.onPostCommitFiberRoot(Uc,
a)}catch(ma){}d=!0}return d}finally{z=c,ca.transition=b}}return!1}function Si(a,b,c){b=Ub(c,b);b=gi(a,b,1);a=fb(a,b,1);b=Z();null!==a&&(ic(a,1,b),ia(a,b))}function G(a,b,c){if(3===a.tag)Si(a,a,c);else for(;null!==b;){if(3===b.tag){Si(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===ib||!ib.has(d))){a=Ub(c,a);a=hi(b,a,1);b=fb(b,a,1);a=Z();null!==b&&(ic(b,1,a),ia(b,a));break}}b=b.return}}function sk(a,
b,c){var d=a.pingCache;null!==d&&d.delete(b);b=Z();a.pingedLanes|=a.suspendedLanes&c;O===a&&(U&c)===c&&(4===L||3===L&&(U&130023424)===U&&500>P()-Of?wb(a,0):Sf|=c);ia(a,b)}function Ti(a,b){0===b&&(0===(a.mode&1)?b=1:(b=Rd,Rd<<=1,0===(Rd&130023424)&&(Rd=4194304)));var c=Z();a=Oa(a,b);null!==a&&(ic(a,b,c),ia(a,c))}function vk(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Ti(a,c)}function Gk(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);
break;case 19:d=a.stateNode;break;default:throw Error(m(314));}null!==d&&d.delete(b);Ti(a,c)}function Mi(a,b){return xh(a,b)}function Tk(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function yf(a){a=
a.prototype;return!(!a||!a.isReactComponent)}function Uk(a){if("function"===typeof a)return yf(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===ie)return 11;if(a===je)return 14}return 2}function eb(a,b){var c=a.alternate;null===c?(c=pa(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=
a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function rd(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)yf(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case Bb:return sb(c.children,e,f,b);case fe:g=8;e|=8;break;case ee:return a=pa(12,c,b,e|2),a.elementType=ee,a.lanes=f,a;case ge:return a=
pa(13,c,b,e),a.elementType=ge,a.lanes=f,a;case he:return a=pa(19,c,b,e),a.elementType=he,a.lanes=f,a;case Ui:return Gd(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case hg:g=10;break a;case gg:g=9;break a;case ie:g=11;break a;case je:g=14;break a;case Ta:g=16;d=null;break a}throw Error(m(130,null==a?a:typeof a,""));}b=pa(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function sb(a,b,c,d){a=pa(7,a,d,b);a.lanes=c;return a}function Gd(a,b,c,d){a=pa(22,a,d,b);a.elementType=
Ui;a.lanes=c;a.stateNode={isHidden:!1};return a}function Ze(a,b,c){a=pa(6,a,null,b);a.lanes=c;return a}function $e(a,b,c){b=pa(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Vk(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=
0;this.eventTimes=we(0);this.expirationTimes=we(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=we(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=null}function Vf(a,b,c,d,e,f,g,h,k,l){a=new Vk(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=pa(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,
pendingSuspenseBoundaries:null};ff(f);return a}function Wk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:Cb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Vi(a){if(!a)return cb;a=a._reactInternals;a:{if(nb(a)!==a||1!==a.tag)throw Error(m(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(ea(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(m(171));
}if(1===a.tag){var c=a.type;if(ea(c))return uh(a,c,b)}return b}function Wi(a,b,c,d,e,f,g,h,k,l){a=Vf(c,d,!0,a,e,f,g,h,k);a.context=Vi(null);c=a.current;d=Z();e=hb(c);f=Pa(d,e);f.callback=void 0!==b&&null!==b?b:null;fb(c,f,e);a.current.lanes=e;ic(a,e,d);ia(a,d);return a}function Sd(a,b,c,d){var e=b.current,f=Z(),g=hb(e);c=Vi(c);null===b.context?b.context=c:b.pendingContext=c;b=Pa(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=fb(e,b,g);null!==a&&(xa(a,e,g,f),vd(a,e,g));return g}
function Td(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Xi(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function Wf(a,b){Xi(a,b);(a=a.alternate)&&Xi(a,b)}function Xk(a){a=Bg(a);return null===a?null:a.stateNode}function Yk(a){return null}function Xf(a){this._internalRoot=a}function Ud(a){this._internalRoot=a}function Yf(a){return!(!a||1!==a.nodeType&&9!==
a.nodeType&&11!==a.nodeType)}function Vd(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Yi(){}function Zk(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=Td(g);f.call(a)}}var g=Wi(b,d,a,0,null,!1,!1,"",Yi);a._reactRootContainer=g;a[Ja]=g.current;sc(8===a.nodeType?a.parentNode:a);yb();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=Td(k);
h.call(a)}}var k=Vf(a,0,!1,null,null,!1,!1,"",Yi);a._reactRootContainer=k;a[Ja]=k.current;sc(8===a.nodeType?a.parentNode:a);yb(function(){Sd(b,k,c,d)});return k}function Wd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=Td(g);h.call(a)}}Sd(b,g,a,e)}else g=Zk(c,b,a,e,d);return Td(g)}var cg=new Set,$b={},Ia=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),Zd=Object.prototype.hasOwnProperty,
cj=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,eg={},dg={},R={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){R[a]=
new Y(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];R[b]=new Y(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){R[a]=new Y(a,2,!1,a.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){R[a]=new Y(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){R[a]=
new Y(a,3,!1,a.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(a){R[a]=new Y(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){R[a]=new Y(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){R[a]=new Y(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){R[a]=new Y(a,5,!1,a.toLowerCase(),null,!1,!1)});var Zf=/[\-:]([a-z])/g,$f=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(Zf,$f);R[b]=new Y(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(Zf,$f);R[b]=new Y(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(Zf,$f);R[b]=new Y(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){R[a]=new Y(a,1,!1,a.toLowerCase(),null,!1,!1)});R.xlinkHref=new Y("xlinkHref",
1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){R[a]=new Y(a,1,!1,a.toLowerCase(),null,!0,!0)});var Sa=zb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,sd=Symbol.for("react.element"),Cb=Symbol.for("react.portal"),Bb=Symbol.for("react.fragment"),fe=Symbol.for("react.strict_mode"),ee=Symbol.for("react.profiler"),hg=Symbol.for("react.provider"),gg=Symbol.for("react.context"),ie=Symbol.for("react.forward_ref"),ge=Symbol.for("react.suspense"),
he=Symbol.for("react.suspense_list"),je=Symbol.for("react.memo"),Ta=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");var Ui=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var fg=Symbol.iterator,E=Object.assign,ae,ce=!1,cc=Array.isArray,Xd,yi=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,
c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{Xd=Xd||document.createElement("div");Xd.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=Xd.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Fc=function(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},dc={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,
borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,
strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},$k=["Webkit","ms","Moz","O"];Object.keys(dc).forEach(function(a){$k.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);dc[b]=dc[a]})});var ij=E({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ze=null,se=null,Eb=null,Fb=null,xg=function(a,b){return a(b)},yg=function(){},te=!1,Oe=!1;if(Ia)try{var Lc={};Object.defineProperty(Lc,
"passive",{get:function(){Oe=!0}});window.addEventListener("test",Lc,Lc);window.removeEventListener("test",Lc,Lc)}catch(a){Oe=!1}var kj=function(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(q){this.onError(q)}},gc=!1,Sc=null,Tc=!1,ue=null,lj={onError:function(a){gc=!0;Sc=a}},Ba=zb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Jg=Ba.unstable_scheduleCallback,Kg=Ba.unstable_NormalPriority,xh=Jg,Ki=Ba.unstable_cancelCallback,Pk=Ba.unstable_shouldYield,
Sk=Ba.unstable_requestPaint,P=Ba.unstable_now,Dj=Ba.unstable_getCurrentPriorityLevel,De=Ba.unstable_ImmediatePriority,Mg=Ba.unstable_UserBlockingPriority,ad=Kg,Ej=Ba.unstable_LowPriority,Ng=Ba.unstable_IdlePriority,Uc=null,Ca=null,ta=Math.clz32?Math.clz32:pj,qj=Math.log,rj=Math.LN2,Wc=64,Rd=4194304,z=0,Ae=!1,Yc=[],Va=null,Wa=null,Xa=null,jc=new Map,kc=new Map,Ya=[],Bj="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "),
Gb=Sa.ReactCurrentBatchConfig,Zc=!0,$c=null,Za=null,Ee=null,bd=null,Yb={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},He=ka(Yb),Mc=E({},Yb,{view:0,detail:0}),ak=ka(Mc),ag,bg,Nc,Yd=E({},Mc,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Fe,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:
a.relatedTarget},movementX:function(a){if("movementX"in a)return a.movementX;a!==Nc&&(Nc&&"mousemove"===a.type?(ag=a.screenX-Nc.screenX,bg=a.screenY-Nc.screenY):bg=ag=0,Nc=a);return ag},movementY:function(a){return"movementY"in a?a.movementY:bg}}),ih=ka(Yd),al=E({},Yd,{dataTransfer:0}),Wj=ka(al),bl=E({},Mc,{relatedTarget:0}),Pe=ka(bl),cl=E({},Yb,{animationName:0,elapsedTime:0,pseudoElement:0}),Yj=ka(cl),dl=E({},Yb,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),
ck=ka(dl),el=E({},Yb,{data:0}),qh=ka(el),fk=qh,fl={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},gl={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",
112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Gj={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},hl=E({},Mc,{key:function(a){if(a.key){var b=fl[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=cd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?gl[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,
metaKey:0,repeat:0,locale:0,getModifierState:Fe,charCode:function(a){return"keypress"===a.type?cd(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===a.type?cd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Vj=ka(hl),il=E({},Yd,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),nh=ka(il),jl=E({},Mc,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,
ctrlKey:0,shiftKey:0,getModifierState:Fe}),Xj=ka(jl),kl=E({},Yb,{propertyName:0,elapsedTime:0,pseudoElement:0}),Zj=ka(kl),ll=E({},Yd,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),bk=ka(ll),Hj=[9,13,27,32],Ge=Ia&&"CompositionEvent"in window,Oc=null;Ia&&"documentMode"in document&&(Oc=document.documentMode);var ek=Ia&&"TextEvent"in
window&&!Oc,Ug=Ia&&(!Ge||Oc&&8<Oc&&11>=Oc),Tg=String.fromCharCode(32),Sg=!1,Hb=!1,Kj={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},oc=null,pc=null,ph=!1;Ia&&(ph=Lj("input")&&(!document.documentMode||9<document.documentMode));var ua="function"===typeof Object.is?Object.is:Sj,dk=Ia&&"documentMode"in document&&11>=document.documentMode,Jb=null,Ke=null,rc=null,Je=!1,Kb={animationend:gd("Animation","AnimationEnd"),
animationiteration:gd("Animation","AnimationIteration"),animationstart:gd("Animation","AnimationStart"),transitionend:gd("Transition","TransitionEnd")},Le={},eh={};Ia&&(eh=document.createElement("div").style,"AnimationEvent"in window||(delete Kb.animationend.animation,delete Kb.animationiteration.animation,delete Kb.animationstart.animation),"TransitionEvent"in window||delete Kb.transitionend.transition);var jh=hd("animationend"),kh=hd("animationiteration"),lh=hd("animationstart"),mh=hd("transitionend"),
fh=new Map,Zi="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
(function(){for(var a=0;a<Zi.length;a++){var b=Zi[a],c=b.toLowerCase();b=b[0].toUpperCase()+b.slice(1);$a(c,"on"+b)}$a(jh,"onAnimationEnd");$a(kh,"onAnimationIteration");$a(lh,"onAnimationStart");$a("dblclick","onDoubleClick");$a("focusin","onFocus");$a("focusout","onBlur");$a(mh,"onTransitionEnd")})();Ab("onMouseEnter",["mouseout","mouseover"]);Ab("onMouseLeave",["mouseout","mouseover"]);Ab("onPointerEnter",["pointerout","pointerover"]);Ab("onPointerLeave",["pointerout","pointerover"]);mb("onChange",
"change click focusin focusout input keydown keyup selectionchange".split(" "));mb("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));mb("onBeforeInput",["compositionend","keypress","textInput","paste"]);mb("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));mb("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));mb("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Ec="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Uj=new Set("cancel close invalid load scroll toggle".split(" ").concat(Ec)),id="_reactListening"+Math.random().toString(36).slice(2),gk=/\r\n?/g,hk=/\u0000|\uFFFD/g,Jf=null,Kf=null,Rf="function"===typeof setTimeout?setTimeout:void 0,Nk="function"===typeof clearTimeout?
clearTimeout:void 0,$i="function"===typeof Promise?Promise:void 0,Jk="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof $i?function(a){return $i.resolve(null).then(a).catch(ik)}:Rf,Zb=Math.random().toString(36).slice(2),Da="__reactFiber$"+Zb,uc="__reactProps$"+Zb,Ja="__reactContainer$"+Zb,Me="__reactEvents$"+Zb,Dk="__reactListeners$"+Zb,Ek="__reactHandles$"+Zb,Se=[],Mb=-1,cb={},J=bb(cb),S=bb(!1),pb=cb,La=null,md=!1,Te=!1,Ob=[],Pb=0,od=null,nd=0,na=[],oa=0,rb=null,Ma=1,Na="",la=
null,fa=null,D=!1,wa=null,Ik=Sa.ReactCurrentBatchConfig,Vb=Dh(!0),li=Dh(!1),ud=bb(null),td=null,Rb=null,bf=null,tb=null,kk=Oa,gb=!1,wc={},Ea=bb(wc),yc=bb(wc),xc=bb(wc),F=bb(0),kf=[],yd=Sa.ReactCurrentDispatcher,sf=Sa.ReactCurrentBatchConfig,vb=0,C=null,K=null,N=null,Ad=!1,zc=!1,Ac=0,ml=0,zd={readContext:qa,useCallback:V,useContext:V,useEffect:V,useImperativeHandle:V,useInsertionEffect:V,useLayoutEffect:V,useMemo:V,useReducer:V,useRef:V,useState:V,useDebugValue:V,useDeferredValue:V,useTransition:V,
useMutableSource:V,useSyncExternalStore:V,useId:V,unstable_isNewReconciler:!1},lk={readContext:qa,useCallback:function(a,b){Fa().memoizedState=[a,void 0===b?null:b];return a},useContext:qa,useEffect:Sh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Bd(4194308,4,Vh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Bd(4194308,4,a,b)},useInsertionEffect:function(a,b){return Bd(4,2,a,b)},useMemo:function(a,b){var c=Fa();b=void 0===b?null:b;a=a();c.memoizedState=
[a,b];return a},useReducer:function(a,b,c){var d=Fa();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=qk.bind(null,C,a);return[d.memoizedState,a]},useRef:function(a){var b=Fa();a={current:a};return b.memoizedState=a},useState:Qh,useDebugValue:rf,useDeferredValue:function(a){return Fa().memoizedState=a},useTransition:function(){var a=Qh(!1),b=a[0];a=pk.bind(null,a[1]);Fa().memoizedState=
a;return[b,a]},useMutableSource:function(a,b,c){},useSyncExternalStore:function(a,b,c){var d=C,e=Fa();if(D){if(void 0===c)throw Error(m(407));c=c()}else{c=b();if(null===O)throw Error(m(349));0!==(vb&30)||Nh(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;Sh(Lh.bind(null,d,f,a),[a]);d.flags|=2048;Cc(9,Mh.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=Fa(),b=O.identifierPrefix;if(D){var c=Na;var d=Ma;c=(d&~(1<<32-ta(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Ac++;0<c&&
(b+="H"+c.toString(32));b+=":"}else c=ml++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},mk={readContext:qa,useCallback:Xh,useContext:qa,useEffect:qf,useImperativeHandle:Wh,useInsertionEffect:Th,useLayoutEffect:Uh,useMemo:Yh,useReducer:of,useRef:Rh,useState:function(a){return of(Bc)},useDebugValue:rf,useDeferredValue:function(a){var b=sa();return Zh(b,K.memoizedState,a)},useTransition:function(){var a=of(Bc)[0],b=sa().memoizedState;return[a,b]},useMutableSource:Jh,
useSyncExternalStore:Kh,useId:$h,unstable_isNewReconciler:!1},nk={readContext:qa,useCallback:Xh,useContext:qa,useEffect:qf,useImperativeHandle:Wh,useInsertionEffect:Th,useLayoutEffect:Uh,useMemo:Yh,useReducer:pf,useRef:Rh,useState:function(a){return pf(Bc)},useDebugValue:rf,useDeferredValue:function(a){var b=sa();return null===K?b.memoizedState=a:Zh(b,K.memoizedState,a)},useTransition:function(){var a=pf(Bc)[0],b=sa().memoizedState;return[a,b]},useMutableSource:Jh,useSyncExternalStore:Kh,useId:$h,
unstable_isNewReconciler:!1},Dd={isMounted:function(a){return(a=a._reactInternals)?nb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=Z(),e=hb(a),f=Pa(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=fb(a,f,e);null!==b&&(xa(b,a,e,d),vd(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=Z(),e=hb(a),f=Pa(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=fb(a,f,e);null!==b&&(xa(b,a,e,d),vd(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;
var c=Z(),d=hb(a),e=Pa(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=fb(a,e,d);null!==b&&(xa(b,a,d,c),vd(b,a,d))}},rk="function"===typeof WeakMap?WeakMap:Map,tk=Sa.ReactCurrentOwner,ha=!1,Cf={dehydrated:null,treeContext:null,retryLane:0};var zk=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=
c.return;c=c.sibling}};var xi=function(a,b){};var yk=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){a=b.stateNode;ub(Ea.current);e=null;switch(c){case "input":f=ke(a,f);d=ke(a,d);e=[];break;case "select":f=E({},f,{value:void 0});d=E({},d,{value:void 0});e=[];break;case "textarea":f=ne(a,f);d=ne(a,d);e=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(a.onclick=kd)}pe(c,d);var g;c=null;for(l in f)if(!d.hasOwnProperty(l)&&f.hasOwnProperty(l)&&null!=f[l])if("style"===
l){var h=f[l];for(g in h)h.hasOwnProperty(g)&&(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&($b.hasOwnProperty(l)?e||(e=[]):(e=e||[]).push(l,null));for(l in d){var k=d[l];h=null!=f?f[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||
(c={}),c[g]=k[g])}else c||(e||(e=[]),e.push(l,c)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(e=e||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(e=e||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&($b.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&B("scroll",a),e||h===k||(e=[])):(e=e||[]).push(l,k))}c&&(e=e||[]).push("style",c);var l=e;if(b.updateQueue=l)b.flags|=4}};var Ak=function(a,
b,c,d){c!==d&&(b.flags|=4)};var Jd=!1,X=!1,Fk="function"===typeof WeakSet?WeakSet:Set,l=null,zi=!1,T=null,za=!1,Mk=Math.ceil,Od=Sa.ReactCurrentDispatcher,Uf=Sa.ReactCurrentOwner,ca=Sa.ReactCurrentBatchConfig,p=0,O=null,H=null,U=0,ba=0,Ga=bb(0),L=0,Jc=null,ra=0,Md=0,Sf=0,Kc=null,ja=null,Of=0,Hf=Infinity,Ra=null,Ed=!1,xf=null,ib=null,Pd=!1,lb=null,Qd=0,Ic=0,Pf=null,Kd=-1,Ld=0;var Qk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||S.current)ha=!0;else{if(0===(a.lanes&c)&&0===(b.flags&
128))return ha=!1,wk(a,b,c);ha=0!==(a.flags&131072)?!0:!1}else ha=!1,D&&0!==(b.flags&1048576)&&yh(b,nd,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;Fd(a,b);a=b.pendingProps;var e=Nb(b,J.current);Sb(b,c);e=mf(null,b,d,a,e,c);var f=nf();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=null,ea(d)?(f=!0,ld(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,ff(b),e.updater=Dd,b.stateNode=
e,e._reactInternals=b,uf(b,d,a,c),b=Af(null,b,d,!0,f,c)):(b.tag=0,D&&f&&Ue(b),aa(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{Fd(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=Uk(d);a=ya(d,a);switch(e){case 0:b=zf(null,b,d,a,c);break a;case 1:b=ri(null,b,d,a,c);break a;case 11:b=mi(null,b,d,a,c);break a;case 14:b=ni(null,b,d,ya(d.type,a),c);break a}throw Error(m(306,d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ya(d,e),zf(a,b,d,e,c);
case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ya(d,e),ri(a,b,d,e,c);case 3:a:{si(b);if(null===a)throw Error(m(387));d=b.pendingProps;f=b.memoizedState;e=f.element;Fh(a,b);wd(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=f,b.memoizedState=f,b.flags&256){e=Ub(Error(m(423)),b);b=ti(a,b,d,c,e);break a}else if(d!==e){e=
Ub(Error(m(424)),b);b=ti(a,b,d,c,e);break a}else for(fa=Ka(b.stateNode.containerInfo.firstChild),la=b,D=!0,wa=null,c=li(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Qb();if(d===e){b=Qa(a,b,c);break a}aa(a,b,d,c)}b=b.child}return b;case 5:return Ih(b),null===a&&Xe(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Qe(d,e)?g=null:null!==f&&Qe(d,f)&&(b.flags|=32),qi(a,b),aa(a,b,g,c),b.child;case 6:return null===a&&Xe(b),null;case 13:return ui(a,b,c);case 4:return gf(b,
b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Vb(b,null,d,c):aa(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ya(d,e),mi(a,b,d,e,c);case 7:return aa(a,b,b.pendingProps,c),b.child;case 8:return aa(a,b,b.pendingProps.children,c),b.child;case 12:return aa(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;g=e.value;y(ud,d._currentValue);d._currentValue=g;if(null!==f)if(ua(f.value,g)){if(f.children===
e.children&&!S.current){b=Qa(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=Pa(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var p=l.pending;null===p?k.next=k:(k.next=p.next,p.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);df(f.return,c,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===
f.tag){g=f.return;if(null===g)throw Error(m(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);df(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}aa(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,Sb(b,c),e=qa(e),d=d(e),b.flags|=1,aa(a,b,d,c),b.child;case 14:return d=b.type,e=ya(d,b.pendingProps),e=ya(d.type,e),ni(a,b,d,e,c);case 15:return oi(a,
b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ya(d,e),Fd(a,b),b.tag=1,ea(d)?(a=!0,ld(b)):a=!1,Sb(b,c),ei(b,d,e),uf(b,d,e,c),Af(null,b,d,!0,a,c);case 19:return wi(a,b,c);case 22:return pi(a,b,c)}throw Error(m(156,b.tag));};var pa=function(a,b,c,d){return new Tk(a,b,c,d)},aj="function"===typeof reportError?reportError:function(a){console.error(a)};Ud.prototype.render=Xf.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(m(409));
Sd(a,b,null,null)};Ud.prototype.unmount=Xf.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;yb(function(){Sd(null,a,null,null)});b[Ja]=null}};Ud.prototype.unstable_scheduleHydration=function(a){if(a){var b=nl();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Ya.length&&0!==b&&b<Ya[c].priority;c++);Ya.splice(c,0,a);0===c&&Hg(a)}};var Cj=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=
hc(b.pendingLanes);0!==c&&(xe(b,c|1),ia(b,P()),0===(p&6)&&(Hc(),db()))}break;case 13:yb(function(){var b=Oa(a,1);if(null!==b){var c=Z();xa(b,a,1,c)}}),Wf(a,1)}};var Gg=function(a){if(13===a.tag){var b=Oa(a,134217728);if(null!==b){var c=Z();xa(b,a,134217728,c)}Wf(a,134217728)}};var xj=function(a){if(13===a.tag){var b=hb(a),c=Oa(a,b);if(null!==c){var d=Z();xa(c,a,b,d)}Wf(a,b)}};var nl=function(){return z};var wj=function(a,b){var c=z;try{return z=a,b()}finally{z=c}};se=function(a,b,c){switch(b){case "input":le(a,
c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Rc(d);if(!e)throw Error(m(90));jg(d);le(d,e)}}}break;case "textarea":og(a,c);break;case "select":b=c.value,null!=b&&Db(a,!!c.multiple,b,!1)}};(function(a,b,c){xg=a;yg=c})(Tf,function(a,b,c,d,e){var f=z,g=ca.transition;try{return ca.transition=null,z=1,a(b,c,d,e)}finally{z=f,ca.transition=
g,0===p&&Hc()}},yb);var ol={usingClientEntryPoint:!1,Events:[ec,Ib,Rc,ug,vg,Tf]};(function(a){a={bundleType:a.bundleType,version:a.version,rendererPackageName:a.rendererPackageName,rendererConfig:a.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Sa.ReactCurrentDispatcher,findHostInstanceByFiber:Xk,
findFiberByHostInstance:a.findFiberByHostInstance||Yk,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1"};if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)a=!1;else{var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)a=!0;else{try{Uc=b.inject(a),Ca=b}catch(c){}a=b.checkDCE?!0:!1}}return a})({findFiberByHostInstance:ob,bundleType:0,version:"18.3.1-next-f1338f8080-20240426",
rendererPackageName:"react-dom"});Q.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ol;Q.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yf(b))throw Error(m(200));return Wk(a,b,null,c)};Q.createRoot=function(a,b){if(!Yf(a))throw Error(m(299));var c=!1,d="",e=aj;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=Vf(a,1,!1,null,null,
c,!1,d,e);a[Ja]=b.current;sc(8===a.nodeType?a.parentNode:a);return new Xf(b)};Q.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(m(188));a=Object.keys(a).join(",");throw Error(m(268,a));}a=Bg(b);a=null===a?null:a.stateNode;return a};Q.flushSync=function(a){return yb(a)};Q.hydrate=function(a,b,c){if(!Vd(b))throw Error(m(200));return Wd(null,a,b,!0,c)};Q.hydrateRoot=function(a,b,c){if(!Yf(a))throw Error(m(405));
var d=null!=c&&c.hydratedSources||null,e=!1,f="",g=aj;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=Wi(b,null,a,1,null!=c?c:null,e,!1,f,g);a[Ja]=b.current;sc(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,e);return new Ud(b)};Q.render=
function(a,b,c){if(!Vd(b))throw Error(m(200));return Wd(null,a,b,!1,c)};Q.unmountComponentAtNode=function(a){if(!Vd(a))throw Error(m(40));return a._reactRootContainer?(yb(function(){Wd(null,null,a,!1,function(){a._reactRootContainer=null;a[Ja]=null})}),!0):!1};Q.unstable_batchedUpdates=Tf;Q.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!Vd(c))throw Error(m(200));if(null==a||void 0===a._reactInternals)throw Error(m(38));return Wd(a,b,c,!1,d)};Q.version="18.3.1-next-f1338f8080-20240426"});
})();

  </script>
  <script src="components/calculators.js"></script>
  <script>
// === CAP OBSERVER LOG APP ===
var App = (() => {
  // app.jsx
  
var spMap = null;


var { useState, useEffect } = React;
  var CAPObserverLog = () => {
    const [missionInfo, setMissionInfo] = useState({
      missionNumber: "",
      missionSymbol: "",
      dateZ: "",
      sortieNumber: "",
      aircraftTailN: "",
      logPageNumber: "1",
      totalPages: "1",
      observerName: "",
      routeOfFlight: ""
    });
    // Crew Manifest
    const [crewManifest, setCrewManifest] = useState([
      { name: "", capid: "", position: "PIC", qualification: "MP" },
      { name: "", capid: "", position: "Crew", qualification: "" }
    ]);
    // Share Modal
    const [showShareModal, setShowShareModal] = useState(false);
    const [shareCode, setShareCode] = useState("");
    const [importCode, setImportCode] = useState("");
    const [times, setTimes] = useState({
      tachStart: "",
      tachShutdown: "",
      hobbsStart: "",
      hobbsShutdown: "",
      takeoffTime: "",
      landingTime: "",
      enteredSearchArea: "",
      departedSearchArea: ""
    });
    const [calculated, setCalculated] = useState({
      tachElapsed: "",
      hobbsElapsed: "",
      enrouteTime: "",
      searchTime: ""
    });
    const [fuelOil, setFuelOil] = useState({ fuelGallons: "", fuelCost: "", oilQt: "" });
    const [notes, setNotes] = useState("");
    const eventSeqRef = React.useRef(1);
    const [events, setEvents] = useState([createEmptyEvent(1)]);
    const [showMoreEventTypes, setShowMoreEventTypes] = useState({});
    const [pirepModal, setPirepModal] = useState({ open: false, eventId: null });
    const [pirepRadioCall, setPirepRadioCall] = useState({ open: false, eventId: null });
    const [pirepData, setPirepData] = useState({
      aircraft: "",
      altitude: "",
      clouds: "",
      turbulence: "",
      icing: "",
      visibility: "",
      remarks: ""
    });
    const [targetLocations, setTargetLocations] = useState([
      { passes: ["", "", "", ""], estimate: "" },
      { passes: ["", "", "", ""], estimate: "" }
    ]);
    const [activeTab, setActiveTab] = useState("home");
    // Helper function to switch tabs and scroll to top
    const switchTab = (tabId) => {
      setActiveTab(tabId);
      window.scrollTo(0, 0);
    };
    const [commsUnlocked, setCommsUnlocked] = useState(false);
    // Night mode for cockpit operations
    const [nightMode, setNightMode] = useState(false);
    // Text size for accessibility - normal, large, xlarge
    const [textSize, setTextSize] = useState("normal");
    // Enlarge modal for viewing text content in extra large format
    const [enlargeModal, setEnlargeModal] = useState({ open: false, title: "", content: "" });
    
    // Proficiency Profile state
    const [proficiencyState, setProficiencyState] = useState({
      selectedProfile: null,
      completedItems: {}, // { itemId: timestamp }
      notes: '',
      startTime: null
    });
    
    
    // Proficiency Profile Data - loaded from external module (data/proficiency-data.js)
    // See MAT.data.proficiencyProfiles or window.proficiencyProfiles
    
    
    
    // Ops Normal Timer
    const [opsTimerEnabled, setOpsTimerEnabled] = useState(false);
    const [opsTimerMinutes, setOpsTimerMinutes] = useState(30);
    const [opsTimerRemaining, setOpsTimerRemaining] = useState(null);
    const [opsTimerLastReset, setOpsTimerLastReset] = useState(null);
const [activeRefSection, setActiveRefSection] = useState("radioFrequencies");
    const [g1000RefTextSize, setG1000RefTextSize] = useState(1); // 0.85, 1, 1.2, 1.4
    
    // Aviation Calculator states
    const [calcState, setCalcState] = useState({
      // Ground Speed
      gsDistance: '', gsTime: '', gsResult: null,
      // Time Enroute
      eteDistance: '', eteGs: '', eteResult: null,
      // Fuel Burn
      fuelTime: '', fuelGph: '', fuelResult: null,
      // Distance
      distGs: '', distTime: '', distResult: null,
      // Headwind
      hwWindSpeed: '', hwWindDir: '', hwRunway: '', hwResult: null,
      // Crosswind
      xwWindSpeed: '', xwWindDir: '', xwRunway: '', xwResult: null,
      // Density Altitude
      daFieldElev: '', daAltSetting: '', daOAT: '', daResult: null,
      // TAS
      tasIAS: '', tasAlt: '', tasResult: null,
      // Wind Correction
      wcaTAS: '', wcaWindSpeed: '', wcaCourse: '', wcaWindDir: '', wcaResult: null,
      // Descent Rate
      drAltLose: '', drDistance: '', drGs: '', drResult: null,
      // Climb Gradient
      cgFtPerNm: '', cgGs: '', cgResult: null,
      // Top of Descent
      todCurrentAlt: '', todTargetAlt: '', todResult: null,
      // Glideslope
      glsGs: '', glsResult: null,
      // Knots to MPH
      ktsMph: '', ktsMphResult: null,
      // Pressure Altitude
      paFieldElev: '', paAltSetting: '', paResult: null
    });
    const updateCalc = (field, value) => setCalcState(prev => ({ ...prev, [field]: value }));
    
    // Command Tools state
    const [cmdState, setCmdState] = useState({
      searchAreaMode: 'grid', // 'grid', 'point', 'route'
      gridInput: '',
      selectedGrids: [], // [{grid: 'DEN27', subgrids: ['A','B','C','D'], corners: {...}}]
      pointInput: '',
      routePoints: [], // [{lat, lon, name}]
      coverageWidth: 0.5, // NM on each side
      flights: [], // [{id, callsign, coordinates: [{lat, lon, alt, time}], color}]
      coverageGrid: null, // 2D array for coverage calculation
      showSettings: false,
      showMap: false,
      mapKey: 0, // Increment to force map re-render
      analysisGrids: [], // Stores coverage analysis data for map
      showEighthGrids: false, // Show 1/8 grid subdivision lines in PDF
      showGapSelector: false, // Show gap selection modal
      gapOptions: [], // [{gridId, quadrant, coverage, uncoveredCells, corners, isRecommended}]
      selectedGap: null // Currently selected gap for mission generation
    });
    const cmdFlightColors = ['#f6e05e', '#68d391', '#63b3ed', '#fc8181', '#b794f4', '#f687b3'];
    
   // Demo module loaded externally from data/demo-module.js
const demoConfigs = window.DEMO_MODULE ? window.DEMO_MODULE.configs : [];
const [demoLoading, setDemoLoading] = useState(false);
    const [demoLoadStatus, setDemoLoadStatus] = useState('');
    const [crosshairDemoFlight, setCrosshairDemoFlight] = useState('kansas');
    const [demoConfirmation, setDemoConfirmation] = useState(null);
    
    const [searchQuery, setSearchQuery] = useState("");
    const [selectedAircraft, setSelectedAircraft] = useState("C182T");
    const [selectedEmergencyCategory, setSelectedEmergencyCategory] = useState("engine");
    const [expandedProcedure, setExpandedProcedure] = useState(null);
    const [expandedRadioCall, setExpandedRadioCall] = useState(null);

    const [spState, setSpState] = useState({ 
      patternType: 'gridParallelTrack', 
      poiInput: '', 
      poi: null, 
      detectedGrid: null, 
      spacing: 0.5, 
      groundspeed: 90, 
      entryCorner: 'NW', 
      initialHeading: 0, 
      turnDirection: 'Right', 
      numLegs: 8, 
      // Grid Parallel Track parameters (Quarter Grid)
      gpLegLength: null,   // null = use quarter grid height (default ~7.5nm)
      gpNumTracks: null,   // null = auto-calculate from width and spacing
      gpUseDefaults: true, // When true, use quarter grid defaults
      // Legacy creeping line (grid-based)
      clDirection: 0, 
      clStartSide: 'Left', 
      // Enhanced creeping line parameters (ForeFlight compatible)
      clMode: 'custom',  // 'grid' or 'custom'
      clCreepDirection: 25,  // Direction the search creeps along (degrees)
      clLegLength: 8.0,  // Length of each search track (NM)
      clNumLegs: 10,  // Number of search tracks
      clG1000Mode: false,  // G1000 mode adds initial waypoint for full first leg
      // POI-centered parallel
      poiNumTracks: 6, 
      poiTrackLength: 3, 
      poiHeading: 0, 
      lastPlan: null, 
      showMap: false,
      showG1000Guide: false  // G1000 SAR programming guide modal
    });
    const [selectedState, setSelectedState] = useState("CO");
    const [selectedCommsCategory, setSelectedCommsCategory] = useState("channels");
    const [commsView, setCommsView] = useState("channels");
    const [channelSearch, setChannelSearch] = useState("");
    const [callsignSearch, setCallsignSearch] = useState("");
    // Radio call sign settings
    const [radioCallSigns, setRadioCallSigns] = useState({
      aircraft: '',      // e.g., "CAP 594"
      missionBase: ''    // e.g., "Blue Mesa 92"
    });
    const [crosshairPoints, setCrosshairPoints] = useState([]); // Unified point list - auto-detects paths
    const [crosshairResult, setCrosshairResult] = useState(null);
    const [crosshairAnalysis, setCrosshairAnalysis] = useState(null); // Stores path detection results
    const [crosshairShowMap, setCrosshairShowMap] = useState(false); // Inline map display
    const [crosshairMapHtml, setCrosshairMapHtml] = useState(''); // Generated map HTML
    const targetSeqRef = React.useRef(0); // per refresh
    // ELT Assist state
    const [eltObservations, setEltObservations] = useState([]);
    const [eltResult, setEltResult] = useState(null);
    const [eltShowMap, setEltShowMap] = useState(false);
    const [eltMapHtml, setEltMapHtml] = useState(''); // Generated map HTML for inline display
    const [eltShowMapModal, setEltShowMapModal] = useState(false); // Show inline map modal
    const [eltDiagramZoom, setEltDiagramZoom] = useState(1.0); // Zoom level for diagram (1.0 = fit all, higher = zoom in)
    const [showG1000Instructions, setShowG1000Instructions] = useState(false); // G1000 SAR programming guide
    const eltMapRef = React.useRef(null);
    
    // Search Probability Model state
    const [adsbTrack, setAdsbTrack] = useState(null); // ADS-B flight track data
    const [sarsatPings, setSarsatPings] = useState([]); // SARSAT ping locations with error radii
    const [searchProbModel, setSearchProbModel] = useState(null); // Computed probability zones
    const [probModelSettings, setProbModelSettings] = useState({
      maxGlideRatio: 12,        // Best glide ratio (typical light aircraft 8-12)
      maxFlightTime: 15,        // Max minutes after last contact
      avgGroundspeed: 100,      // Average groundspeed in knots
      altitudeAGL: 1000,        // Assumed AGL for glide calculations
      terrainBuffer: 500,       // Terrain clearance buffer in feet
      pingWeightRecent: 1.0,    // Weight for recent pings
      pingWeightOld: 0.5,       // Weight for older pings
      showHighProb: true,
      showMedProb: true,
      showLowProb: true
    });
    const [showProbModel, setShowProbModel] = useState(false);
    
    const [eltSettings, setEltSettings] = useState({
      r10: 0.5,           // NM at strength 10
      k: 2,               // range growth factor
      sigmaTheta: 20,     // bearing uncertainty degrees
      resolution: 0.25,   // grid resolution NM
      confidenceMode: 'auto', // 'auto', 'conservative', 'moderate', 'aggressive'
      manualUncertainty: 50   // manual override percentage (when mode != auto)
    });
    const [eltSolutions, setEltSolutions] = useState([]); // History of computed solutions
    const eltSolutionSeqRef = React.useRef(0);
    const [newEltObs, setNewEltObs] = useState({
      timeZ: '',
      source: 'audio',
      latDeg: '',
      latMin: '',
      lonDeg: '',
      lonMin: '',
      altMSL: '',
      altAGL: '',
      strength: 5,
      directRange: '',  // Direct range entry in NM (overrides strength)
      rangeAccuracy: '', // Range uncertainty in NM
      dfBearing: '',
      bearingRef: 'MAG',
      bearingAccuracy: '20',
      notes: '',
      useInCalc: true
    });
    const eltObsSeqRef = React.useRef(0);
    function createEmptyEvent(eventNum) {
      return {
        id: Date.now() + Math.random(),
        eventNum: eventNum ?? "",
        eventType: "",
        dateZ: "",
        timeZ: "",
        latDeg: "",
        latMin: "",
        longDeg: "",
        longMin: "",
        altMSL: "",
        altAGL: "",
        heading: "",
        airspeed: "",
        groundSpeed: "",
        capGrid: "",
        notes: ""
      };
    }
    const PirepModal = ({ isOpen, onClose, onSave, onRadioCall, data, setData }) => {
      if (!isOpen) return null;
      const buildPirepString = () => {
        let parts = [];
        if (data.aircraft) parts.push(`A/C: ${data.aircraft}`);
        if (data.altitude) parts.push(`ALT: ${data.altitude}`);
        if (data.clouds) parts.push(`SKY: ${data.clouds}`);
        if (data.turbulence) parts.push(`TB: ${data.turbulence}`);
        if (data.icing) parts.push(`IC: ${data.icing}`);
        if (data.visibility) parts.push(`VIS: ${data.visibility}`);
        if (data.remarks) parts.push(`RMK: ${data.remarks}`);
        return parts.length > 0 ? "PIREP - " + parts.join(", ") : "PIREP";
      };
      const SelectButton = ({ selected, onClick, children, color = "#3182ce" }) => /* @__PURE__ */ React.createElement(
        "button",
        {
          onClick,
          style: {
            minHeight: "52px",
            padding: "10px 12px",
            fontSize: "13px",
            fontWeight: "700",
            background: selected ? `linear-gradient(135deg, ${color}, ${color}dd)` : "rgba(0,0,0,0.3)",
            border: selected ? `3px solid ${color}` : "2px solid rgba(255,255,255,0.15)",
            borderRadius: "10px",
            color: selected ? "#fff" : "#a0aec0",
            fontFamily: "inherit",
            cursor: "pointer",
            touchAction: "manipulation",
            boxShadow: selected ? `0 4px 12px ${color}44` : "none"
          }
        },
        children
      );
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          style: {
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: "rgba(0,0,0,0.9)",
            zIndex: 1e3,
            overflowY: "auto",
            WebkitOverflowScrolling: "touch"
          },
          onClick: (e) => {
            if (e.target === e.currentTarget) onClose();
          }
        },
        /* @__PURE__ */ React.createElement("div", { style: {
          background: "linear-gradient(135deg, #1a365d 0%, #0c1929 100%)",
          borderRadius: "16px",
          border: "2px solid rgba(99,179,237,0.3)",
          margin: "20px auto",
          width: "calc(100% - 40px)",
          maxWidth: "500px"
        } }, /* @__PURE__ */ React.createElement("div", { style: {
          background: "linear-gradient(90deg, rgba(49,130,206,0.4) 0%, transparent 100%)",
          padding: "16px 20px",
          borderBottom: "1px solid rgba(255,255,255,0.1)",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        } }, /* @__PURE__ */ React.createElement("span", { style: { fontSize: "18px", fontWeight: "700", color: "#63b3ed" } }, "\u2601\uFE0F Quick PIREP"), /* @__PURE__ */ React.createElement(
          "button",
          {
            onClick: onClose,
            style: {
              background: "rgba(255,255,255,0.1)",
              border: "none",
              borderRadius: "8px",
              padding: "12px 20px",
              color: "#fff",
              fontSize: "14px",
              fontWeight: "700",
              cursor: "pointer",
              minHeight: "48px"
            }
          },
          "\u2715 CANCEL"
        )), /* @__PURE__ */ React.createElement("div", { style: { padding: "20px" } }, /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "20px" } }, /* @__PURE__ */ React.createElement("label", { style: { fontSize: "12px", fontWeight: "700", color: "#f6e05e", textTransform: "uppercase", display: "block", marginBottom: "10px" } }, "\u2708\uFE0F Aircraft"), /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px" } }, ["C172", "C182", "C206", "C210", "GA8", "OTHER"].map((ac) => /* @__PURE__ */ React.createElement(
          SelectButton,
          {
            key: ac,
            selected: data.aircraft === ac,
            onClick: () => setData({ ...data, aircraft: ac }),
            color: "#3182ce"
          },
          ac
        )))), /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "20px" } }, /* @__PURE__ */ React.createElement("label", { style: { fontSize: "12px", fontWeight: "700", color: "#f6e05e", textTransform: "uppercase", display: "block", marginBottom: "10px" } }, "\u{1F4CF} Altitude (ft MSL)"), /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: "8px", marginBottom: "8px" } }, ["5500", "7500", "9500", "11500"].map((alt) => /* @__PURE__ */ React.createElement(
          SelectButton,
          {
            key: alt,
            selected: data.altitude === alt,
            onClick: () => setData({ ...data, altitude: alt }),
            color: "#805ad5"
          },
          (parseInt(alt) / 1e3).toFixed(1),
          "K"
        ))), /* @__PURE__ */ React.createElement(
          "input",
          {
            type: "text",
            inputMode: "numeric",
            placeholder: "Or enter altitude...",
            value: data.altitude,
            onChange: (e) => setData({ ...data, altitude: e.target.value }),
            style: {
              width: "100%",
              background: "rgba(0,0,0,0.4)",
              border: "2px solid rgba(255,255,255,0.2)",
              borderRadius: "8px",
              padding: "14px",
              fontSize: "16px",
              color: "#fff",
              fontFamily: "inherit"
            }
          }
        )), /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "20px" } }, /* @__PURE__ */ React.createElement("label", { style: { fontSize: "12px", fontWeight: "700", color: "#f6e05e", textTransform: "uppercase", display: "block", marginBottom: "10px" } }, "\u2601\uFE0F Sky Condition"), /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px" } }, [
          { v: "CLR", l: "CLEAR" },
          { v: "FEW", l: "FEW" },
          { v: "SCT", l: "SCTRD" },
          { v: "BKN", l: "BROKN" },
          { v: "OVC", l: "OVCST" },
          { v: "IMC", l: "IMC" }
        ].map((sky) => /* @__PURE__ */ React.createElement(
          SelectButton,
          {
            key: sky.v,
            selected: data.clouds === sky.v,
            onClick: () => setData({ ...data, clouds: sky.v }),
            color: "#718096"
          },
          sky.l
        )))), /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "20px" } }, /* @__PURE__ */ React.createElement("label", { style: { fontSize: "12px", fontWeight: "700", color: "#f6e05e", textTransform: "uppercase", display: "block", marginBottom: "10px" } }, "\u3030\uFE0F Turbulence"), /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px" } }, [
          { v: "NEG", l: "NONE", c: "#38a169" },
          { v: "SMTH", l: "SMOOTH", c: "#38a169" },
          { v: "LGT", l: "LIGHT", c: "#d69e2e" },
          { v: "LGT-MOD", l: "LGT-MOD", c: "#dd6b20" },
          { v: "MOD", l: "MOD", c: "#e53e3e" },
          { v: "MOD-SVR", l: "MOD-SVR", c: "#c53030" },
          { v: "SVR", l: "SEVERE", c: "#9b2c2c" },
          { v: "EXTRM", l: "EXTRM", c: "#742a2a" }
        ].map((tb) => /* @__PURE__ */ React.createElement(
          SelectButton,
          {
            key: tb.v,
            selected: data.turbulence === tb.v,
            onClick: () => setData({ ...data, turbulence: tb.v }),
            color: tb.c
          },
          tb.l
        )))), /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "20px" } }, /* @__PURE__ */ React.createElement("label", { style: { fontSize: "12px", fontWeight: "700", color: "#f6e05e", textTransform: "uppercase", display: "block", marginBottom: "10px" } }, "\u2744\uFE0F Icing"), /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px" } }, [
          { v: "NEG", l: "NONE", c: "#38a169" },
          { v: "TRC", l: "TRACE", c: "#3182ce" },
          { v: "LGT", l: "LIGHT", c: "#d69e2e" },
          { v: "LGT-MOD", l: "LGT-MOD", c: "#dd6b20" },
          { v: "MOD", l: "MOD", c: "#e53e3e" },
          { v: "SVR", l: "SEVERE", c: "#9b2c2c" }
        ].map((ic) => /* @__PURE__ */ React.createElement(
          SelectButton,
          {
            key: ic.v,
            selected: data.icing === ic.v,
            onClick: () => setData({ ...data, icing: ic.v }),
            color: ic.c
          },
          ic.l
        )))), /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "20px" } }, /* @__PURE__ */ React.createElement("label", { style: { fontSize: "12px", fontWeight: "700", color: "#f6e05e", textTransform: "uppercase", display: "block", marginBottom: "10px" } }, "\u{1F441} Visibility"), /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: "8px" } }, [
          { v: "10+", l: "10+ SM", c: "#38a169" },
          { v: "5-10", l: "5-10", c: "#3182ce" },
          { v: "3-5", l: "3-5", c: "#d69e2e" },
          { v: "1-3", l: "1-3", c: "#dd6b20" },
          { v: "<1", l: "<1 SM", c: "#e53e3e" }
        ].map((vis) => /* @__PURE__ */ React.createElement(
          SelectButton,
          {
            key: vis.v,
            selected: data.visibility === vis.v,
            onClick: () => setData({ ...data, visibility: vis.v }),
            color: vis.c
          },
          vis.l
        )))), /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "20px" } }, /* @__PURE__ */ React.createElement("label", { style: { fontSize: "12px", fontWeight: "700", color: "#f6e05e", textTransform: "uppercase", display: "block", marginBottom: "10px" } }, "\u{1F4DD} Remarks (optional)"), /* @__PURE__ */ React.createElement(
          "input",
          {
            type: "text",
            placeholder: "Additional notes...",
            value: data.remarks,
            onChange: (e) => setData({ ...data, remarks: e.target.value.toUpperCase() }),
            style: {
              width: "100%",
              background: "rgba(0,0,0,0.4)",
              border: "2px solid rgba(255,255,255,0.2)",
              borderRadius: "8px",
              padding: "14px",
              fontSize: "16px",
              color: "#fff",
              fontFamily: "inherit"
            }
          }
        )), /* @__PURE__ */ React.createElement("div", { style: {
          background: "rgba(0,0,0,0.4)",
          borderRadius: "10px",
          padding: "16px",
          marginBottom: "20px",
          border: "1px solid rgba(104,211,145,0.3)"
        } }, /* @__PURE__ */ React.createElement("label", { style: { fontSize: "11px", fontWeight: "700", color: "#68d391", textTransform: "uppercase", display: "block", marginBottom: "8px" } }, "Preview"), /* @__PURE__ */ React.createElement("div", { style: {
          fontSize: "14px",
          color: "#68d391",
          lineHeight: "1.5",
          fontWeight: "600"
        } }, buildPirepString())), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "12px" } },
          /* @__PURE__ */ React.createElement(
          "button",
          {
            onClick: () => {
              onSave(buildPirepString());
              onClose();
            },
            style: {
              flex: 1,
              minHeight: "64px",
              padding: "18px",
              fontSize: "18px",
              fontWeight: "700",
              background: "linear-gradient(135deg, #38a169, #2f855a)",
              border: "3px solid #48bb78",
              borderRadius: "12px",
              color: "#fff",
              cursor: "pointer",
              touchAction: "manipulation",
              boxShadow: "0 4px 12px rgba(56,161,105,0.4)"
            }
          },
          "\u2713 SAVE"
        ), /* @__PURE__ */ React.createElement(
          "button",
          {
            onClick: () => {
              onSave(buildPirepString());
              onRadioCall();
            },
            style: {
              flex: 1,
              minHeight: "64px",
              padding: "18px",
              fontSize: "18px",
              fontWeight: "700",
              background: "linear-gradient(135deg, #3182ce, #2b6cb0)",
              border: "3px solid #4299e1",
              borderRadius: "12px",
              color: "#fff",
              cursor: "pointer",
              touchAction: "manipulation",
              boxShadow: "0 4px 12px rgba(49,130,206,0.4)"
            }
          },
          "\u{1F4FB} RADIO CALL"
        ))))
      );
    };
    const PirepRadioCallOverlay = ({ isOpen, onClose, pirepData, event, missionInfo }) => {
      if (!isOpen) return null;
      
      // Determine report type based on severity
      const isUrgent = pirepData.turbulence === "SVR" || pirepData.turbulence === "EXTRM" || 
                       pirepData.turbulence === "MOD-SVR" || pirepData.icing === "SVR" ||
                       pirepData.icing === "MOD";
      const reportType = isUrgent ? "URGENT PIREP" : "Routine PIREP";
      
      // Format location from event data
      const formatLocation = () => {
        if (event?.capGrid) return event.capGrid;
        if (event?.latDeg && event?.latMin && event?.longDeg && event?.longMin) {
          return `N${event.latDeg} ${event.latMin}' W${event.longDeg} ${event.longMin}'`;
        }
        return "";
      };
      
      // Format time
      const formatTime = () => {
        if (event?.timeZ) return event.timeZ + " Zulu";
        const now = new Date();
        return now.getUTCHours().toString().padStart(2, '0') + 
               now.getUTCMinutes().toString().padStart(2, '0') + " Zulu";
      };
      
      // Format altitude
      const formatAltitude = () => {
        if (pirepData.altitude) {
          const alt = parseInt(pirepData.altitude);
          if (alt >= 18000) return "Flight Level " + Math.round(alt / 100);
          return alt.toLocaleString() + " feet MSL";
        }
        if (event?.altMSL) return parseInt(event.altMSL).toLocaleString() + " feet MSL";
        return "";
      };
      
      // Format aircraft type
      const formatAircraft = () => {
        const ac = pirepData.aircraft || missionInfo?.aircraftTailN || "";
        const acNames = {
          "C172": "Cessna 172",
          "C182": "Cessna 182",
          "C206": "Cessna 206",
          "C210": "Cessna 210",
          "GA8": "GippsAero GA8 Airvan"
        };
        return acNames[ac] || ac;
      };
      
      // Format sky condition
      const formatSky = () => {
        const skyNames = {
          "CLR": "Clear",
          "FEW": "Few clouds",
          "SCT": "Scattered clouds",
          "BKN": "Broken clouds",
          "OVC": "Overcast",
          "IMC": "IMC conditions"
        };
        return skyNames[pirepData.clouds] || pirepData.clouds || "";
      };
      
      // Format visibility
      const formatVisibility = () => {
        if (!pirepData.visibility) return "";
        const visNames = {
          "10+": "Greater than 10 miles",
          "5-10": "5 to 10 miles",
          "3-5": "3 to 5 miles",
          "1-3": "1 to 3 miles",
          "<1": "Less than 1 mile"
        };
        return visNames[pirepData.visibility] || pirepData.visibility;
      };
      
      // Format turbulence
      const formatTurbulence = () => {
        const tbNames = {
          "NEG": "Negative",
          "SMTH": "Smooth",
          "LGT": "Light turbulence",
          "LGT-MOD": "Light to moderate turbulence",
          "MOD": "Moderate turbulence",
          "MOD-SVR": "Moderate to severe turbulence",
          "SVR": "Severe turbulence",
          "EXTRM": "Extreme turbulence"
        };
        return tbNames[pirepData.turbulence] || pirepData.turbulence || "";
      };
      
      // Format icing
      const formatIcing = () => {
        const icNames = {
          "NEG": "Negative",
          "TRC": "Trace icing",
          "LGT": "Light icing",
          "LGT-MOD": "Light to moderate icing",
          "MOD": "Moderate icing",
          "SVR": "Severe icing"
        };
        return icNames[pirepData.icing] || pirepData.icing || "";
      };
      
      // Build the report lines
      const reportLines = [
        { label: "Report Type", value: reportType, highlight: isUrgent },
        { label: "Location", value: formatLocation() },
        { label: "Time", value: formatTime() },
        { label: "Altitude", value: formatAltitude() },
        { label: "Aircraft", value: formatAircraft() },
        { label: "Sky Condition", value: formatSky() },
        { label: "Visibility", value: formatVisibility() },
        { label: "Temperature", value: "" },
        { label: "Winds", value: "" },
        { label: "Turbulence", value: formatTurbulence() },
        { label: "Icing", value: formatIcing() },
        { label: "Remarks", value: pirepData.remarks || "" }
      ];
      
      const lineStyle = {
        display: "flex",
        padding: "14px 16px",
        borderBottom: "1px solid rgba(255,255,255,0.1)",
        alignItems: "center"
      };
      
      const labelStyle = {
        width: "110px",
        fontSize: "13px",
        fontWeight: "600",
        color: "#a0aec0"
      };
      
      const valueStyle = {
        flex: 1,
        fontSize: "17px",
        fontWeight: "600",
        color: "#fff"
      };
      
      return React.createElement("div", {
        style: {
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: "rgba(0,0,0,0.95)",
          zIndex: 1001,
          overflowY: "auto",
          WebkitOverflowScrolling: "touch"
        },
        onClick: (e) => { if (e.target === e.currentTarget) onClose(); }
      },
        React.createElement("div", {
          style: {
            background: "linear-gradient(135deg, #1a365d 0%, #0c1929 100%)",
            borderRadius: "16px",
            border: "2px solid rgba(99,179,237,0.3)",
            margin: "20px auto",
            width: "calc(100% - 40px)",
            maxWidth: "500px"
          }
        },
          // Header
          React.createElement("div", {
            style: {
              background: isUrgent 
                ? "linear-gradient(90deg, rgba(229,62,62,0.4) 0%, transparent 100%)"
                : "linear-gradient(90deg, rgba(49,130,206,0.4) 0%, transparent 100%)",
              padding: "16px 20px",
              borderBottom: "1px solid rgba(255,255,255,0.1)",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center"
            }
          },
            React.createElement("div", null,
              React.createElement("span", { 
                style: { 
                  fontSize: "18px", 
                  fontWeight: "700", 
                  color: isUrgent ? "#fc8181" : "#63b3ed" 
                } 
              }, " PIREP Radio Call"),
              React.createElement("div", {
                style: { fontSize: "11px", color: "#a0aec0", marginTop: "4px" }
              }, "Read to Flight Service")
            ),
            React.createElement("button", {
              onClick: onClose,
              style: {
                background: "rgba(255,255,255,0.1)",
                border: "none",
                borderRadius: "8px",
                padding: "12px 20px",
                color: "#fff",
                fontSize: "14px",
                fontWeight: "700",
                cursor: "pointer",
                minHeight: "48px"
              }
            }, " CLOSE")
          ),
          
          // Urgent Warning
          isUrgent && React.createElement("div", {
            style: {
              background: "rgba(229,62,62,0.2)",
              padding: "12px 20px",
              borderBottom: "1px solid rgba(229,62,62,0.3)",
              textAlign: "center"
            }
          },
            React.createElement("span", {
              style: { color: "#fc8181", fontWeight: "700", fontSize: "14px" }
            }, " URGENT PIREP - Report Immediately")
          ),
          
          // Instructions
          React.createElement("div", {
            style: {
              background: "rgba(246,224,94,0.1)",
              padding: "12px 20px",
              borderBottom: "1px solid rgba(246,224,94,0.2)"
            }
          },
            React.createElement("div", {
              style: { fontSize: "12px", color: "#f6e05e", lineHeight: "1.5" }
            }, 
              React.createElement("strong", null, "Call: "), 
              "Flight Service (122.2) or EFAS Flight Watch (122.0)",
              React.createElement("br", null),
              React.createElement("strong", null, "Say: "), 
              "\"[Callsign], PIREP\" then read each item below"
            )
          ),
          
          // Report Lines
          React.createElement("div", { style: { padding: "8px 0" } },
            reportLines.map((line, idx) => 
              React.createElement("div", {
                key: idx,
                style: {
                  ...lineStyle,
                  background: line.highlight ? "rgba(229,62,62,0.15)" : 
                              (line.value ? "transparent" : "rgba(0,0,0,0.2)")
                }
              },
                React.createElement("span", { style: labelStyle }, line.label),
                React.createElement("span", { 
                  style: { 
                    ...valueStyle, 
                    color: line.highlight ? "#fc8181" : (line.value ? "#fff" : "#4a5568")
                  } 
                }, line.value || "")
              )
            )
          ),
          
          // Footer
          React.createElement("div", {
            style: {
              padding: "16px 20px",
              borderTop: "1px solid rgba(255,255,255,0.1)",
              background: "rgba(0,0,0,0.2)"
            }
          },
            React.createElement("div", {
              style: { fontSize: "11px", color: "#718096", lineHeight: "1.6", textAlign: "center" }
            },
              "Skip items marked with \"\"  Emphasize non-standard conditions",
              React.createElement("br", null),
              "FSS will read back for confirmation"
            )
          )
        )
      );
    };
    const GpsToolsModal = ({ isOpen, onClose, onApply, initialLat, initialLon, eventId }) => {
      const [format, setFormat] = useState("ddm");
      const [ddLat, setDdLat] = useState("");
      const [ddLon, setDdLon] = useState("");
      const [dmsLatDeg, setDmsLatDeg] = useState("");
      const [dmsLatMin, setDmsLatMin] = useState("");
      const [dmsLatSec, setDmsLatSec] = useState("");
      const [dmsLonDeg, setDmsLonDeg] = useState("");
      const [dmsLonMin, setDmsLonMin] = useState("");
      const [dmsLonSec, setDmsLonSec] = useState("");
      const [ddmLatDeg, setDdmLatDeg] = useState("");
      const [ddmLatMin, setDdmLatMin] = useState("");
      const [ddmLonDeg, setDdmLonDeg] = useState("");
      const [ddmLonMin, setDdmLonMin] = useState("");
      const [capGrid, setCapGrid] = useState(null);
      const [gpsStatus, setGpsStatus] = useState("");
      const [offlineMode, setOfflineMode] = useState(false);
      useEffect(() => {
        if (initialLat && initialLon) {
          setDdmLatDeg(initialLat);
          setDdmLatMin(initialLon);
          const ddVal = gpsUtils.ddmToDd(initialLat, initialLon.split(".")[0] || "0");
          syncFromDdm(initialLat, initialLon, initialLat ? "" : "", initialLon ? "" : "");
        }
      }, [initialLat, initialLon, isOpen]);
      const syncFromDd = (lat, lon) => {
        if (!lat || !lon) return;
        const latNum = parseFloat(lat);
        const lonNum = parseFloat(lon);
        if (isNaN(latNum) || isNaN(lonNum)) return;
        const latDms = gpsUtils.ddToDms(latNum);
        const lonDms = gpsUtils.ddToDms(lonNum);
        setDmsLatDeg(latDms.deg.toString());
        setDmsLatMin(latDms.min.toString());
        setDmsLatSec(latDms.sec.toString());
        setDmsLonDeg(lonDms.deg.toString());
        setDmsLonMin(lonDms.min.toString());
        setDmsLonSec(lonDms.sec.toString());
        const latDdm = gpsUtils.ddToDdm(latNum);
        const lonDdm = gpsUtils.ddToDdm(lonNum);
        setDdmLatDeg(latDdm.deg.toString());
        setDdmLatMin(latDdm.min.toFixed(3));
        setDdmLonDeg(lonDdm.deg.toString());
        setDdmLonMin(lonDdm.min.toFixed(3));
        setCapGrid(gpsUtils.calculateCapGrid(latNum, -Math.abs(lonNum)));
      };
      const syncFromDms = () => {
        if (!dmsLatDeg || !dmsLonDeg) return;
        const latDd = gpsUtils.dmsToDd(dmsLatDeg, dmsLatMin || 0, dmsLatSec || 0);
        const lonDd = gpsUtils.dmsToDd(dmsLonDeg, dmsLonMin || 0, dmsLonSec || 0);
        setDdLat(latDd.toFixed(6));
        setDdLon(lonDd.toFixed(6));
        const latDdm = gpsUtils.ddToDdm(latDd);
        const lonDdm = gpsUtils.ddToDdm(lonDd);
        setDdmLatDeg(latDdm.deg.toString());
        setDdmLatMin(latDdm.min.toFixed(3));
        setDdmLonDeg(lonDdm.deg.toString());
        setDdmLonMin(lonDdm.min.toFixed(3));
        setCapGrid(gpsUtils.calculateCapGrid(latDd, -lonDd));
      };
      const syncFromDdm = () => {
        if (!ddmLatDeg || !ddmLonDeg) return;
        const latDd = gpsUtils.ddmToDd(ddmLatDeg, ddmLatMin || 0);
        const lonDd = gpsUtils.ddmToDd(ddmLonDeg, ddmLonMin || 0);
        setDdLat(latDd.toFixed(6));
        setDdLon(lonDd.toFixed(6));
        const latDms = gpsUtils.ddToDms(latDd);
        const lonDms = gpsUtils.ddToDms(lonDd);
        setDmsLatDeg(latDms.deg.toString());
        setDmsLatMin(latDms.min.toString());
        setDmsLatSec(latDms.sec.toFixed(2));
        setDmsLonDeg(lonDms.deg.toString());
        setDmsLonMin(lonDms.min.toString());
        setDmsLonSec(lonDms.sec.toFixed(2));
        setCapGrid(gpsUtils.calculateCapGrid(latDd, -lonDd));
      };
      const getCurrentLocation = () => {
        if (!navigator.geolocation) {
          setGpsStatus("GPS not supported in this browser");
          return;
        }
        setGpsStatus("Getting location...");
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const lat = position.coords.latitude;
            const lon = Math.abs(position.coords.longitude);
            setDdLat(lat.toFixed(6));
            setDdLon(lon.toFixed(6));
            syncFromDd(lat.toFixed(6), lon.toFixed(6));
            setGpsStatus(`Location acquired (\xB1${Math.round(position.coords.accuracy)}m)`);
          },
          (error) => {
            setGpsStatus(`GPS Error: ${error.message}`);
          },
          { enableHighAccuracy: true, timeout: 1e4 }
        );
      };
      const openMapView = () => {
        if (offlineMode) {
          setGpsStatus("Map unavailable in offline mode");
          return;
        }
        const lat = ddLat || (ddmLatDeg ? gpsUtils.ddmToDd(ddmLatDeg, ddmLatMin || 0) : null);
        const lon = ddLon || (ddmLonDeg ? gpsUtils.ddmToDd(ddmLonDeg, ddmLonMin || 0) : null);
        if (lat && lon) {
          window.open(`https://www.openstreetmap.org/?mlat=${lat}&mlon=-${lon}&zoom=14`, "_blank");
        }
      };
      const handleApply = () => {
        onApply(eventId, ddmLatDeg, ddmLatMin, ddmLonDeg, ddmLonMin, capGrid);
        onClose();
      };
      if (!isOpen) return null;
      const modalStyles = {
        overlay: { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.8)", zIndex: 1e3, display: "flex", alignItems: "center", justifyContent: "center", padding: "16px" },
        modal: { background: "linear-gradient(180deg, #1a365d, #0c1929)", borderRadius: "12px", maxWidth: "500px", width: "100%", maxHeight: "90vh", overflow: "auto", border: "1px solid rgba(99,179,237,0.3)" },
        header: { padding: "16px", borderBottom: "1px solid rgba(255,255,255,0.1)", display: "flex", justifyContent: "space-between", alignItems: "center" },
        title: { fontSize: "18px", fontWeight: "700", color: "#63b3ed", display: "flex", alignItems: "center", gap: "8px" },
        closeBtn: { background: "none", border: "none", color: "#a0aec0", fontSize: "24px", cursor: "pointer", padding: "4px" },
        body: { padding: "16px" },
        section: { marginBottom: "16px", padding: "12px", background: "rgba(0,0,0,0.2)", borderRadius: "8px", border: "1px solid rgba(255,255,255,0.1)" },
        sectionTitle: { fontSize: "12px", fontWeight: "600", color: "#f6e05e", marginBottom: "8px", textTransform: "uppercase", letterSpacing: "0.5px" },
        row: { display: "flex", gap: "8px", marginBottom: "8px", alignItems: "center" },
        input: { flex: 1, padding: "8px 10px", background: "rgba(0,0,0,0.3)", border: "1px solid rgba(255,255,255,0.2)", borderRadius: "4px", color: "#fff", fontSize: "14px", fontFamily: "monospace" },
        inputSmall: { width: "70px", padding: "8px 10px", background: "rgba(0,0,0,0.3)", border: "1px solid rgba(255,255,255,0.2)", borderRadius: "4px", color: "#fff", fontSize: "14px", fontFamily: "monospace", textAlign: "center" },
        label: { fontSize: "11px", color: "#a0aec0", marginBottom: "4px", display: "block" },
        unitLabel: { fontSize: "12px", color: "#a0aec0", minWidth: "20px" },
        button: { padding: "10px 16px", background: "linear-gradient(135deg, #3182ce, #2b6cb0)", border: "none", borderRadius: "6px", color: "#fff", fontWeight: "600", cursor: "pointer", fontSize: "14px" },
        buttonSecondary: { background: "rgba(255,255,255,0.1)", border: "1px solid rgba(255,255,255,0.2)" },
        buttonSuccess: { background: "linear-gradient(135deg, #38a169, #2f855a)" },
        gridResult: { padding: "12px", background: "linear-gradient(135deg, rgba(246,224,94,0.1), rgba(237,137,54,0.1))", borderRadius: "8px", border: "1px solid rgba(246,224,94,0.3)", textAlign: "center" },
        gridMain: { fontSize: "24px", fontWeight: "700", color: "#f6e05e", fontFamily: "monospace", letterSpacing: "2px" },
        gridSub: { fontSize: "12px", color: "#a0aec0", marginTop: "4px" },
        tabs: { display: "flex", gap: "4px", marginBottom: "12px" },
        tab: { flex: 1, padding: "8px", background: "rgba(0,0,0,0.2)", border: "1px solid rgba(255,255,255,0.1)", borderRadius: "4px", color: "#a0aec0", fontSize: "12px", cursor: "pointer", textAlign: "center" },
        tabActive: { background: "rgba(99,179,237,0.2)", borderColor: "rgba(99,179,237,0.4)", color: "#63b3ed" },
        status: { fontSize: "11px", color: "#68d391", textAlign: "center", padding: "8px" }
      };
      return /* @__PURE__ */ React.createElement("div", { style: modalStyles.overlay, onClick: onClose }, /* @__PURE__ */ React.createElement("div", { style: modalStyles.modal, onClick: (e) => e.stopPropagation() }, /* @__PURE__ */ React.createElement("div", { style: modalStyles.header }, /* @__PURE__ */ React.createElement("div", { style: modalStyles.title }, "\u{1F6F0}\uFE0F GPS Coordinate Tools"), /* @__PURE__ */ React.createElement("button", { style: modalStyles.closeBtn, onClick: onClose }, "\xD7")), /* @__PURE__ */ React.createElement("div", { style: modalStyles.body }, /* @__PURE__ */ React.createElement("div", { style: { ...modalStyles.row, marginBottom: "16px" } }, /* @__PURE__ */ React.createElement("button", { style: { ...modalStyles.button, flex: 1 }, onClick: getCurrentLocation }, "\u{1F4CD} Get Current Location"), /* @__PURE__ */ React.createElement("button", { style: { ...modalStyles.button, ...modalStyles.buttonSecondary, flex: 1 }, onClick: openMapView, disabled: offlineMode }, "\u{1F5FA}\uFE0F View on Map")), gpsStatus && /* @__PURE__ */ React.createElement("div", { style: modalStyles.status }, gpsStatus), /* @__PURE__ */ React.createElement("div", { style: modalStyles.tabs }, /* @__PURE__ */ React.createElement("button", { style: { ...modalStyles.tab, ...format === "ddm" ? modalStyles.tabActive : {} }, onClick: () => setFormat("ddm") }, "DDM (G1000)"), /* @__PURE__ */ React.createElement("button", { style: { ...modalStyles.tab, ...format === "dd" ? modalStyles.tabActive : {} }, onClick: () => setFormat("dd") }, "DD"), /* @__PURE__ */ React.createElement("button", { style: { ...modalStyles.tab, ...format === "dms" ? modalStyles.tabActive : {} }, onClick: () => setFormat("dms") }, "DMS")), format === "ddm" && /* @__PURE__ */ React.createElement("div", { style: modalStyles.section }, /* @__PURE__ */ React.createElement("div", { style: modalStyles.sectionTitle }, "Degrees Decimal Minutes (DDM) - G1000 Format"), /* @__PURE__ */ React.createElement("div", { style: modalStyles.row }, /* @__PURE__ */ React.createElement("div", { style: { flex: 1 } }, /* @__PURE__ */ React.createElement("label", { style: modalStyles.label }, "Latitude N"), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "4px", alignItems: "center" } }, /* @__PURE__ */ React.createElement("input", { style: modalStyles.inputSmall, placeholder: "DD", value: ddmLatDeg, onChange: (e) => setDdmLatDeg(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, "\xB0"), /* @__PURE__ */ React.createElement("input", { style: { ...modalStyles.input, flex: 1 }, placeholder: "MM.MMM", value: ddmLatMin, onChange: (e) => setDdmLatMin(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, "'")))), /* @__PURE__ */ React.createElement("div", { style: modalStyles.row }, /* @__PURE__ */ React.createElement("div", { style: { flex: 1 } }, /* @__PURE__ */ React.createElement("label", { style: modalStyles.label }, "Longitude W"), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "4px", alignItems: "center" } }, /* @__PURE__ */ React.createElement("input", { style: modalStyles.inputSmall, placeholder: "DDD", value: ddmLonDeg, onChange: (e) => setDdmLonDeg(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, "\xB0"), /* @__PURE__ */ React.createElement("input", { style: { ...modalStyles.input, flex: 1 }, placeholder: "MM.MMM", value: ddmLonMin, onChange: (e) => setDdmLonMin(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, "'")))), /* @__PURE__ */ React.createElement("button", { style: { ...modalStyles.button, ...modalStyles.buttonSecondary, width: "100%", marginTop: "8px" }, onClick: syncFromDdm }, "Convert & Calculate Grid")), format === "dd" && /* @__PURE__ */ React.createElement("div", { style: modalStyles.section }, /* @__PURE__ */ React.createElement("div", { style: modalStyles.sectionTitle }, "Decimal Degrees (DD)"), /* @__PURE__ */ React.createElement("div", { style: modalStyles.row }, /* @__PURE__ */ React.createElement("div", { style: { flex: 1 } }, /* @__PURE__ */ React.createElement("label", { style: modalStyles.label }, "Latitude (N positive)"), /* @__PURE__ */ React.createElement("input", { style: modalStyles.input, placeholder: "39.123456", value: ddLat, onChange: (e) => setDdLat(e.target.value) })), /* @__PURE__ */ React.createElement("div", { style: { flex: 1 } }, /* @__PURE__ */ React.createElement("label", { style: modalStyles.label }, "Longitude (W as positive)"), /* @__PURE__ */ React.createElement("input", { style: modalStyles.input, placeholder: "104.123456", value: ddLon, onChange: (e) => setDdLon(e.target.value) }))), /* @__PURE__ */ React.createElement("button", { style: { ...modalStyles.button, ...modalStyles.buttonSecondary, width: "100%", marginTop: "8px" }, onClick: () => syncFromDd(ddLat, ddLon) }, "Convert & Calculate Grid")), format === "dms" && /* @__PURE__ */ React.createElement("div", { style: modalStyles.section }, /* @__PURE__ */ React.createElement("div", { style: modalStyles.sectionTitle }, "Degrees Minutes Seconds (DMS)"), /* @__PURE__ */ React.createElement("div", { style: modalStyles.row }, /* @__PURE__ */ React.createElement("div", { style: { flex: 1 } }, /* @__PURE__ */ React.createElement("label", { style: modalStyles.label }, "Latitude N"), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "4px", alignItems: "center" } }, /* @__PURE__ */ React.createElement("input", { style: modalStyles.inputSmall, placeholder: "DD", value: dmsLatDeg, onChange: (e) => setDmsLatDeg(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, "\xB0"), /* @__PURE__ */ React.createElement("input", { style: modalStyles.inputSmall, placeholder: "MM", value: dmsLatMin, onChange: (e) => setDmsLatMin(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, "'"), /* @__PURE__ */ React.createElement("input", { style: modalStyles.inputSmall, placeholder: "SS.SS", value: dmsLatSec, onChange: (e) => setDmsLatSec(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, '"')))), /* @__PURE__ */ React.createElement("div", { style: modalStyles.row }, /* @__PURE__ */ React.createElement("div", { style: { flex: 1 } }, /* @__PURE__ */ React.createElement("label", { style: modalStyles.label }, "Longitude W"), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "4px", alignItems: "center" } }, /* @__PURE__ */ React.createElement("input", { style: modalStyles.inputSmall, placeholder: "DDD", value: dmsLonDeg, onChange: (e) => setDmsLonDeg(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, "\xB0"), /* @__PURE__ */ React.createElement("input", { style: modalStyles.inputSmall, placeholder: "MM", value: dmsLonMin, onChange: (e) => setDmsLonMin(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, "'"), /* @__PURE__ */ React.createElement("input", { style: modalStyles.inputSmall, placeholder: "SS.SS", value: dmsLonSec, onChange: (e) => setDmsLonSec(e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: modalStyles.unitLabel }, '"')))), /* @__PURE__ */ React.createElement("button", { style: { ...modalStyles.button, ...modalStyles.buttonSecondary, width: "100%", marginTop: "8px" }, onClick: syncFromDms }, "Convert & Calculate Grid")), ddLat && ddLon && /* @__PURE__ */ React.createElement("div", { style: modalStyles.section }, /* @__PURE__ */ React.createElement("div", { style: modalStyles.sectionTitle }, "All Formats"), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "12px", fontFamily: "monospace", lineHeight: "1.8" } }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0" } }, "DD:"), " ", /* @__PURE__ */ React.createElement("span", { style: { color: "#68d391" } }, ddLat, "\xB0 N, ", ddLon, "\xB0 W")), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0" } }, "DDM:"), " ", /* @__PURE__ */ React.createElement("span", { style: { color: "#68d391" } }, ddmLatDeg, "\xB0 ", ddmLatMin, "' N, ", ddmLonDeg, "\xB0 ", ddmLonMin, "' W")), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0" } }, "DMS:"), " ", /* @__PURE__ */ React.createElement("span", { style: { color: "#68d391" } }, dmsLatDeg, "\xB0 ", dmsLatMin, "' ", dmsLatSec, '" N, ', dmsLonDeg, "\xB0 ", dmsLonMin, "' ", dmsLonSec, '" W')))), capGrid && /* @__PURE__ */ React.createElement("div", { style: modalStyles.gridResult }, /* @__PURE__ */ React.createElement("div", { style: modalStyles.sectionTitle }, "CAP Grid"), capGrid.sectional ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { style: modalStyles.gridMain }, capGrid.full), /* @__PURE__ */ React.createElement("div", { style: modalStyles.gridSub }, capGrid.sectionalName, " Sectional \u2022 Grid ", capGrid.grid, " \u2022 Quadrant ", capGrid.quadrant)) : /* @__PURE__ */ React.createElement("div", { style: { color: "#fc8181" } }, capGrid.full)), /* @__PURE__ */ React.createElement("div", { style: { ...modalStyles.row, justifyContent: "center", marginTop: "16px" } }, /* @__PURE__ */ React.createElement("label", { style: { display: "flex", alignItems: "center", gap: "8px", fontSize: "12px", color: "#a0aec0", cursor: "pointer" } }, /* @__PURE__ */ React.createElement("input", { type: "checkbox", checked: offlineMode, onChange: (e) => setOfflineMode(e.target.checked) }), "Offline Mode (disable map features)")), /* @__PURE__ */ React.createElement("button", { style: { ...modalStyles.button, ...modalStyles.buttonSuccess, width: "100%", marginTop: "16px" }, onClick: handleApply }, "\u2713 Apply Coordinates to Event"))));
    };
    const [gpsModalOpen, setGpsModalOpen] = useState(false);
    const [gpsModalEventId, setGpsModalEventId] = useState(null);
    const [gpsModalInitialLat, setGpsModalInitialLat] = useState("");
    const [gpsModalInitialLon, setGpsModalInitialLon] = useState("");
    const openGpsModal = (eventId, latDeg, latMin, lonDeg, lonMin) => {
      setGpsModalEventId(eventId);
      setGpsModalInitialLat(latDeg);
      setGpsModalInitialLon(latMin);
      setGpsModalOpen(true);
    };
    const handleGpsApply = (eventId, latDeg, latMin, lonDeg, lonMin, capGrid) => {
      if (eventId) {
        setEvents(events.map((e) => e.id === eventId ? {
          ...e,
          latDeg,
          latMin,
          longDeg: lonDeg,
          longMin: lonMin,
          capGrid: capGrid?.full || ""
        } : e));
      }
    };
    // UTC Time Utilities - Military 24-hour format
    const getCurrentZuluTime = () => {
      const d = new Date();
      const day = d.getUTCDate().toString().padStart(2, '0');
      const months = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
      const mon = months[d.getUTCMonth()];
      const year = d.getUTCFullYear();
      const hh = d.getUTCHours().toString().padStart(2, '0');
      const mm = d.getUTCMinutes().toString().padStart(2, '0');
      return `${day}${mon}${year} ${hh}${mm}`;
    };
    const getZuluTimeOnly = () => {
      const d = new Date();
      const hh = d.getUTCHours().toString().padStart(2, '0');
      const mm = d.getUTCMinutes().toString().padStart(2, '0');
      return `${hh}${mm}`;
    };
    const getZuluDate = () => {
      const d = new Date();
      const day = d.getUTCDate().toString().padStart(2, '0');
      const months = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
      const mon = months[d.getUTCMonth()];
      const year = d.getUTCFullYear();
      return `${day}${mon}${year}`;
    };
    const getZuluDateTime = () => {
      const d = new Date();
      const day = d.getUTCDate().toString().padStart(2, '0');
      const months = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
      const mon = months[d.getUTCMonth()];
      const year = d.getUTCFullYear();
      const hh = d.getUTCHours().toString().padStart(2, '0');
      const mm = d.getUTCMinutes().toString().padStart(2, '0');
      return `${day}${mon}${year} ${hh}${mm}Z`;
    };
    // Format for display: converts HHMM to HH:MM for time inputs, or returns as-is
    const formatTimeDisplay = (t) => {
      if (!t) return '';
      // If already has colon, return as-is
      if (t.includes(':')) return t;
      // If 4 digits, format as HH:MM
      if (/^\d{4}$/.test(t)) return t.slice(0,2) + ':' + t.slice(2,4);
      return t;
    };
    // Parse time input - accepts HHMM or HH:MM
    const parseTimeInput = (t) => {
      if (!t) return '';
      // Remove colon if present
      return t.replace(':', '');
    };
    useEffect(() => {
      if (!missionInfo.dateZ) setMissionInfo((prev) => ({ ...prev, dateZ: getZuluDate() }));
    }, []);
    useEffect(() => {
      const tachElapsed = calculateElapsed(times.tachStart, times.tachShutdown);
      const hobbsElapsed = calculateElapsed(times.hobbsStart, times.hobbsShutdown);
      const searchTime = calculateTimeElapsed(times.enteredSearchArea, times.departedSearchArea);
      const totalFlight = calculateTimeElapsed(times.takeoffTime, times.landingTime);
      const enroute = totalFlight && searchTime ? (parseFloat(totalFlight) - parseFloat(searchTime)).toFixed(1) : "";
      setCalculated({ tachElapsed, hobbsElapsed, enrouteTime: enroute, searchTime });
    }, [times]);
    const calculateElapsed = (start, end) => {
      if (!start || !end) return "";
      const elapsed = parseFloat(end) - parseFloat(start);
      return elapsed > 0 ? elapsed.toFixed(1) : "";
    };
    const calculateTimeElapsed = (start, end) => {
      if (!start || !end) return "";
      // Handle both HHMM and HH:MM formats
      const parseTime = (t) => {
        if (t.includes(':')) {
          const [h, m] = t.split(':').map(Number);
          return h * 60 + m;
        } else if (/^\d{4}$/.test(t)) {
          return parseInt(t.slice(0,2)) * 60 + parseInt(t.slice(2,4));
        }
        return 0;
      };
      const startMins = parseTime(start);
      const endMins = parseTime(end);
      const elapsed = (endMins - startMins) / 60;
      return elapsed > 0 ? elapsed.toFixed(1) : "";
    };
    const addEvent = () => {
      eventSeqRef.current = (eventSeqRef.current || 1) + 1;
      setEvents([createEmptyEvent(eventSeqRef.current), ...events]);
    };
    const removeEvent = (id) => events.length > 1 && setEvents(events.filter((e) => e.id !== id));
    const updateEvent = (id, field, value) => setEvents(events.map((e) => e.id === id ? { ...e, [field]: value } : e));
    const setEventDateTime = (id) => {
      setEvents(events.map((e) => e.id === id ? { ...e, dateZ: getZuluDate(), timeZ: getZuluTimeOnly() } : e));
    };
    const selectEventType = (id, eventType) => {
      setEvents(events.map((e) => {
        if (e.id === id) {
          const updates = { eventType };
          if (!e.timeZ) {
            updates.timeZ = getZuluTimeOnly();
            updates.dateZ = getZuluDate();
          }
          return { ...e, ...updates };
        }
        return e;
      }));
    };
    
    // Enhanced localStorage - save all mission data including ELT, Crosshair, and Search Planner
    useEffect(() => {
      const data = { 
        missionInfo, crewManifest, times, fuelOil, notes, events, targetLocations,
        eltObservations, eltSolutions, eltSettings, radioCallSigns, nightMode, textSize,
        crosshairPoints, crosshairResult, crosshairAnalysis,
        searchPlan: spState.lastPlan, searchPlanHistory: spState.planHistory
      };
      localStorage.setItem("capObserverLog", JSON.stringify(data));
    }, [missionInfo, crewManifest, times, fuelOil, notes, events, targetLocations, eltObservations, eltSolutions, eltSettings, radioCallSigns, nightMode, textSize, crosshairPoints, crosshairResult, crosshairAnalysis, spState.lastPlan, spState.planHistory]);
    
    // Load saved data on startup with resume prompt
    useEffect(() => {
      const saved = localStorage.getItem("capObserverLog");
      if (saved) {
        try {
          const data = JSON.parse(saved);
          // Check if there's meaningful data to restore
          const hasData = data.missionInfo?.missionNumber || 
                         (data.events && data.events.some(e => e.eventType || e.notes)) ||
                         (data.eltObservations && data.eltObservations.length > 0);
          
          if (hasData) {
            const resume = confirm('Previous mission data found. Resume where you left off?');
            if (!resume) {
              localStorage.removeItem("capObserverLog");
              return;
            }
          }
          
          if (data.missionInfo) setMissionInfo(data.missionInfo);
          if (data.crewManifest) setCrewManifest(data.crewManifest);
          if (data.times) setTimes(data.times);
          if (data.fuelOil) setFuelOil(data.fuelOil);
          if (data.notes) setNotes(data.notes);
          if (data.events) setEvents(data.events);
          if (data.targetLocations) setTargetLocations(data.targetLocations);
          if (data.eltObservations) setEltObservations(data.eltObservations);
          if (data.eltSolutions) setEltSolutions(data.eltSolutions);
          if (data.eltSettings) setEltSettings(data.eltSettings);
          if (data.radioCallSigns) setRadioCallSigns(data.radioCallSigns);
          if (data.nightMode) setNightMode(data.nightMode);
          if (data.textSize) setTextSize(data.textSize);
          if (data.crosshairPoints) setCrosshairPoints(data.crosshairPoints);
          if (data.crosshairResult) setCrosshairResult(data.crosshairResult);
          if (data.crosshairAnalysis) setCrosshairAnalysis(data.crosshairAnalysis);
          if (data.searchPlan || data.searchPlanHistory) {
            setSpState(prev => ({
              ...prev,
              lastPlan: data.searchPlan || prev.lastPlan,
              planHistory: data.searchPlanHistory || prev.planHistory
            }));
          }
        } catch (e) {
          console.error("Failed to load saved data:", e);
        }
      }
    }, []);
    
    // Ops Normal Timer Effect
    useEffect(() => {
      if (!opsTimerEnabled || !opsTimerLastReset) return;
      
      const interval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - opsTimerLastReset) / 1000);
        const remaining = (opsTimerMinutes * 60) - elapsed;
        setOpsTimerRemaining(Math.max(0, remaining));
      }, 1000);
      
      return () => clearInterval(interval);
    }, [opsTimerEnabled, opsTimerLastReset, opsTimerMinutes]);
    
    // Night mode class toggle
    useEffect(() => {
      if (nightMode) {
        document.body.classList.add('night-mode');
      } else {
        document.body.classList.remove('night-mode');
      }
    }, [nightMode]);
    
    // Coordinate validation helper
    const validateCoordinate = (value, type) => {
      const num = parseFloat(value);
      if (isNaN(num)) return true; // Empty is OK
      if (type === 'latDeg') return num >= 0 && num <= 90;
      if (type === 'lonDeg') return num >= 0 && num <= 180;
      if (type === 'latMin' || type === 'lonMin') return num >= 0 && num < 60;
      return true;
    };
    
    // CSV Export function
    const exportToCSV = () => {
      const rows = [];
      
      // Header
      rows.push(['CAP OBSERVER LOG EXPORT']);
      rows.push(['Generated', new Date().toISOString()]);
      rows.push([]);
      
      // Mission Info
      rows.push(['MISSION INFORMATION']);
      rows.push(['Mission #', missionInfo.missionNumber]);
      rows.push(['Date (Z)', missionInfo.dateZ]);
      rows.push(['Sortie #', missionInfo.sortieNumber]);
      rows.push(['Aircraft', missionInfo.aircraftTailN]);
      rows.push(['Observer', missionInfo.observerName]);
      rows.push([]);
      
      // Times
      rows.push(['TIME TRACKING']);
      rows.push(['Tach Start', times.tachStart]);
      rows.push(['Tach Shutdown', times.tachShutdown]);
      rows.push(['Hobbs Start', times.hobbsStart]);
      rows.push(['Hobbs Shutdown', times.hobbsShutdown]);
      rows.push(['Takeoff', times.takeoffTime]);
      rows.push(['Landing', times.landingTime]);
      rows.push(['Entered Search', times.enteredSearchArea]);
      rows.push(['Departed Search', times.departedSearchArea]);
      rows.push([]);
      
      // Events
      rows.push(['EVENTS LOG']);
      rows.push(['#', 'Type', 'Date (Z)', 'Time (Z)', 'Lat Deg', 'Lat Min', 'Lon Deg', 'Lon Min', 'CAP Grid', 'MSL', 'AGL', 'Hdg', 'AS', 'GS', 'Notes']);
      events.forEach(e => {
        if (e.eventType || e.timeZ || e.notes) {
          rows.push([
            e.eventNum, e.eventType, e.dateZ || '', e.timeZ, e.latDeg, e.latMin, e.longDeg, e.longMin,
            e.capGrid, e.altMSL, e.altAGL, e.heading, e.airspeed, e.groundSpeed, e.notes
          ]);
        }
      });
      rows.push([]);
      
      // ELT Observations
      if (eltObservations && eltObservations.length > 0) {
        rows.push(['ELT OBSERVATIONS']);
        rows.push(['#', 'Time', 'Source', 'Lat Deg', 'Lat Min', 'Lon Deg', 'Lon Min', 'Range NM', 'Accuracy', 'DF Bearing', 'Strength', 'Notes']);
        eltObservations.forEach(o => {
          rows.push([
            o.obsNum, o.timeZ, o.source, o.latDeg, o.latMin, o.lonDeg, o.lonMin,
            o.directRange, o.rangeAccuracy, o.dfBearing, o.strength, o.notes
          ]);
        });
        rows.push([]);
      }
      
      // Convert to CSV string
      const csvContent = rows.map(row => 
        row.map(cell => {
          const str = String(cell ?? '');
          return str.includes(',') || str.includes('"') || str.includes('\n') 
            ? '"' + str.replace(/"/g, '""') + '"' 
            : str;
        }).join(',')
      ).join('\n');
      
      // Download
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `CAP_Log_${missionInfo.missionNumber || 'Mission'}_${new Date().toISOString().slice(0,10)}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

    const generatePDF = () => {
      try {
      const printWindow = window.open("", "_blank");
      if (!printWindow) {
        alert('Could not open print window. Please allow pop-ups for this site.');
        return;
      }
      const escHtml = (s) => String(s ?? "").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;");
const escNl = (s) => escHtml(s).replace(/\n/g,"<br>");
printWindow.document.write(`
          <!DOCTYPE html><html><head><title>Mission Aircrew Toolkit - ${missionInfo.missionNumber || "Mission"}</title>
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <style>
            @page { size: letter landscape; margin: 0.5in; }
            @media print { .no-print { display: none !important; } body { padding-top: 0 !important; } }
            body { font-family: 'Courier New', monospace; font-size: 10pt; color: #000; background: #fff; padding-top: 60px; }
            .mobile-header { 
              position: fixed; top: 0; left: 0; right: 0; z-index: 9999;
              background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
              padding: 10px 16px; display: flex; justify-content: space-between; align-items: center;
              box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            }
            .mobile-header h1 { color: #fff; font-size: 14pt; margin: 0; font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
            .mobile-header-btns { display: flex; gap: 8px; }
            .mobile-header-btn {
              padding: 8px 14px; border-radius: 6px; border: none; font-size: 12pt; font-weight: 600;
              cursor: pointer; font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            }
            .btn-back { background: rgba(255,255,255,0.2); color: #fff; }
            .btn-back:hover { background: rgba(255,255,255,0.3); }
            .btn-print { background: #48bb78; color: #fff; }
            .btn-print:hover { background: #38a169; }
            .header { display: flex; align-items: center; gap: 20px; border-bottom: 2px solid #1a365d; padding-bottom: 10px; margin-bottom: 15px; }
            .cap-logo { width: 60px; height: 60px; background: #1a365d; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; }
            .title { font-size: 16pt; font-weight: bold; color: #1a365d; }
            .section { margin-bottom: 15px; border: 1px solid #ccc; padding: 10px; border-radius: 4px; }
            .section-title { font-weight: bold; background: #1a365d; color: white; padding: 4px 8px; margin: -10px -10px 10px -10px; border-radius: 3px 3px 0 0; }
            .grid { display: grid; gap: 8px; }
            .grid-2 { grid-template-columns: 1fr 1fr; }
            .grid-3 { grid-template-columns: 1fr 1fr 1fr; }
            .field { display: flex; gap: 5px; align-items: baseline; }
            .label { font-weight: bold; font-size: 9pt; }
            .value { border-bottom: 1px solid #333; min-width: 80px; padding: 2px 4px; }
            table { width: 100%; border-collapse: collapse; font-size: 9pt; }
            th, td { border: 1px solid #999; padding: 4px 6px; text-align: left; }
            th { background: #e2e8f0; }
            .notes { min-height: 60px; white-space: pre-wrap; font-size: 9pt; }
            .checkbox { display: inline-block; width: 14px; height: 14px; border: 1px solid #333; margin-right: 4px; text-align: center; line-height: 12px; }
            .checkbox.checked::after { content: '\u2713'; }
            .two-column { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
          </style>  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    .search-planner-map { height: 350px; border-radius: 8px; margin: 10px 0; border: 2px solid rgba(56,161,105,0.3); }
    .sp-grid-info { background: rgba(49,130,206,0.15); border: 1px solid rgba(49,130,206,0.4); border-radius: 8px; padding: 12px; margin: 10px 0; }
    .sp-coverage { background: rgba(56,161,105,0.15); border: 1px solid rgba(56,161,105,0.4); border-radius: 8px; padding: 12px; margin: 10px 0; }
  </style>
</head><body>
            <div class="mobile-header no-print">
              <h1> Mission Report</h1>
              <div class="mobile-header-btns">
                <button class="mobile-header-btn btn-back" onclick="window.close()">\u2190 Back</button>
                <button class="mobile-header-btn btn-print" onclick="window.print()"> Print</button>
              </div>
            </div>
            <div class="header"><img src="https://www.gocivilairpatrol.com/local/public/shared/assets/images/websites/CAP-2017-logo-horizontal-optimized-d73f31575f10142a77f0888cdfb36256.png" alt="CAP" style="height: 50px; margin-right: 15px;"><div><div class="title">Mission Aircrew Toolkit</div><div>Civil Air Patrol - U.S. Air Force Auxiliary</div></div></div>
            <div class="two-column"><div>
              <div class="section"><div class="section-title">Mission Information</div><div class="grid grid-2">
                <div class="field"><span class="label">Mission #:</span> <span class="value">${missionInfo.missionNumber}</span></div>
                <div class="field"><span class="label">Symbol:</span> <span class="value">${missionInfo.missionSymbol}</span></div>
                <div class="field"><span class="label">Date (Z):</span> <span class="value">${missionInfo.dateZ}</span></div>
                <div class="field"><span class="label">Sortie #:</span> <span class="value">${missionInfo.sortieNumber}</span></div>
                <div class="field"><span class="label">Aircraft N:</span> <span class="value">${missionInfo.aircraftTailN}</span></div>
                <div class="field"><span class="label">Log Page:</span> <span class="value">${missionInfo.logPageNumber} of ${missionInfo.totalPages}</span></div>
              </div>
              ${missionInfo.routeOfFlight ? `<div style="margin-top: 8px;"><span class="label">Route:</span> <span class="value" style="min-width: 200px;">${escHtml(missionInfo.routeOfFlight)}</span></div>` : ''}
              </div>
              <div class="section"><div class="section-title">Crew Manifest</div>
                <table><tr><th>Position</th><th>Name</th><th>CAPID</th><th>Qual</th></tr>
                ${crewManifest.filter(c => c.name || c.capid).map(c => `<tr><td>${escHtml(c.position)}</td><td>${escHtml(c.name)}</td><td>${escHtml(c.capid)}</td><td>${escHtml(c.qualification)}</td></tr>`).join('') || '<tr><td colspan="4" style="color:#666;font-style:italic;">(No crew entered)</td></tr>'}
                </table>
                ${missionInfo.observerName ? `<div style="margin-top: 8px;"><span class="label">Observer/Logger:</span> <span class="value">${escHtml(missionInfo.observerName)}</span></div>` : ''}
              </div>
              <div class="section"><div class="section-title">Time Tracking (All Times UTC)</div>
                <table><tr><th></th><th>Tach</th><th>Hobbs</th><th>Time (Z)</th></tr>
                <tr><td><strong>Engine Start</strong></td><td>${times.tachStart}</td><td>${times.hobbsStart}</td><td></td></tr>
                <tr><td><strong>\u2605 Takeoff</strong></td><td></td><td></td><td>${times.takeoffTime}</td></tr>
                <tr><td><strong>\u2605\u25BC Entered Search</strong></td><td></td><td></td><td>${times.enteredSearchArea}</td></tr>
                <tr><td><strong>\u2605\u25BC Departed Search</strong></td><td></td><td></td><td>${times.departedSearchArea}</td></tr>
                <tr><td><strong>\u2605 Landing</strong></td><td></td><td></td><td>${times.landingTime}</td></tr>
                <tr><td><strong>Shutdown</strong></td><td>${times.tachShutdown}</td><td>${times.hobbsShutdown}</td><td></td></tr>
                <tr><td><strong>Elapsed</strong></td><td>${calculated.tachElapsed}</td><td>${calculated.hobbsElapsed}</td><td></td></tr></table>
                <div class="grid grid-2" style="margin-top: 8px;">
                  <div class="field"><span class="label">Enroute:</span> <span class="value">${calculated.enrouteTime}</span></div>
                  <div class="field"><span class="label">Search:</span> <span class="value">${calculated.searchTime}</span></div>
                </div></div>
              <div class="section"><div class="section-title">Fuel & Oil</div><div class="grid grid-3">
                <div class="field"><span class="label">Fuel:</span> <span class="value">${fuelOil.fuelGallons} gal</span></div>
                <div class="field"><span class="label">Cost:</span> <span class="value">$${fuelOil.fuelCost}</span></div>
                <div class="field"><span class="label">Oil:</span> <span class="value">${fuelOil.oilQt} qt</span></div>
              </div></div>
            </div><div>
              <div class="section"><div class="section-title">Notes</div><div class="notes">${escNl(notes) || "(No notes)"}</div></div>
            </div></div>
            <div class="section"><div class="section-title">Events Log</div>
              <table><tr>
  <th style="width:30px">#</th>
  <th style="width:110px">Event</th>
  <th style="width:130px">Date/Time (Z)</th>
  <th style="width:125px">Lat N</th>
  <th style="width:125px">Lon W</th>
  <th style="width:100px">CAP Grid</th>
  <th style="width:50px">MSL</th>
  <th style="width:50px">AGL</th>
  <th style="width:45px">Hdg</th>
  <th style="width:45px">AS</th>
  <th style="width:45px">GS</th>
</tr>
${events.filter(e => e.eventType || e.timeZ || e.notes).map((e, idx) => `
  <tr>
    <td style="text-align:center;font-weight:bold;color:#1a365d">${e.eventNum || idx + 1}</td>
    <td>${escHtml(e.eventType)}</td>
    <td>${escHtml((e.dateZ || "") + " " + (e.timeZ || ""))}</td>
    <td>${e.latDeg ? escHtml(e.latDeg + " " + e.latMin + "'") : ""}</td>
    <td>${e.longDeg ? escHtml(e.longDeg + " " + e.longMin + "'") : ""}</td>
    <td style="font-weight:bold;color:#1a365d">${escHtml(e.capGrid || "")}</td>
    <td>${escHtml(e.altMSL)}</td>
    <td>${escHtml(e.altAGL)}</td>
    <td>${escHtml(e.heading)}</td>
    <td>${escHtml(e.airspeed)}</td>
    <td>${escHtml(e.groundSpeed)}</td>
  </tr>
  ${e.notes ? `<tr>
    <td colspan="11" style="padding:6px 8px;background:#f8f9fa">
      <div style="font-size:9pt;color:#333;white-space:normal;line-height:1.25">
        <span style="font-weight:bold;color:#555">Notes:</span>
        ${escNl(e.notes)}
      </div>
    </td>
  </tr>` : ''}
`).join("")}
${events.filter(e => e.eventType || e.timeZ || e.notes).length === 0 ? '<tr><td colspan="11" style="color:#666;font-style:italic;text-align:center;padding:12px">(No events logged)</td></tr>' : ''}
</table></div>
${proficiencyState.selectedProfile ? `
<div class="section"><div class="section-title">Proficiency Profile (P${proficiencyState.selectedProfile})</div>
  <div class="grid grid-2" style="margin-bottom: 10px;">
    <div class="field"><span class="label">Profile:</span> <span class="value">${proficiencyProfiles.find(p => p.id === proficiencyState.selectedProfile)?.name || ''}</span></div>
    <div class="field"><span class="label">Started:</span> <span class="value">${proficiencyState.startTime ? new Date(proficiencyState.startTime).toLocaleTimeString() : ''}</span></div>
  </div>
  <table><tr><th style="width:40px">\u2713</th><th style="width:100px">Section</th><th>Task</th><th style="width:80px">Time</th></tr>
  ${(() => {
    const profile = proficiencyProfiles.find(p => p.id === proficiencyState.selectedProfile);
    if (!profile) return '';
    let allItems = [];
    (profile.sections || []).forEach(section => {
      (section.groups || []).forEach(group => {
        (group.items || []).forEach(item => {
          allItems.push({ ...item, sectionType: section.type, sectionTitle: section.title });
        });
      });
    });
    return allItems.map(item => {
      const completed = proficiencyState.completedItems[item.id];
      const typeLabel = item.sectionType === 'required' ? 'Required' : item.sectionType === 'block' ? item.sectionTitle : 'Routine';
      return '<tr><td style="text-align:center">' + (completed ? '\u2713' : '') + '</td><td>' + escHtml(typeLabel) + '</td><td>' + escHtml(item.text) + '</td><td>' + (completed ? new Date(completed).toLocaleTimeString() : '') + '</td></tr>';
    }).join('');
  })()}
  </table>
  ${proficiencyState.notes ? '<div style="margin-top:8px"><span class="label">Notes:</span> ' + escNl(proficiencyState.notes) + '</div>' : ''}
</div>` : ''}
${crosshairResult ? `
<div class="section" style="page-break-inside: avoid;">
  <div class="section-title"> Crosshair Target Location</div>
  <div class="two-column">
    <div>
      <div style="background:#f0f4f8;padding:12px;border-radius:6px;margin-bottom:10px;border:2px solid ${crosshairResult.qualityColor || '#d69e2e'}">
        <div style="font-size:10px;color:#666;text-transform:uppercase;letter-spacing:1px">CAP Grid</div>
        <div style="font-size:20px;font-weight:bold;color:#1a365d;font-family:monospace;letter-spacing:2px">${crosshairResult.capGrid}</div>
      </div>
      <div class="grid grid-2">
        <div class="field"><span class="label">Target:</span> <span class="value">${crosshairResult.targetLabel || 'Target'}</span></div>
        <div class="field"><span class="label">Time (Z):</span> <span class="value">${crosshairResult.timestamp || ''}</span></div>
      </div>
      <div style="margin-top:8px">
        <div class="field"><span class="label">Lat N:</span> <span class="value">${crosshairResult.latDeg} ${crosshairResult.latMin}'</span></div>
        <div class="field"><span class="label">Lon W:</span> <span class="value">${crosshairResult.lonDeg} ${crosshairResult.lonMin}'</span></div>
        <div class="field"><span class="label">DD:</span> <span class="value" style="font-family:monospace">${crosshairResult.ddText || ''}</span></div>
        <div class="field"><span class="label">DMS:</span> <span class="value" style="font-family:monospace">${crosshairResult.dmsText || ''}</span></div>
      </div>
    </div>
    <div>
      <div style="background:#f0f4f8;padding:10px;border-radius:6px;margin-bottom:10px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
          <span style="font-size:10px;color:#666;text-transform:uppercase">Solution Quality</span>
          <span style="font-size:12px;font-weight:bold;color:${crosshairResult.qualityColor || '#d69e2e'}">${crosshairResult.qualityRating} (${crosshairResult.qualityScore}%)</span>
        </div>
        <div style="height:8px;background:#e2e8f0;border-radius:4px;overflow:hidden">
          <div style="height:100%;width:${crosshairResult.qualityScore}%;background:${crosshairResult.qualityColor || '#d69e2e'}"></div>
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:6px;font-size:9px;color:#666">
          <span>Crossing Angle: ${Math.round(crosshairResult.crossingAngle || 0)}</span>
          <span>Expected: ${crosshairResult.expectedAccuracy || 'Unknown'}</span>
        </div>
      </div>
      <div class="grid grid-2" style="font-size:9pt">
        <div class="field"><span class="label">Method:</span> <span class="value">${escHtml(crosshairResult.method || '')}</span></div>
        <div class="field"><span class="label">Path 1 Pts:</span> <span class="value">${crosshairResult.path1Count || 0}</span></div>
        <div class="field"><span class="label">Path 2 Pts:</span> <span class="value">${crosshairResult.path2Count || 0}</span></div>
        <div class="field"><span class="label">Closest Appr:</span> <span class="value">${crosshairResult.closestApproachNM ? crosshairResult.closestApproachNM.toFixed(2) + ' NM' : ''}</span></div>
      </div>
    </div>
  </div>
  ${crosshairPoints && crosshairPoints.length >= 4 && crosshairResult ? `
  <div style="margin-top:10px">
    <div style="font-weight:bold;font-size:9pt;margin-bottom:6px">Flight Path Diagram:</div>
    <div style="background:#fff;border:1px solid #ccc;border-radius:8px;padding:10px;text-align:center">
      ${(() => {
        const pts = crosshairPoints;
        const targetLat = crosshairResult.latDD;
        const targetLon = crosshairResult.lonDD;
        
        // Convert points to DD
        const ddPts = pts.map(p => ({
          lat: parseFloat(p.latDeg) + parseFloat(p.latMin) / 60,
          lon: parseFloat(p.lonDeg) + parseFloat(p.lonMin) / 60
        }));
        
        // Find bounds
        let minLat = targetLat, maxLat = targetLat, minLon = targetLon, maxLon = targetLon;
        ddPts.forEach(p => {
          if (p.lat < minLat) minLat = p.lat;
          if (p.lat > maxLat) maxLat = p.lat;
          if (p.lon < minLon) minLon = p.lon;
          if (p.lon > maxLon) maxLon = p.lon;
        });
        
        const latPad = Math.max((maxLat - minLat) * 0.15, 0.005);
        const lonPad = Math.max((maxLon - minLon) * 0.15, 0.005);
        minLat -= latPad; maxLat += latPad;
        minLon -= lonPad; maxLon += lonPad;
        
        const width = 350, height = 250;
        const scaleX = width / (maxLon - minLon);
        const scaleY = height / (maxLat - minLat);
        const scale = Math.min(scaleX, scaleY) * 0.85;
        
        const toX = (lon) => (lon - minLon) * scale + (width - (maxLon - minLon) * scale) / 2;
        const toY = (lat) => height - ((lat - minLat) * scale + (height - (maxLat - minLat) * scale) / 2);
        
        let svg = '<svg width="' + width + '" height="' + height + '" style="background:#f7fafc;border-radius:4px">';
        
        // Grid
        svg += '<defs><pattern id="gridCH" width="30" height="30" patternUnits="userSpaceOnUse"><path d="M 30 0 L 0 0 0 30" fill="none" stroke="#e2e8f0" stroke-width="1"/></pattern></defs>';
        svg += '<rect width="100%" height="100%" fill="url(#gridCH)"/>';
        
        // Split points into two paths (first half, second half)
        const mid = Math.ceil(ddPts.length / 2);
        const path1 = ddPts.slice(0, mid);
        const path2 = ddPts.slice(mid);
        
        // Draw Path 1 (blue)
        if (path1.length > 1) {
          let pathD = 'M ' + toX(path1[0].lon) + ' ' + toY(path1[0].lat);
          path1.slice(1).forEach(p => { pathD += ' L ' + toX(p.lon) + ' ' + toY(p.lat); });
          svg += '<path d="' + pathD + '" fill="none" stroke="#0066cc" stroke-width="3"/>';
        }
        path1.forEach((p, i) => {
          svg += '<circle cx="' + toX(p.lon) + '" cy="' + toY(p.lat) + '" r="6" fill="#0066cc" stroke="#fff" stroke-width="2"/>';
        });
        
        // Draw Path 2 (green)
        if (path2.length > 1) {
          let pathD = 'M ' + toX(path2[0].lon) + ' ' + toY(path2[0].lat);
          path2.slice(1).forEach(p => { pathD += ' L ' + toX(p.lon) + ' ' + toY(p.lat); });
          svg += '<path d="' + pathD + '" fill="none" stroke="#006600" stroke-width="3"/>';
        }
        path2.forEach((p, i) => {
          svg += '<circle cx="' + toX(p.lon) + '" cy="' + toY(p.lat) + '" r="6" fill="#006600" stroke="#fff" stroke-width="2"/>';
        });
        
        // Target point
        const tx = toX(targetLon);
        const ty = toY(targetLat);
        svg += '<circle cx="' + tx + '" cy="' + ty + '" r="10" fill="#cc0000" stroke="#fff" stroke-width="3"/>';
        svg += '<line x1="' + (tx-15) + '" y1="' + ty + '" x2="' + (tx+15) + '" y2="' + ty + '" stroke="#fff" stroke-width="2"/>';
        svg += '<line x1="' + tx + '" y1="' + (ty-15) + '" x2="' + tx + '" y2="' + (ty+15) + '" stroke="#fff" stroke-width="2"/>';
        
        // Legend
        svg += '<rect x="10" y="10" width="120" height="55" fill="rgba(255,255,255,0.9)" stroke="#ccc" rx="4"/>';
        svg += '<line x1="20" y1="25" x2="40" y2="25" stroke="#0066cc" stroke-width="3"/><text x="45" y="28" font-size="9" fill="#333">Path 1 (' + path1.length + ')</text>';
        svg += '<line x1="20" y1="40" x2="40" y2="40" stroke="#006600" stroke-width="3"/><text x="45" y="43" font-size="9" fill="#333">Path 2 (' + path2.length + ')</text>';
        svg += '<circle cx="30" cy="55" r="5" fill="#cc0000"/><text x="45" y="58" font-size="9" fill="#333">Target</text>';
        
        svg += '</svg>';
        return svg;
      })()}
      <div style="font-size:8pt;color:#666;margin-top:6px">Crosshair flight paths - schematic diagram. North is up.</div>
    </div>
  </div>` : ''}
  ${crosshairPoints && crosshairPoints.length > 0 ? `
  <div style="margin-top:10px">
    <div style="font-weight:bold;font-size:9pt;margin-bottom:6px">Data Points (${crosshairPoints.length} total):</div>
    <table style="font-size:8pt">
      <tr><th>#</th><th>Time</th><th>Lat N</th><th>Lon W</th></tr>
      ${crosshairPoints.map((pt, idx) => `<tr>
        <td>${idx + 1}</td>
        <td>${escHtml(pt.time || '')}</td>
        <td>${pt.latDeg} ${pt.latMin}'</td>
        <td>${pt.lonDeg} ${pt.lonMin}'</td>
      </tr>`).join('')}
    </table>
  </div>` : ''}
</div>` : ''}
${(eltObservations && eltObservations.length > 0) || (eltSolutions && eltSolutions.length > 0) ? `
<div class="section" style="page-break-inside: avoid;">
  <div class="section-title"> ELT Triangulation Assistant</div>
  ${eltSolutions && eltSolutions.length > 0 ? `
  <div style="margin-bottom:15px">
    <div style="font-weight:bold;font-size:10pt;margin-bottom:8px;color:#1a365d">Computed Solutions (${eltSolutions.length})</div>
    ${eltSolutions.map((sol, idx) => `
    <div style="background:#f0f4f8;padding:12px;border-radius:6px;margin-bottom:10px;border-left:4px solid ${sol.qualityScore >= 70 ? '#38a169' : sol.qualityScore >= 40 ? '#d69e2e' : '#e53e3e'}">
      <div class="two-column">
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <span style="font-weight:bold;color:#1a365d">Solution #${sol.solutionNum || idx + 1}</span>
            <span style="font-size:9pt;color:#666">${sol.timestamp || ''}</span>
          </div>
          <div style="background:#fff;padding:10px;border-radius:4px;margin-bottom:8px;border:2px solid #d69e2e">
            <div style="font-size:9px;color:#666;text-transform:uppercase">CAP Grid</div>
            <div style="font-size:18px;font-weight:bold;color:#1a365d;font-family:monospace">${sol.capGrid || 'N/A'}</div>
          </div>
          <div class="grid grid-2" style="font-size:9pt">
            <div class="field"><span class="label">Lat N:</span> <span class="value">${sol.centroid ? sol.centroid.latDeg + ' ' + sol.centroid.latMin + "'" : 'N/A'}</span></div>
            <div class="field"><span class="label">Lon W:</span> <span class="value">${sol.centroid ? sol.centroid.lonDeg + ' ' + sol.centroid.lonMin + "'" : 'N/A'}</span></div>
          </div>
          <div style="font-size:9pt;margin-top:4px">
            <span class="label">DD:</span> <span style="font-family:monospace">${sol.centroid ? sol.centroid.lat.toFixed(5) + ', -' + sol.centroid.lon.toFixed(5) : 'N/A'}</span>
          </div>
        </div>
        <div>
          <div style="background:#fff;padding:10px;border-radius:4px;margin-bottom:8px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
              <span style="font-size:9px;color:#666;text-transform:uppercase">Quality Score</span>
              <span style="font-weight:bold;color:${sol.qualityScore >= 70 ? '#38a169' : sol.qualityScore >= 40 ? '#d69e2e' : '#e53e3e'}">${sol.qualityLabel || 'Unknown'} (${sol.qualityScore || 0}%)</span>
            </div>
            <div style="height:6px;background:#e2e8f0;border-radius:3px;overflow:hidden">
              <div style="height:100%;width:${sol.qualityScore || 0}%;background:${sol.qualityScore >= 70 ? '#38a169' : sol.qualityScore >= 40 ? '#d69e2e' : '#e53e3e'}"></div>
            </div>
          </div>
          <div class="grid grid-2" style="font-size:8pt">
            <div class="field"><span class="label">Observations:</span> <span class="value">${sol.obsCount || 0}</span></div>
            <div class="field"><span class="label">DF Bearings:</span> <span class="value">${sol.dfCount || 0}</span></div>
            <div class="field"><span class="label">Search Radius:</span> <span class="value">${sol.searchRadiusNm || 'N/A'} nm</span></div>
            <div class="field"><span class="label">Uncertainty:</span> <span class="value">${sol.uncertaintyPct || 'N/A'}%</span></div>
            <div class="field"><span class="label">50% Area:</span> <span class="value">${sol.area50SizeNm2 || 'N/A'} nm</span></div>
            <div class="field"><span class="label">90% Area:</span> <span class="value">${sol.area90SizeNm2 || 'N/A'} nm</span></div>
          </div>
          ${sol.sourceBreakdown ? `
          <div style="font-size:8pt;margin-top:6px;padding:6px;background:#f7fafc;border-radius:4px">
            <span class="label">Sources:</span>
            ${sol.sourceBreakdown.audio ? '<span style="margin-left:6px">Audio: ' + sol.sourceBreakdown.audio + '</span>' : ''}
            ${sol.sourceBreakdown.df ? '<span style="margin-left:6px">DF: ' + sol.sourceBreakdown.df + '</span>' : ''}
            ${sol.sourceBreakdown.sarsat ? '<span style="margin-left:6px">SARSAT: ' + sol.sourceBreakdown.sarsat + '</span>' : ''}
            ${sol.sourceBreakdown.visual ? '<span style="margin-left:6px">Visual: ' + sol.sourceBreakdown.visual + '</span>' : ''}
            ${sol.sourceBreakdown.adsb ? '<span style="margin-left:6px">ADS-B: ' + sol.sourceBreakdown.adsb + '</span>' : ''}
          </div>` : ''}
        </div>
      </div>
      ${sol.adsbData ? `
      <div style="margin-top:8px;padding:8px;background:#e6fffa;border-radius:4px;font-size:8pt;border:1px solid #81e6d9">
        <span style="font-weight:bold;color:#234e52">ADS-B Constraint:</span>
        Aircraft: ${escHtml(sol.adsbData.aircraftId || 'Unknown')} |
        Last Position: ${sol.adsbData.lastLat ? sol.adsbData.lastLat.toFixed(4) + ', ' + sol.adsbData.lastLon.toFixed(4) : 'N/A'} |
        Alt: ${sol.adsbData.lastAlt || 'N/A'} ft |
        Hdg: ${sol.adsbData.lastHdg || 'N/A'} |
        Max Range: ${sol.adsbData.maxRangeNm ? sol.adsbData.maxRangeNm.toFixed(1) + ' nm' : 'N/A'}
      </div>` : ''}
    </div>`).join('')}
  </div>` : ''}
  ${eltSolutions && eltSolutions.length > 0 && eltSolutions[0].observations ? `
  <div style="margin-bottom:15px">
    <div style="font-weight:bold;font-size:10pt;margin-bottom:8px;color:#1a365d">Solution Diagrams</div>
    <div style="display:flex;gap:15px;flex-wrap:wrap">
      <!-- Overview Diagram - All Observation Points -->
      <div style="flex:1;min-width:280px;background:#fff;border:1px solid #ccc;border-radius:8px;padding:10px;text-align:center">
        <div style="font-weight:bold;font-size:9pt;color:#1a365d;margin-bottom:8px">Overview - All Observations</div>
        ${(() => {
          const sol = eltSolutions[0];
          if (!sol.observations || sol.observations.length === 0) return '<p style="color:#666;font-style:italic">No observation data</p>';
          
          const obs = sol.observations;
          const centerLat = sol.centroid.lat;
          const centerLon = sol.centroid.lon;
          
          // Find bounds including all observations
          let minLat = centerLat, maxLat = centerLat, minLon = centerLon, maxLon = centerLon;
          obs.forEach(o => {
            if (o.lat < minLat) minLat = o.lat;
            if (o.lat > maxLat) maxLat = o.lat;
            if (o.lon < minLon) minLon = o.lon;
            if (o.lon > maxLon) maxLon = o.lon;
          });
          
          const latPad = Math.max((maxLat - minLat) * 0.15, 0.005);
          const lonPad = Math.max((maxLon - minLon) * 0.15, 0.005);
          minLat -= latPad; maxLat += latPad;
          minLon -= lonPad; maxLon += lonPad;
          
          const width = 280, height = 220;
          const scaleX = width / (maxLon - minLon);
          const scaleY = height / (maxLat - minLat);
          const scale = Math.min(scaleX, scaleY) * 0.85;
          
          const toX = (lon) => (lon - minLon) * scale + (width - (maxLon - minLon) * scale) / 2;
          const toY = (lat) => height - ((lat - minLat) * scale + (height - (maxLat - minLat) * scale) / 2);
          
          const cx = toX(centerLon);
          const cy = toY(centerLat);
          
          let svg = '<svg width="' + width + '" height="' + height + '" style="background:#f7fafc;border-radius:4px">';
          svg += '<defs><pattern id="gridOv" width="30" height="30" patternUnits="userSpaceOnUse"><path d="M 30 0 L 0 0 0 30" fill="none" stroke="#e2e8f0" stroke-width="1"/></pattern></defs>';
          svg += '<rect width="100%" height="100%" fill="url(#gridOv)"/>';
          
          // Uncertainty circle (search radius)
          const uncertRadius = (sol.searchRadiusNm || 2) * scale * 60;
          svg += '<circle cx="' + cx + '" cy="' + cy + '" r="' + Math.min(uncertRadius, 80) + '" fill="rgba(237,137,54,0.15)" stroke="#ed8936" stroke-width="2" stroke-dasharray="6,3"/>';
          
          // Draw observation points
          obs.forEach((o, i) => {
            const ox = toX(o.lon);
            const oy = toY(o.lat);
            
            // DF bearing line
            if (o.bearing !== undefined && o.bearing !== null) {
              const bearing = parseFloat(o.bearing);
              const rad = (90 - bearing) * Math.PI / 180;
              const lineLen = 100;
              const ex = ox + Math.cos(rad) * lineLen;
              const ey = oy - Math.sin(rad) * lineLen;
              svg += '<line x1="' + ox + '" y1="' + oy + '" x2="' + ex + '" y2="' + ey + '" stroke="#805ad5" stroke-width="1.5" opacity="0.6"/>';
            }
            
            svg += '<circle cx="' + ox + '" cy="' + oy + '" r="6" fill="#3182ce" stroke="#fff" stroke-width="1.5"/>';
            svg += '<text x="' + (ox + 9) + '" y="' + (oy + 3) + '" font-size="8" fill="#2d3748">' + (i + 1) + '</text>';
          });
          
          // Center point
          svg += '<circle cx="' + cx + '" cy="' + cy + '" r="8" fill="#cc0000" stroke="#fff" stroke-width="2"/>';
          
          // Scale indicator
          const nmPerDegLon = 60 * Math.cos(centerLat * Math.PI / 180);
          const oneNmPx = scale / nmPerDegLon;
          if (oneNmPx > 10 && oneNmPx < 100) {
            svg += '<line x1="' + (width - 60) + '" y1="' + (height - 15) + '" x2="' + (width - 60 + oneNmPx) + '" y2="' + (height - 15) + '" stroke="#333" stroke-width="2"/>';
            svg += '<text x="' + (width - 60 + oneNmPx/2) + '" y="' + (height - 20) + '" font-size="8" fill="#333" text-anchor="middle">1 nm</text>';
          }
          
          svg += '</svg>';
          return svg;
        })()}
        <div style="font-size:7pt;color:#666;margin-top:4px">All observation points and solution centroid</div>
      </div>
      
      <!-- Zoomed Diagram - 90% Probability Area -->
      <div style="flex:1;min-width:280px;background:#fff;border:1px solid #ccc;border-radius:8px;padding:10px;text-align:center">
        <div style="font-weight:bold;font-size:9pt;color:#1a365d;margin-bottom:8px">Detail - Probability Areas</div>
        ${(() => {
          const sol = eltSolutions[0];
          if (!sol.centroid) return '<p style="color:#666;font-style:italic">No solution data</p>';
          
          const obs = sol.observations || [];
          const centerLat = sol.centroid.lat;
          const centerLon = sol.centroid.lon;
          
          // Zoom to show ~2x the 90% search radius
          const searchRadiusNm = parseFloat(sol.searchRadiusNm) || 2;
          const area90Nm2 = parseFloat(sol.area90SizeNm2) || (searchRadiusNm * searchRadiusNm * Math.PI * 2);
          const radius90Nm = Math.sqrt(area90Nm2 / Math.PI);
          const area50Nm2 = parseFloat(sol.area50SizeNm2) || (area90Nm2 * 0.5);
          const radius50Nm = Math.sqrt(area50Nm2 / Math.PI);
          
          // Set bounds to 2.5x the 90% radius
          const viewRadiusNm = Math.max(radius90Nm * 2.5, 1);
          const nmPerDegLat = 60;
          const nmPerDegLon = 60 * Math.cos(centerLat * Math.PI / 180);
          
          const latSpan = viewRadiusNm / nmPerDegLat;
          const lonSpan = viewRadiusNm / nmPerDegLon;
          
          const minLat = centerLat - latSpan;
          const maxLat = centerLat + latSpan;
          const minLon = centerLon - lonSpan;
          const maxLon = centerLon + lonSpan;
          
          const width = 280, height = 220;
          const scaleX = width / (maxLon - minLon);
          const scaleY = height / (maxLat - minLat);
          const scale = Math.min(scaleX, scaleY) * 0.9;
          
          const toX = (lon) => (lon - minLon) * scale + (width - (maxLon - minLon) * scale) / 2;
          const toY = (lat) => height - ((lat - minLat) * scale + (height - (maxLat - minLat) * scale) / 2);
          
          const cx = toX(centerLon);
          const cy = toY(centerLat);
          
          // Convert radius from nm to pixels
          const radius90Px = radius90Nm * nmPerDegLon * scale / 60;
          const radius50Px = radius50Nm * nmPerDegLon * scale / 60;
          
          let svg = '<svg width="' + width + '" height="' + height + '" style="background:#f7fafc;border-radius:4px">';
          svg += '<defs><pattern id="gridZm" width="20" height="20" patternUnits="userSpaceOnUse"><path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e2e8f0" stroke-width="1"/></pattern></defs>';
          svg += '<rect width="100%" height="100%" fill="url(#gridZm)"/>';
          
          // 90% probability area (outer, lighter)
          svg += '<circle cx="' + cx + '" cy="' + cy + '" r="' + radius90Px + '" fill="rgba(237,137,54,0.12)" stroke="#ed8936" stroke-width="2" stroke-dasharray="8,4"/>';
          
          // 50% probability area (inner, darker)
          svg += '<circle cx="' + cx + '" cy="' + cy + '" r="' + radius50Px + '" fill="rgba(56,161,105,0.2)" stroke="#38a169" stroke-width="2"/>';
          
          // Draw observation points and DF bearing lines
          obs.forEach((o, i) => {
            if (!o.lat || !o.lon) return;
            const ox = toX(o.lon);
            const oy = toY(o.lat);
            
            // Only draw if within or near the view bounds
            if (ox >= -50 && ox <= width + 50 && oy >= -50 && oy <= height + 50) {
              // DF bearing line - extend through the solution area
              if (o.bearing !== undefined && o.bearing !== null) {
                const bearing = parseFloat(o.bearing);
                const rad = (90 - bearing) * Math.PI / 180;
                // Extend line in both directions
                const lineLen = 300;
                const sx = ox - Math.cos(rad) * 50;
                const sy = oy + Math.sin(rad) * 50;
                const ex = ox + Math.cos(rad) * lineLen;
                const ey = oy - Math.sin(rad) * lineLen;
                svg += '<line x1="' + sx + '" y1="' + sy + '" x2="' + ex + '" y2="' + ey + '" stroke="#805ad5" stroke-width="1.5" opacity="0.5"/>';
              }
              
              // Observation point
              svg += '<circle cx="' + ox + '" cy="' + oy + '" r="5" fill="#3182ce" stroke="#fff" stroke-width="1.5"/>';
              svg += '<text x="' + (ox + 7) + '" y="' + (oy + 3) + '" font-size="7" fill="#2d3748" font-weight="bold">' + (i + 1) + '</text>';
            }
          });
          
          // Center crosshairs
          svg += '<line x1="' + (cx - 15) + '" y1="' + cy + '" x2="' + (cx + 15) + '" y2="' + cy + '" stroke="#cc0000" stroke-width="1.5"/>';
          svg += '<line x1="' + cx + '" y1="' + (cy - 15) + '" x2="' + cx + '" y2="' + (cy + 15) + '" stroke="#cc0000" stroke-width="1.5"/>';
          
          // Center point
          svg += '<circle cx="' + cx + '" cy="' + cy + '" r="6" fill="#cc0000" stroke="#fff" stroke-width="2"/>';
          
          // Labels for probability areas
          svg += '<text x="' + cx + '" y="' + (cy - radius50Px - 6) + '" font-size="7" fill="#38a169" text-anchor="middle" font-weight="bold">50% (' + radius50Nm.toFixed(1) + ' nm)</text>';
          svg += '<text x="' + cx + '" y="' + (cy - radius90Px - 6) + '" font-size="7" fill="#ed8936" text-anchor="middle" font-weight="bold">90% (' + radius90Nm.toFixed(1) + ' nm)</text>';
          
          // Coordinates label
          svg += '<text x="' + cx + '" y="' + (cy + 22) + '" font-size="6" fill="#666" text-anchor="middle">' + centerLat.toFixed(4) + 'N, ' + centerLon.toFixed(4) + 'W</text>';
          
          // Scale bar
          const oneNmPx = scale * nmPerDegLon / 60;
          if (oneNmPx > 15) {
            svg += '<line x1="15" y1="' + (height - 12) + '" x2="' + (15 + oneNmPx) + '" y2="' + (height - 12) + '" stroke="#333" stroke-width="2"/>';
            svg += '<text x="' + (15 + oneNmPx/2) + '" y="' + (height - 16) + '" font-size="7" fill="#333" text-anchor="middle">1 nm</text>';
          }
          
          // Legend
          svg += '<rect x="' + (width - 90) + '" y="5" width="82" height="52" fill="rgba(255,255,255,0.9)" stroke="#ccc" rx="3"/>';
          svg += '<circle cx="' + (width - 80) + '" cy="14" r="3" fill="rgba(56,161,105,0.5)" stroke="#38a169"/>';
          svg += '<text x="' + (width - 74) + '" y="17" font-size="6" fill="#333">50% probability</text>';
          svg += '<circle cx="' + (width - 80) + '" cy="26" r="3" fill="rgba(237,137,54,0.3)" stroke="#ed8936" stroke-dasharray="2,1"/>';
          svg += '<text x="' + (width - 74) + '" y="29" font-size="6" fill="#333">90% probability</text>';
          svg += '<circle cx="' + (width - 80) + '" cy="38" r="3" fill="#3182ce"/>';
          svg += '<text x="' + (width - 74) + '" y="41" font-size="6" fill="#333">Observation</text>';
          svg += '<line x1="' + (width - 83) + '" y1="50" x2="' + (width - 77) + '" y2="50" stroke="#805ad5" stroke-width="2"/>';
          svg += '<text x="' + (width - 74) + '" y="53" font-size="6" fill="#333">DF Bearing</text>';
          
          svg += '</svg>';
          return svg;
        })()}
        <div style="font-size:7pt;color:#666;margin-top:4px">Zoomed view with observation points and DF bearings</div>
      </div>
    </div>
  </div>` : ''}
  ${eltObservations && eltObservations.length > 0 ? `
  <div>
    <div style="font-weight:bold;font-size:10pt;margin-bottom:8px;color:#1a365d">Observations (${eltObservations.length})</div>
    <table style="font-size:8pt">
      <tr>
        <th style="width:25px">#</th>
        <th style="width:60px">Time</th>
        <th style="width:50px">Source</th>
        <th style="width:75px">Lat N</th>
        <th style="width:75px">Lon W</th>
        <th style="width:40px">Alt</th>
        <th style="width:35px">Str</th>
        <th style="width:50px">Range</th>
        <th style="width:45px">DF Brg</th>
        <th style="width:35px">Used</th>
        <th>Notes</th>
      </tr>
      ${eltObservations.map((obs, idx) => `
      <tr style="background:${obs.useInCalc ? '#fff' : '#f0f0f0'}">
        <td style="text-align:center">${obs.obsNum || idx + 1}</td>
        <td>${escHtml(obs.timeZ || '')}</td>
        <td>${escHtml(obs.source || '')}</td>
        <td>${obs.latDeg ? obs.latDeg + ' ' + obs.latMin + "'" : ''}</td>
        <td>${obs.lonDeg ? obs.lonDeg + ' ' + obs.lonMin + "'" : ''}</td>
        <td>${escHtml(obs.altMSL || obs.altAGL || '')}</td>
        <td style="text-align:center">${obs.strength || ''}</td>
        <td>${obs.directRange ? obs.directRange + ' nm' : ''}${obs.rangeAccuracy ? ' ' + obs.rangeAccuracy : ''}</td>
        <td>${obs.dfBearing ? obs.dfBearing + '' + (obs.bearingRef || '') : ''}</td>
        <td style="text-align:center;color:${obs.useInCalc ? '#38a169' : '#e53e3e'}">${obs.useInCalc ? '\u2714' : '\u2717'}</td>
        <td style="font-size:7pt;max-width:120px;overflow:hidden;text-overflow:ellipsis">${escHtml(obs.notes || '')}</td>
      </tr>`).join('')}
    </table>
  </div>` : ''}
  <div style="margin-top:10px;padding:8px;background:#fffbeb;border-radius:4px;font-size:8pt;border:1px solid #f6e05e">
    <span style="font-weight:bold;color:#744210"> Calculation Assumptions:</span>
    <span style="margin-left:8px">R = ${eltSettings?.r10 || 0.5} nm</span> |
    <span style="margin-left:4px">K = ${eltSettings?.k || 2}</span> |
    <span style="margin-left:4px"> = ${eltSettings?.sigmaTheta || 20}</span> |
    <span style="margin-left:4px">Resolution = ${eltSettings?.resolution || 0.25} nm</span> |
    <span style="margin-left:4px">Confidence = ${eltSettings?.confidenceMode || 'auto'}</span>
    <div style="margin-top:4px;color:#92400e;font-style:italic">
      Note: ELT positions are mathematically derived estimates. Field verification required. Signal strength-to-range conversion uses exponential decay model.
    </div>
  </div>
</div>` : ''}
${spState.lastPlan ? `
<div class="section" style="page-break-inside: avoid;">
  <div class="section-title"> Search Pattern Planner</div>
  <div class="two-column">
    <div>
      <div style="background:#f0f4f8;padding:12px;border-radius:6px;margin-bottom:10px;border:2px solid #805ad5">
        <div style="font-size:10px;color:#666;text-transform:uppercase;letter-spacing:1px">Pattern Type</div>
        <div style="font-size:16px;font-weight:bold;color:#1a365d">${escHtml(spState.lastPlan.patternType)}</div>
        ${spState.lastPlan.gridInfo?.gridId ? `<div style="font-size:14px;font-weight:bold;color:#805ad5;margin-top:4px">${escHtml(spState.lastPlan.gridInfo.gridId)}</div>` : ''}
      </div>
      <div class="grid grid-2">
        <div class="field"><span class="label">Generated:</span> <span class="value">${spState.lastPlan.generatedAtZ || ''} Z</span></div>
        <div class="field"><span class="label">Date:</span> <span class="value">${spState.lastPlan.generatedDateZ || ''}</span></div>
      </div>
      <div style="margin-top:8px">
        <div class="field"><span class="label">POI Lat:</span> <span class="value">${spState.lastPlan.poi?.latDD ? spState.lastPlan.poi.latDD.toFixed(6) + 'N' : ''}</span></div>
        <div class="field"><span class="label">POI Lon:</span> <span class="value">${spState.lastPlan.poi?.lonDD ? Math.abs(spState.lastPlan.poi.lonDD).toFixed(6) + 'W' : ''}</span></div>
        ${spState.lastPlan.poi?.fromGrid ? `<div class="field"><span class="label">From Grid:</span> <span class="value">${escHtml(spState.lastPlan.poi.fromGrid)}</span></div>` : ''}
      </div>
    </div>
    <div>
      <div style="background:#f0fff4;padding:10px;border-radius:6px;margin-bottom:10px;border:1px solid #68d391">
        <div style="font-size:10px;color:#666;text-transform:uppercase;margin-bottom:6px">Summary</div>
        <div class="grid grid-2" style="font-size:9pt">
          <div class="field"><span class="label">Tracks:</span> <span class="value">${spState.lastPlan.summary?.numTracks || spState.lastPlan.summary?.numLegs || ''}</span></div>
          <div class="field"><span class="label">Spacing:</span> <span class="value">${spState.lastPlan.summary?.spacing || ''} NM</span></div>
          <div class="field"><span class="label">Total Dist:</span> <span class="value">${spState.lastPlan.summary?.totalDistance?.toFixed(1) || ''} NM</span></div>
          <div class="field"><span class="label">Est. Time:</span> <span class="value">${spState.lastPlan.summary?.timeMinutes?.toFixed(0) || ''} min</span></div>
          ${spState.lastPlan.summary?.entryCorner ? `<div class="field"><span class="label">Entry:</span> <span class="value">${spState.lastPlan.summary.entryCorner}</span></div>` : ''}
          ${spState.lastPlan.coverage?.efficiency !== undefined ? `<div class="field"><span class="label">Efficiency:</span> <span class="value">${spState.lastPlan.coverage.efficiency.toFixed(1)}%</span></div>` : ''}
        </div>
      </div>
      ${spState.lastPlan.gridInfo ? `
      <div style="font-size:8pt;color:#666">
        <div><strong>Grid:</strong> ${escHtml(spState.lastPlan.gridInfo.gridId || '')}</div>
        <div><strong>Quarter:</strong> ${escHtml(spState.lastPlan.gridInfo.quarterGrid || '')} | <strong>Mag Var:</strong> ${spState.lastPlan.gridInfo.magVariation || ''}${(spState.lastPlan.gridInfo.magVariation || 0) >= 0 ? 'E' : 'W'}</div>
        ${spState.lastPlan.dimensions ? `<div><strong>Size:</strong> ${spState.lastPlan.dimensions.actualWidth?.toFixed(2) || ''}  ${spState.lastPlan.dimensions.actualHeight?.toFixed(2) || ''} NM</div>` : ''}
      </div>` : ''}
    </div>
  </div>
  
  ${spState.lastPlan.waypoints && spState.lastPlan.waypoints.length > 0 ? `
  <div style="margin-top:10px">
    <div style="font-weight:bold;font-size:9pt;margin-bottom:6px">Flight Path Diagram:</div>
    <div style="display:flex;gap:15px;align-items:flex-start">
      <div style="background:#fff;border:1px solid #ccc;border-radius:8px;padding:10px;flex:0 0 400px">
        ${(() => {
          const wps = spState.lastPlan.waypoints;
          const corners = spState.lastPlan.gridInfo?.corners;
          
          // Get all points including waypoints
          const allLats = wps.map(w => w.lat);
          const allLons = wps.map(w => w.lon);
          
          // Include grid corners if available
          if (corners) {
            allLats.push(corners.nw.lat, corners.sw.lat);
            allLons.push(corners.nw.lon, corners.ne.lon);
          }
          
          let minLat = Math.min(...allLats);
          let maxLat = Math.max(...allLats);
          let minLon = Math.min(...allLons);
          let maxLon = Math.max(...allLons);
          
          const latPad = Math.max((maxLat - minLat) * 0.1, 0.01);
          const lonPad = Math.max((maxLon - minLon) * 0.1, 0.01);
          minLat -= latPad; maxLat += latPad;
          minLon -= lonPad; maxLon += lonPad;
          
          const width = 380, height = 280;
          const scaleX = width / (maxLon - minLon);
          const scaleY = height / (maxLat - minLat);
          
          const toX = (lon) => (lon - minLon) * scaleX;
          const toY = (lat) => height - (lat - minLat) * scaleY;
          
          let svg = '<svg width="' + width + '" height="' + height + '" xmlns="http://www.w3.org/2000/svg">';
          
          // Background
          svg += '<rect width="100%" height="100%" fill="#f8fafc"/>';
          
          // Grid pattern
          svg += '<defs><pattern id="spGrid" width="20" height="20" patternUnits="userSpaceOnUse">';
          svg += '<path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e2e8f0" stroke-width="0.5"/>';
          svg += '</pattern></defs>';
          svg += '<rect width="100%" height="100%" fill="url(#spGrid)"/>';
          
          // Draw quarter grid boundary if available
          if (corners) {
            const nwX = toX(corners.nw.lon), nwY = toY(corners.nw.lat);
            const neX = toX(corners.ne.lon), neY = toY(corners.ne.lat);
            const swX = toX(corners.sw.lon), swY = toY(corners.sw.lat);
            const seX = toX(corners.se.lon), seY = toY(corners.se.lat);
            svg += '<polygon points="' + nwX + ',' + nwY + ' ' + neX + ',' + neY + ' ' + seX + ',' + seY + ' ' + swX + ',' + swY + '" fill="rgba(128,90,213,0.1)" stroke="#805ad5" stroke-width="2" stroke-dasharray="5,3"/>';
          }
          
          // Draw flight path
          if (wps.length >= 2) {
            let pathD = 'M ' + toX(wps[0].lon) + ' ' + toY(wps[0].lat);
            for (let i = 1; i < wps.length; i++) {
              pathD += ' L ' + toX(wps[i].lon) + ' ' + toY(wps[i].lat);
            }
            svg += '<path d="' + pathD + '" fill="none" stroke="#3182ce" stroke-width="2"/>';
          }
          
          // Draw waypoints
          wps.forEach((w, i) => {
            const x = toX(w.lon), y = toY(w.lat);
            const isStart = i === 0;
            const isEnd = i === wps.length - 1;
            svg += '<circle cx="' + x + '" cy="' + y + '" r="' + (isStart || isEnd ? 5 : 3) + '" fill="' + (isStart ? '#38a169' : isEnd ? '#e53e3e' : '#3182ce') + '"/>';
          });
          
          // Start/End labels
          if (wps.length >= 1) {
            svg += '<text x="' + (toX(wps[0].lon) + 8) + '" y="' + (toY(wps[0].lat) + 4) + '" font-size="10" fill="#38a169" font-weight="bold">START</text>';
          }
          if (wps.length >= 2) {
            svg += '<text x="' + (toX(wps[wps.length-1].lon) + 8) + '" y="' + (toY(wps[wps.length-1].lat) + 4) + '" font-size="10" fill="#e53e3e" font-weight="bold">END</text>';
          }
          
          // North arrow
          svg += '<g transform="translate(20,25)">';
          svg += '<polygon points="0,-15 5,0 -5,0" fill="#1a365d"/>';
          svg += '<text x="0" y="12" text-anchor="middle" font-size="10" font-weight="bold" fill="#1a365d">N</text>';
          svg += '</g>';
          
          // Legend
          svg += '<g transform="translate(' + (width - 100) + ',' + (height - 40) + ')">';
          svg += '<rect x="0" y="0" width="95" height="35" fill="rgba(255,255,255,0.9)" stroke="#ccc" rx="3"/>';
          svg += '<circle cx="10" cy="10" r="4" fill="#38a169"/><text x="18" y="13" font-size="8">Start</text>';
          svg += '<circle cx="55" cy="10" r="4" fill="#e53e3e"/><text x="63" y="13" font-size="8">End</text>';
          svg += '<line x1="5" y1="25" x2="25" y2="25" stroke="#3182ce" stroke-width="2"/><text x="30" y="28" font-size="8">Track</text>';
          svg += '</g>';
          
          svg += '</svg>';
          return svg;
        })()}
      </div>
      <div style="flex:1;font-size:8pt">
        <div style="font-weight:bold;margin-bottom:4px">ForeFlight Route String:</div>
        <div style="background:#f7fafc;padding:6px;border-radius:4px;font-family:monospace;font-size:7pt;word-break:break-all;max-height:80px;overflow:auto;border:1px solid #e2e8f0">
          ${spState.lastPlan.waypoints.map(w => w.foreflight).join(' ')}
        </div>
      </div>
    </div>
  </div>
  
  <div style="margin-top:10px">
    <div style="font-weight:bold;font-size:9pt;margin-bottom:6px">Waypoint Table:</div>
    <table style="font-size:8pt">
      <thead>
        <tr style="background:#e2e8f0">
          <th style="width:35px">WP</th>
          <th>Coordinates (DDM)</th>
          <th>ForeFlight</th>
          <th style="width:40px">Hdg</th>
          <th style="width:50px">Leg NM</th>
          <th>Note</th>
        </tr>
      </thead>
      <tbody>
        ${spState.lastPlan.waypoints.slice(0, 30).map((w, i) => `
        <tr>
          <td style="text-align:center;font-weight:bold">WP${String(i).padStart(2,'0')}</td>
          <td style="font-family:monospace">${escHtml(w.ddm || '')}</td>
          <td style="font-family:monospace;font-size:7pt">${escHtml(w.foreflight || '')}</td>
          <td style="text-align:center">${w.heading !== null && w.heading !== undefined ? w.heading + '' : '-'}</td>
          <td style="text-align:center">${w.legLength ? w.legLength.toFixed(2) : '-'}</td>
          <td style="font-size:7pt">${escHtml(w.note || '')}</td>
        </tr>`).join('')}
        ${spState.lastPlan.waypoints.length > 30 ? '<tr><td colspan="6" style="text-align:center;font-style:italic">... and ' + (spState.lastPlan.waypoints.length - 30) + ' more waypoints</td></tr>' : ''}
      </tbody>
    </table>
  </div>` : ''}
</div>` : ''}
${cmdState.selectedGrids && cmdState.selectedGrids.length > 0 && cmdState.analysisTimestamp ? `
<div class="section" style="page-break-inside: avoid;">
  <div class="section-title"> Coverage Analysis</div>
  <div class="two-column">
    <div>
      <div style="background:#f0f4f8;padding:12px;border-radius:6px;margin-bottom:10px;border:2px solid #805ad5">
        <div style="font-size:10px;color:#666;text-transform:uppercase;letter-spacing:1px">Analysis Summary</div>
        <div style="font-size:14px;font-weight:bold;color:#1a365d;margin-top:4px">${cmdState.selectedGrids.length} Grid${cmdState.selectedGrids.length > 1 ? 's' : ''} Analyzed</div>
        <div style="font-size:12px;color:#4a5568;margin-top:2px">${cmdState.flights.length} Aircraft Track${cmdState.flights.length > 1 ? 's' : ''}</div>
      </div>
      <div class="grid grid-2">
        <div class="field"><span class="label">Analyzed:</span> <span class="value">${cmdState.analysisTimeZ || ''} Z</span></div>
        <div class="field"><span class="label">Date:</span> <span class="value">${cmdState.analysisDateZ || ''}</span></div>
        <div class="field"><span class="label">Coverage Width:</span> <span class="value">${cmdState.coverageWidth || 0.5} NM</span></div>
        <div class="field"><span class="label">Track Points:</span> <span class="value">${(cmdState.totalFlightPoints || 0).toLocaleString()}</span></div>
      </div>
    </div>
    <div>
      <div style="font-size:10px;color:#666;text-transform:uppercase;margin-bottom:6px">Average Coverage</div>
      <div style="font-size:36px;font-weight:bold;color:${(() => {
        const avg = cmdState.selectedGrids.length > 0 
          ? Math.round(cmdState.selectedGrids.reduce((sum, g) => sum + (g.coverage?.total || 0), 0) / cmdState.selectedGrids.length)
          : 0;
        return avg >= 80 ? '#38a169' : avg >= 50 ? '#d69e2e' : '#e53e3e';
      })()}">${cmdState.selectedGrids.length > 0 
        ? Math.round(cmdState.selectedGrids.reduce((sum, g) => sum + (g.coverage?.total || 0), 0) / cmdState.selectedGrids.length)
        : 0}%</div>
      <div style="height:10px;background:#e2e8f0;border-radius:5px;margin-top:6px;overflow:hidden">
        <div style="height:100%;width:${cmdState.selectedGrids.length > 0 
          ? Math.round(cmdState.selectedGrids.reduce((sum, g) => sum + (g.coverage?.total || 0), 0) / cmdState.selectedGrids.length)
          : 0}%;background:${(() => {
            const avg = cmdState.selectedGrids.length > 0 
              ? Math.round(cmdState.selectedGrids.reduce((sum, g) => sum + (g.coverage?.total || 0), 0) / cmdState.selectedGrids.length)
              : 0;
            return avg >= 80 ? '#38a169' : avg >= 50 ? '#d69e2e' : '#e53e3e';
          })()}"></div>
      </div>
    </div>
  </div>
  
  <div style="margin-top:15px">
    <div style="font-weight:bold;font-size:10pt;margin-bottom:8px">Grid Coverage Map:</div>
    <div style="display:flex;gap:15px;align-items:flex-start">
      <div style="background:#fff;border:1px solid #ccc;border-radius:8px;padding:10px;flex:0 0 450px">
        ${(() => {
          const grids = cmdState.selectedGrids;
          if (!grids || grids.length === 0) return '<div style="color:#666;text-align:center">No grids to display</div>';
          
          // Calculate bounds from GRIDS ONLY - tight zoom on search area
          let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
          grids.forEach(g => {
            const c = g.corners;
            if (c) {
              minLat = Math.min(minLat, c.sw.lat, c.se.lat);
              maxLat = Math.max(maxLat, c.nw.lat, c.ne.lat);
              minLon = Math.min(minLon, c.nw.lon, c.sw.lon);
              maxLon = Math.max(maxLon, c.ne.lon, c.se.lon);
            }
          });
          
          // Small padding - keep tight on grids
          const latPad = (maxLat - minLat) * 0.05;
          const lonPad = (maxLon - minLon) * 0.05;
          minLat -= latPad; maxLat += latPad;
          minLon -= lonPad; maxLon += lonPad;
          
          const width = 550, height = 420;
          const scaleX = width / (maxLon - minLon);
          const scaleY = height / (maxLat - minLat);
          
          const toX = (lon) => (lon - minLon) * scaleX;
          const toY = (lat) => height - (lat - minLat) * scaleY;
          
          // Get flights for drawing
          const flights = cmdState.flights || [];
          
          let svg = '<svg width="' + width + '" height="' + height + '" xmlns="http://www.w3.org/2000/svg">';
          svg += '<rect width="100%" height="100%" fill="#e8f0e0"/>';
          
          // Draw each grid boundary (magenta dashed like the screenshot)
          grids.forEach((g, gIdx) => {
            const c = g.corners;
            if (!c) return;
            
            const nwX = toX(c.nw.lon), nwY = toY(c.nw.lat);
            const neX = toX(c.ne.lon), neY = toY(c.ne.lat);
            const swX = toX(c.sw.lon), swY = toY(c.sw.lat);
            const seX = toX(c.se.lon), seY = toY(c.se.lat);
            
            // Grid boundary - magenta dashed line with light fill
            svg += '<polygon points="' + nwX + ',' + nwY + ' ' + neX + ',' + neY + ' ' + seX + ',' + seY + ' ' + swX + ',' + swY + '" fill="rgba(255,245,245,0.4)" stroke="#ff00ff" stroke-width="3" stroke-dasharray="8,4"/>';
            
            // Draw quadrant subdivision lines (A/B/C/D) - thin magenta lines
            const midLat = (c.nw.lat + c.sw.lat) / 2;
            const midLon = (c.nw.lon + c.ne.lon) / 2;
            const midX = toX(midLon);
            const midY = toY(midLat);
            
            // Vertical line (separates A/C from B/D)
            svg += '<line x1="' + midX + '" y1="' + nwY + '" x2="' + midX + '" y2="' + swY + '" stroke="#ff00ff" stroke-width="1" stroke-dasharray="4,3" opacity="0.7"/>';
            // Horizontal line (separates A/B from C/D)
            svg += '<line x1="' + nwX + '" y1="' + midY + '" x2="' + neX + '" y2="' + midY + '" stroke="#ff00ff" stroke-width="1" stroke-dasharray="4,3" opacity="0.7"/>';
            
            // Draw 1/8 grid lines (sub-quadrant divisions) - only if enabled for this grid
            if (g.showEighthGrids) {
              // These divide each quadrant in half both horizontally and vertically
              const q1Lat = (c.nw.lat + midLat) / 2; // Between north edge and horizontal midline
              const q3Lat = (midLat + c.sw.lat) / 2; // Between horizontal midline and south edge
              const q1Lon = (c.nw.lon + midLon) / 2; // Between west edge and vertical midline
              const q3Lon = (midLon + c.ne.lon) / 2; // Between vertical midline and east edge
              
              const q1Y = toY(q1Lat);
              const q3Y = toY(q3Lat);
              const q1X = toX(q1Lon);
              const q3X = toX(q3Lon);
              
              // Horizontal eighth-grid lines
              svg += '<line x1="' + nwX + '" y1="' + q1Y + '" x2="' + neX + '" y2="' + q1Y + '" stroke="#ff00ff" stroke-width="0.5" stroke-dasharray="2,2" opacity="0.5"/>';
              svg += '<line x1="' + nwX + '" y1="' + q3Y + '" x2="' + neX + '" y2="' + q3Y + '" stroke="#ff00ff" stroke-width="0.5" stroke-dasharray="2,2" opacity="0.5"/>';
              // Vertical eighth-grid lines
              svg += '<line x1="' + q1X + '" y1="' + nwY + '" x2="' + q1X + '" y2="' + swY + '" stroke="#ff00ff" stroke-width="0.5" stroke-dasharray="2,2" opacity="0.5"/>';
              svg += '<line x1="' + q3X + '" y1="' + nwY + '" x2="' + q3X + '" y2="' + swY + '" stroke="#ff00ff" stroke-width="0.5" stroke-dasharray="2,2" opacity="0.5"/>';
            }
            
            // Quadrant labels (small, in corners)
            const qLabelSize = 9;
            const qPad = 8;
            svg += '<text x="' + (nwX + qPad) + '" y="' + (nwY + qPad + qLabelSize) + '" font-size="' + qLabelSize + '" fill="#cc00cc" opacity="0.8" font-weight="bold">A</text>';
            svg += '<text x="' + (neX - qPad - qLabelSize) + '" y="' + (neY + qPad + qLabelSize) + '" font-size="' + qLabelSize + '" fill="#cc00cc" opacity="0.8" font-weight="bold">B</text>';
            svg += '<text x="' + (swX + qPad) + '" y="' + (swY - qPad) + '" font-size="' + qLabelSize + '" fill="#cc00cc" opacity="0.8" font-weight="bold">C</text>';
            svg += '<text x="' + (seX - qPad - qLabelSize) + '" y="' + (seY - qPad) + '" font-size="' + qLabelSize + '" fill="#cc00cc" opacity="0.8" font-weight="bold">D</text>';
            
            // Draw center dividing line between adjacent grids (solid magenta)
            if (gIdx < grids.length - 1) {
              const nextC = grids[gIdx + 1]?.corners;
              if (nextC && Math.abs(c.ne.lon - nextC.nw.lon) < 0.01) {
                // Grids are adjacent horizontally
                svg += '<line x1="' + neX + '" y1="' + neY + '" x2="' + seX + '" y2="' + seY + '" stroke="#ff00ff" stroke-width="2"/>';
              }
            }
          });
          
          // Draw uncovered cells as dots (salmon/pink color like screenshot)
          grids.forEach(g => {
            if (g.uncoveredCells && g.uncoveredCells.length > 0) {
              // Sample uncovered cells (max ~1000 per grid for good density)
              const maxDots = 1000;
              const step = Math.max(1, Math.floor(g.uncoveredCells.length / maxDots));
              for (let i = 0; i < g.uncoveredCells.length; i += step) {
                const cell = g.uncoveredCells[i];
                const x = toX(cell.lon);
                const y = toY(cell.lat);
                svg += '<rect x="' + (x-2.5) + '" y="' + (y-2.5) + '" width="5" height="5" fill="#c08080" opacity="0.8"/>';
              }
            }
          });
          
          // Draw flight paths - clips naturally to view, use black for contrast
          flights.forEach((flight, fIdx) => {
            if (!flight.coordinates || flight.coordinates.length < 2) return;
            
            // Build path - draw all points, SVG will clip to viewBox
            let pathD = 'M ' + toX(flight.coordinates[0].lon).toFixed(1) + ' ' + toY(flight.coordinates[0].lat).toFixed(1);
            for (let i = 1; i < flight.coordinates.length; i++) {
              const coord = flight.coordinates[i];
              pathD += ' L ' + toX(coord.lon).toFixed(1) + ' ' + toY(coord.lat).toFixed(1);
            }
            
            // Use dark color for all tracks for better visibility on tight zoom
            svg += '<path d="' + pathD + '" fill="none" stroke="#1a1a1a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>';
          });
          
          // Grid labels (on top of everything)
          grids.forEach((g, gIdx) => {
            const c = g.corners;
            if (!c) return;
            
            const coverage = g.coverage?.total || 0;
            const nwX = toX(c.nw.lon), nwY = toY(c.nw.lat);
            const neX = toX(c.ne.lon), neY = toY(c.ne.lat);
            const swX = toX(c.sw.lon), swY = toY(c.sw.lat);
            const seX = toX(c.se.lon), seY = toY(c.se.lat);
            
            // Label background - centered in grid
            const centerX = (nwX + neX + swX + seX) / 4;
            const centerY = (nwY + neY + swY + seY) / 4;
            svg += '<rect x="' + (centerX - 55) + '" y="' + (centerY - 28) + '" width="110" height="56" fill="rgba(255,255,255,0.95)" stroke="#666" rx="4"/>';
            svg += '<text x="' + centerX + '" y="' + (centerY - 8) + '" text-anchor="middle" font-size="14" font-weight="bold" fill="#1a365d">' + escHtml(g.grid) + '</text>';
            svg += '<text x="' + centerX + '" y="' + (centerY + 18) + '" text-anchor="middle" font-size="18" font-weight="bold" fill="' + (coverage >= 80 ? '#38a169' : coverage >= 50 ? '#d69e2e' : '#e53e3e') + '">' + coverage + '% covered</text>';
          });
          
          // North arrow
          svg += '<g transform="translate(25,30)">';
          svg += '<polygon points="0,-18 6,0 -6,0" fill="#1a365d"/>';
          svg += '<text x="0" y="14" text-anchor="middle" font-size="11" font-weight="bold" fill="#1a365d">N</text>';
          svg += '</g>';
          
          // Legend
          svg += '<g transform="translate(' + (width - 140) + ',10)">';
          svg += '<rect x="0" y="0" width="135" height="70" fill="rgba(255,255,255,0.95)" stroke="#999" rx="4"/>';
          svg += '<text x="8" y="14" font-size="9" font-weight="bold" fill="#333">Legend</text>';
          svg += '<line x1="8" y1="26" x2="28" y2="26" stroke="#1a1a1a" stroke-width="2"/><text x="34" y="29" font-size="8">Flight Track</text>';
          svg += '<rect x="8" y="36" width="8" height="8" fill="#c08080"/><text x="34" y="44" font-size="8">Uncovered Area</text>';
          svg += '<line x1="8" y1="56" x2="28" y2="56" stroke="#ff00ff" stroke-width="2" stroke-dasharray="4,2"/><text x="34" y="59" font-size="8">Grid Boundary</text>';
          svg += '</g>';
          
          svg += '</svg>';
          return svg;
        })()}
      </div>
      <div style="flex:1">
        <div style="font-weight:bold;font-size:9pt;margin-bottom:6px">Grid Details:</div>
        <table style="font-size:8pt;width:100%">
          <thead>
            <tr style="background:#e2e8f0">
              <th>Grid</th>
              <th>Total</th>
              <th>A (NW)</th>
              <th>B (NE)</th>
              <th>C (SW)</th>
              <th>D (SE)</th>
            </tr>
          </thead>
          <tbody>
            ${cmdState.selectedGrids.map(g => `
            <tr>
              <td style="font-weight:bold">${escHtml(g.grid)}</td>
              <td style="text-align:center;font-weight:bold;color:${(g.coverage?.total || 0) >= 80 ? '#38a169' : (g.coverage?.total || 0) >= 50 ? '#d69e2e' : '#e53e3e'}">${g.coverage?.total || 0}%</td>
              <td style="text-align:center">${g.coverage?.A || 0}%</td>
              <td style="text-align:center">${g.coverage?.B || 0}%</td>
              <td style="text-align:center">${g.coverage?.C || 0}%</td>
              <td style="text-align:center">${g.coverage?.D || 0}%</td>
            </tr>`).join('')}
          </tbody>
        </table>
        
        <div style="margin-top:10px;font-weight:bold;font-size:9pt;margin-bottom:4px">Aircraft Tracks:</div>
        <table style="font-size:8pt;width:100%">
          <thead>
            <tr style="background:#e2e8f0">
              <th>Callsign</th>
              <th>Points</th>
              <th>Color</th>
            </tr>
          </thead>
          <tbody>
            ${cmdState.flights.map(f => `
            <tr>
              <td>${escHtml(f.callsign || 'Unknown')}</td>
              <td style="text-align:center">${f.coordinates?.length || 0}</td>
              <td><span style="display:inline-block;width:14px;height:14px;background:${f.color || '#999'};border-radius:3px;vertical-align:middle"></span></td>
            </tr>`).join('')}
          </tbody>
        </table>
      </div>
    </div>
  </div>
  
  <div style="margin-top:10px;padding:8px;background:#fffbeb;border-radius:4px;font-size:8pt;border:1px solid #f6e05e">
    <span style="font-weight:bold;color:#744210"> Analysis Assumptions:</span>
    <span style="margin-left:8px">Coverage Width: ${cmdState.coverageWidth || 0.5} NM (visual range from aircraft track)</span> |
    <span style="margin-left:4px">Cell Resolution: 0.1 NM</span> |
    <span style="margin-left:4px">Quadrant Layout: A=NW, B=NE, C=SW, D=SE</span>
    <div style="margin-top:4px;color:#92400e;font-style:italic">
      Note: Coverage percentages represent the portion of each grid visually searched based on flight tracks. Actual visual coverage depends on altitude, visibility, and observer effectiveness.
      ${cmdState.flightsOutsideArea ? ' WARNING: Flight tracks were outside the selected search grids.' : ''}
      ${cmdState.someFlightsOutside ? ' Note: Some track points were outside the search area and excluded from analysis.' : ''}
    </div>
  </div>
</div>` : ''}
            <div style="margin-top: 20px; font-size: 8pt; text-align: center; color: #666;">Generated: ${(/* @__PURE__ */ new Date()).toISOString()} | Mission Aircrew Toolkit (MAT)</div>
          </body></html>`);
      printWindow.document.close();
      printWindow.focus();
      setTimeout(() => printWindow.print(), 250);
      } catch (err) {
        alert('PDF generation failed. Pop-ups may be blocked. Error: ' + err.message);
      }
    };

    // Generate text log for copying
    const generateTextLog = () => {
      const lines = [];
      const sep = "".repeat(50);
      const sepLight = "".repeat(50);
      
      lines.push(sep);
      lines.push("CAP MISSION OBSERVER LOG");
      lines.push(sep);
      lines.push("");
      
      // Mission Info
      lines.push("MISSION INFORMATION");
      lines.push(sepLight);
      lines.push(`Mission #: ${missionInfo.missionNumber || "(none)"}`);
      lines.push(`Date (Z): ${missionInfo.dateZ || "(none)"}`);
      lines.push(`Sortie #: ${missionInfo.sortieNumber || "(none)"}`);
      lines.push(`Aircraft: N${missionInfo.aircraftTailN || "(none)"}`);
      lines.push(`Observer: ${missionInfo.observerName || "(none)"}`);
      lines.push(`Page: ${missionInfo.logPageNumber || "1"} of ${missionInfo.totalPages || "1"}`);
      lines.push("");
      
      // Times
      lines.push("TIME TRACKING (Zulu)");
      lines.push(sepLight);
      lines.push(`Tach Start: ${times.tachStart || "____"} | Hobbs Start: ${times.hobbsStart || "____"}`);
      lines.push(`Takeoff: ${times.takeoffTime || "____"}Z`);
      lines.push(`Entered Search: ${times.enteredSearchArea || "____"}Z`);
      lines.push(`Departed Search: ${times.departedSearchArea || "____"}Z`);
      lines.push(`Landing: ${times.landingTime || "____"}Z`);
      lines.push(`Tach Stop: ${times.tachShutdown || "____"} | Hobbs Stop: ${times.hobbsShutdown || "____"}`);
      lines.push(`Elapsed - Tach: ${calculated.tachElapsed || "____"} | Hobbs: ${calculated.hobbsElapsed || "____"}`);
      lines.push(`Enroute Time: ${calculated.enrouteTime || "____"} | Search Time: ${calculated.searchTime || "____"}`);
      lines.push("");
      
      // Fuel & Oil
      lines.push("FUEL & OIL");
      lines.push(sepLight);
      lines.push(`Fuel: ${fuelOil.fuelGallons || "____"} gal | Cost: $${fuelOil.fuelCost || "____"} | Oil: ${fuelOil.oilQt || "____"} qt`);
      lines.push("");
      
      // Notes
      lines.push("NOTES");
      lines.push(sepLight);
      lines.push(notes || "(No notes)");
      lines.push("");
      
      // Events
      lines.push("EVENTS LOG");
      lines.push(sepLight);
      const validEvents = events.filter(e => e.eventType || e.timeZ || e.notes);
      if (validEvents.length === 0) {
        lines.push("(No events logged)");
      } else {
        validEvents.forEach((e, idx) => {
          const dateTime = (e.dateZ || "") + " " + (e.timeZ || "____") + "Z";
          lines.push(`[${e.eventNum || idx + 1}] ${e.eventType || "(No type)"} @ ${dateTime.trim()}`);
          if (e.latDeg && e.latMin) {
            lines.push(`    Position: N ${e.latDeg} ${e.latMin}' W ${e.longDeg} ${e.longMin}'`);
          }
          if (e.capGrid) {
            lines.push(`    CAP Grid: ${e.capGrid}`);
          }
          if (e.altMSL || e.altAGL) {
            lines.push(`    Alt: ${e.altMSL ? e.altMSL + ' MSL' : ''} ${e.altAGL ? e.altAGL + ' AGL' : ''}`);
          }
          if (e.heading || e.airspeed || e.groundSpeed) {
            lines.push(`    Hdg: ${e.heading || "___"} | AS: ${e.airspeed || "___"} | GS: ${e.groundSpeed || "___"}`);
          }
          if (e.notes) {
            lines.push(`    Notes: ${e.notes}`);
          }
          lines.push("");
        });
      }
      
      // ELT Observations (if any)
      if (eltObservations && eltObservations.length > 0) {
        lines.push("");
        lines.push("ELT OBSERVATIONS");
        lines.push(sepLight);
        eltObservations.forEach((obs, idx) => {
          if (!obs) return;
          lines.push(`[${obs.obsNum || idx + 1}] ${obs.timeZ || "____"}Z - Source: ${obs.source || "unknown"}`);
          if (obs.latDeg && obs.latMin) {
            lines.push(`    Position: N ${obs.latDeg} ${obs.latMin}' W ${obs.lonDeg || "___"} ${obs.lonMin || "___"}'`);
          }
          if (obs.directRange) {
            lines.push(`    Range: ${obs.directRange} NM ${obs.rangeAccuracy ? '' + obs.rangeAccuracy : ''}`);
          } else if (obs.strength) {
            lines.push(`    Signal Strength: ${obs.strength}/10`);
          }
          if (obs.dfBearing) {
            lines.push(`    DF Bearing: ${obs.dfBearing} ${obs.bearingRef || ""} ${obs.bearingAccuracy || "20"}`);
          }
          if (obs.notes) {
            lines.push(`    Notes: ${obs.notes}`);
          }
          lines.push("");
        });
      }
      
      // ELT Solutions (if any)
      if (eltSolutions && eltSolutions.length > 0) {
        lines.push("");
        lines.push("ELT COMPUTED SOLUTIONS");
        lines.push(sepLight);
        eltSolutions.forEach((sol, idx) => {
          if (!sol || !sol.centroid) return;
          lines.push(`Solution #${sol.solutionNum || idx + 1} @ ${sol.timestamp || "____"}Z`);
          lines.push(`    Centroid: N ${sol.centroid.latDeg || "___"} ${sol.centroid.latMin || "___"}' W ${sol.centroid.lonDeg || "___"} ${sol.centroid.lonMin || "___"}'`);
          lines.push(`    CAP Grid: ${sol.capGrid || "(unknown)"}`);
          lines.push(`    50% Area: ${sol.area50SizeNm2 || "?"} NM | 90% Area: ${sol.area90SizeNm2 || "?"} NM`);
          lines.push(`    Quality: ${sol.qualityScore || "?"}/100 - ${sol.qualityLabel || ""}`);
          lines.push(`    Observations: ${sol.obsCount || "?"}${sol.dfCount > 0 ? ' (' + sol.dfCount + ' DF)' : ''}`);
          lines.push("");
        });
      }
      
      // Target Locations (if any)
      if (targetLocations && targetLocations.length > 0) {
        const validTargets = targetLocations.filter(t => t && t.lat !== undefined && t.lon !== undefined);
        if (validTargets.length > 0) {
          lines.push("");
          lines.push("TARGET LOCATIONS");
          lines.push(sepLight);
          validTargets.forEach((t, idx) => {
            lines.push(`Target #${idx + 1}: N ${t.lat.toFixed(5)} W ${Math.abs(t.lon).toFixed(5)}`);
          });
          lines.push("");
        }
      }
      
      // Search Planner (if plan exists)
      if (spState.lastPlan) {
        const plan = spState.lastPlan;
        lines.push("");
        lines.push("SEARCH PATTERN PLANNER");
        lines.push(sepLight);
        lines.push(`Pattern Type: ${plan.patternType}`);
        if (plan.gridInfo?.gridId) lines.push(`CAP Grid: ${plan.gridInfo.gridId}`);
        if (plan.generatedAtZ) lines.push(`Generated: ${plan.generatedDateZ || ""} ${plan.generatedAtZ}Z`);
        lines.push("");
        lines.push("POI:");
        if (plan.poi?.latDD) lines.push(`    Lat: ${plan.poi.latDD.toFixed(6)}N`);
        if (plan.poi?.lonDD) lines.push(`    Lon: ${Math.abs(plan.poi.lonDD).toFixed(6)}W`);
        if (plan.poi?.fromGrid) lines.push(`    From Grid: ${plan.poi.fromGrid}`);
        lines.push("");
        lines.push("Summary:");
        lines.push(`    Tracks: ${plan.summary?.numTracks || plan.summary?.numLegs || "?"}`);
        lines.push(`    Spacing: ${plan.summary?.spacing || "?"} NM`);
        lines.push(`    Total Distance: ${plan.summary?.totalDistance?.toFixed(1) || "?"} NM`);
        lines.push(`    Est. Time: ${plan.summary?.timeMinutes?.toFixed(0) || "?"} min`);
        if (plan.summary?.entryCorner) lines.push(`    Entry Corner: ${plan.summary.entryCorner}`);
        if (plan.coverage?.efficiency !== undefined) lines.push(`    Efficiency: ${plan.coverage.efficiency.toFixed(1)}%`);
        lines.push("");
        if (plan.waypoints && plan.waypoints.length > 0) {
          lines.push("ForeFlight Route:");
          lines.push(`    ${plan.waypoints.map(w => w.foreflight).join(" ")}`);
          lines.push("");
          lines.push("Waypoints:");
          plan.waypoints.forEach((w, i) => {
            lines.push(`    WP${String(i).padStart(2,"0")}: ${w.ddm || ""} | ${w.foreflight || ""} | Hdg: ${w.heading !== null && w.heading !== undefined ? w.heading + "" : "-"}`);
          });
        }
        lines.push("");
      }
      
      // Coverage Analysis (if analysis exists)
      if (cmdState.selectedGrids && cmdState.selectedGrids.length > 0 && cmdState.analysisTimestamp) {
        lines.push("");
        lines.push("COVERAGE ANALYSIS");
        lines.push(sepLight);
        lines.push(`Analyzed: ${cmdState.analysisDateZ || ""} ${cmdState.analysisTimeZ || ""}Z`);
        lines.push(`Aircraft Tracks: ${cmdState.flights?.length || 0}`);
        lines.push(`Track Points: ${(cmdState.totalFlightPoints || 0).toLocaleString()}`);
        lines.push(`Coverage Width: ${cmdState.coverageWidth || 0.5} NM`);
        lines.push("");
        
        const avgCoverage = cmdState.selectedGrids.length > 0 
          ? Math.round(cmdState.selectedGrids.reduce((sum, g) => sum + (g.coverage?.total || 0), 0) / cmdState.selectedGrids.length)
          : 0;
        lines.push(`Average Coverage: ${avgCoverage}%`);
        lines.push("");
        
        lines.push("Grid Results:");
        cmdState.selectedGrids.forEach(g => {
          lines.push(`    ${g.grid}: ${g.coverage?.total || 0}% total`);
          lines.push(`        A(NW): ${g.coverage?.A || 0}% | B(NE): ${g.coverage?.B || 0}% | C(SW): ${g.coverage?.C || 0}% | D(SE): ${g.coverage?.D || 0}%`);
        });
        lines.push("");
        
        lines.push("Aircraft:");
        cmdState.flights.forEach(f => {
          lines.push(`    ${f.callsign || "Unknown"}: ${f.coordinates?.length || 0} track points`);
        });
        lines.push("");
        
        if (cmdState.flightsOutsideArea) {
          lines.push("WARNING: Flight tracks were outside the selected search grids.");
        }
        if (cmdState.someFlightsOutside) {
          lines.push("Note: Some track points were outside the search area and excluded from analysis.");
        }
        lines.push("");
        lines.push("Assumptions: Coverage width = " + (cmdState.coverageWidth || 0.5) + " NM, Cell resolution = 0.1 NM");
        lines.push("Quadrant layout: A=NW, B=NE, C=SW, D=SE");
        lines.push("");
      }
      
      lines.push(sep);
      lines.push(`Generated: ${new Date().toISOString()}`);
      lines.push(sep);
      
      return lines.join("\n");
    };
    
    // Export mission file for sharing
    const exportMissionFile = () => {
      const exportData = {
        version: "3.4",
        exportDate: new Date().toISOString(),
        missionInfo,
        crewManifest,
        times,
        fuelOil,
        notes,
        events,
        targetLocations,
        radioCallSigns,
        eltObservations,
        eltSolutions,
        eltSettings,
        crosshairPoints,
        crosshairResult,
        crosshairAnalysis,
        searchPlan: spState.lastPlan,
        searchPlanHistory: spState.planHistory,
        coverageAnalysis: cmdState.selectedGrids?.length > 0 && cmdState.analysisTimestamp ? {
          selectedGrids: cmdState.selectedGrids,
          flights: cmdState.flights,
          coverageWidth: cmdState.coverageWidth,
          analysisTimestamp: cmdState.analysisTimestamp,
          analysisTimeZ: cmdState.analysisTimeZ,
          analysisDateZ: cmdState.analysisDateZ,
          totalFlightPoints: cmdState.totalFlightPoints,
          pointsInsideArea: cmdState.pointsInsideArea,
          flightsOutsideArea: cmdState.flightsOutsideArea,
          someFlightsOutside: cmdState.someFlightsOutside
        } : null
      };
      
      const jsonString = JSON.stringify(exportData, null, 2);
      const compressed = btoa(encodeURIComponent(jsonString));
      setShareCode(compressed);
      
      // Also create downloadable file
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `CAP_Mission_${missionInfo.missionSymbol || 'Mission'}_${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    };
    
    // Import mission file from code or file
    const importMissionFile = (inputData) => {
      try {
        let data;
        if (typeof inputData === 'string') {
          // Try to decode from base64
          try {
            const decoded = decodeURIComponent(atob(inputData));
            data = JSON.parse(decoded);
          } catch {
            // Try direct JSON parse
            data = JSON.parse(inputData);
          }
        } else {
          data = inputData;
        }
        
        if (data.missionInfo) setMissionInfo(data.missionInfo);
        if (data.crewManifest) setCrewManifest(data.crewManifest);
        if (data.times) setTimes(data.times);
        if (data.fuelOil) setFuelOil(data.fuelOil);
        if (data.notes) setNotes(data.notes);
        if (data.events) setEvents(data.events);
        if (data.targetLocations) setTargetLocations(data.targetLocations);
        if (data.radioCallSigns) setRadioCallSigns(data.radioCallSigns);
        if (data.eltObservations) setEltObservations(data.eltObservations);
        if (data.eltSolutions) setEltSolutions(data.eltSolutions);
        if (data.eltSettings) setEltSettings(data.eltSettings);
        if (data.crosshairPoints) setCrosshairPoints(data.crosshairPoints);
        if (data.crosshairResult) setCrosshairResult(data.crosshairResult);
        if (data.crosshairAnalysis) setCrosshairAnalysis(data.crosshairAnalysis);
        if (data.searchPlan || data.searchPlanHistory) {
          setSpState(prev => ({
            ...prev,
            lastPlan: data.searchPlan || prev.lastPlan,
            planHistory: data.searchPlanHistory || prev.planHistory
          }));
        }
        if (data.coverageAnalysis) {
          setCmdState(prev => ({
            ...prev,
            selectedGrids: data.coverageAnalysis.selectedGrids || prev.selectedGrids,
            flights: data.coverageAnalysis.flights || prev.flights,
            coverageWidth: data.coverageAnalysis.coverageWidth || prev.coverageWidth,
            analysisTimestamp: data.coverageAnalysis.analysisTimestamp,
            analysisTimeZ: data.coverageAnalysis.analysisTimeZ,
            analysisDateZ: data.coverageAnalysis.analysisDateZ,
            totalFlightPoints: data.coverageAnalysis.totalFlightPoints,
            pointsInsideArea: data.coverageAnalysis.pointsInsideArea,
            flightsOutsideArea: data.coverageAnalysis.flightsOutsideArea,
            someFlightsOutside: data.coverageAnalysis.someFlightsOutside
          }));
        }
        
        setShowShareModal(false);
        setImportCode("");
        alert('Mission data imported successfully!');
      } catch (err) {
        alert('Error importing data: ' + err.message);
      }
    };
    
    // Handle file import
    const handleFileImport = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);
          importMissionFile(data);
        } catch (err) {
          alert('Error reading file: ' + err.message);
        }
      };
      reader.readAsText(file);
    };
    
    // Copy log to clipboard
    const copyLogToClipboard = () => {
      try {
        const text = generateTextLog();
        
        // Try modern clipboard API first
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(() => {
            alert('Log copied to clipboard! You can now paste it into Notes or any text app.');
          }).catch((err) => {
            console.error('Clipboard API failed:', err);
            fallbackCopy(text);
          });
        } else {
          fallbackCopy(text);
        }
      } catch (err) {
        console.error('Copy log error:', err);
        alert('Error copying log: ' + err.message);
      }
    };
    
    // Fallback copy method for older browsers or when clipboard API fails
    const fallbackCopy = (text) => {
      try {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.left = '-9999px';
        textarea.style.top = '0';
        textarea.setAttribute('readonly', '');
        document.body.appendChild(textarea);
        textarea.select();
        textarea.setSelectionRange(0, text.length);
        const success = document.execCommand('copy');
        document.body.removeChild(textarea);
        if (success) {
          alert('Log copied to clipboard! You can now paste it into Notes or any text app.');
        } else {
          alert('Copy failed. Please try selecting text manually.');
        }
      } catch (err) {
        console.error('Fallback copy failed:', err);
        alert('Copy failed: ' + err.message);
      }
    };

    // Render share modal
    const renderShareModal = () => {
      if (!showShareModal) return null;
      
      // Native share function using Web Share API
      const nativeShare = async () => {
        const data = {
          missionInfo, crewManifest, times, fuelOil, notes, events, targetLocations,
          eltObservations, eltSolutions, radioCallSigns, nightMode, textSize
        };
        const jsonStr = JSON.stringify(data);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const file = new File([blob], `CAP_Mission_${missionInfo.missionNumber || 'Log'}_${missionInfo.dateZ || 'export'}.json`, { type: 'application/json' });
        
        // Create a summary text for sharing
        const summary = `CAP Mission Log
Mission: ${missionInfo.missionNumber || 'N/A'}
Date: ${missionInfo.dateZ || 'N/A'}
Aircraft: ${missionInfo.aircraftTailN || 'N/A'}
Events: ${events.length}`;
        
        if (navigator.share) {
          try {
            // Try sharing with file first
            if (navigator.canShare && navigator.canShare({ files: [file] })) {
              await navigator.share({
                title: 'CAP Mission Log',
                text: summary,
                files: [file]
              });
            } else {
              // Fall back to text-only share
              await navigator.share({
                title: 'CAP Mission Log',
                text: summary + '\n\nShare Code:\n' + btoa(jsonStr).substring(0, 500) + '...'
              });
            }
          } catch (err) {
            if (err.name !== 'AbortError') {
              alert('Share failed: ' + err.message);
            }
          }
        } else {
          alert('Native sharing not supported on this device. Use Download or Copy options instead.');
        }
      };
      
      const canNativeShare = typeof navigator.share === 'function';
      
      return React.createElement("div", {
        style: {
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: "rgba(0,0,0,0.85)",
          zIndex: 1000,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          padding: "20px"
        },
        onClick: () => setShowShareModal(false)
      },
        React.createElement("div", {
          style: {
            background: "#1a2c42",
            borderRadius: "12px",
            padding: "20px",
            width: "100%",
            maxWidth: "500px",
            maxHeight: "80vh",
            overflowY: "auto"
          },
          onClick: e => e.stopPropagation()
        },
          React.createElement("div", {
            style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "20px" }
          },
            React.createElement("h3", { style: { color: "#e2e8f0", margin: 0 } }, " Share / Import Mission"),
            React.createElement("button", {
              style: { background: "rgba(229,62,62,0.3)", border: "none", color: "#fc8181", padding: "8px 12px", borderRadius: "4px", cursor: "pointer" },
              onClick: () => setShowShareModal(false)
            }, "")
          ),
          
          // Native Share Button (mobile)
          canNativeShare && React.createElement("div", { style: { marginBottom: "20px" } },
            React.createElement("button", {
              style: { ...styles.button, width: "100%", background: "linear-gradient(135deg, #38a169, #2f855a)", padding: "16px", fontSize: "16px" },
              onClick: nativeShare
            }, " Share via Text, Email, AirDrop...")
          ),
          
          // Export Section
          React.createElement("div", { style: { marginBottom: "20px" } },
            React.createElement("h4", { style: { color: "#68d391", marginBottom: "10px" } }, "Export Mission"),
            React.createElement("button", {
              style: { ...styles.button, width: "100%", marginBottom: "10px" },
              onClick: exportMissionFile
            }, " Download Mission File"),
            shareCode && React.createElement("div", { style: { marginTop: "10px" } },
              React.createElement("label", { style: { color: "#a0aec0", fontSize: "12px" } }, "Or copy share code:"),
              React.createElement("textarea", {
                style: { ...styles.input, height: "60px", fontSize: "10px", fontFamily: "monospace", marginTop: "5px" },
                value: shareCode,
                readOnly: true,
                onClick: e => e.target.select()
              })
            )
          ),
          
          // Import Section
          React.createElement("div", { style: { borderTop: "1px solid rgba(255,255,255,0.1)", paddingTop: "20px" } },
            React.createElement("h4", { style: { color: "#63b3ed", marginBottom: "10px" } }, "Import Mission"),
            React.createElement("input", {
              type: "file",
              accept: "*/*",
              onChange: handleFileImport,
              style: { marginBottom: "10px", color: "#e2e8f0" }
            }),
            React.createElement("div", { style: { color: "#a0aec0", fontSize: "12px", marginBottom: "5px" } }, "Or paste share code:"),
            React.createElement("textarea", {
              style: { ...styles.input, height: "60px", fontSize: "10px", fontFamily: "monospace", marginBottom: "10px" },
              value: importCode,
              onChange: e => setImportCode(e.target.value),
              placeholder: "Paste share code here..."
            }),
            React.createElement("button", {
              style: { ...styles.button, width: "100%", background: "linear-gradient(135deg, #3182ce, #2b6cb0)" },
              onClick: importMissionFile
            }, " Import Mission Data")
          )
        )
      );
    };

    const clearAllData = () => {
      if (confirm("Clear ALL application data? This will reset everything.")) {
        // Clear Mission Info
        setMissionInfo({ missionNumber: "", dateZ: getZuluDate(), sortieNumber: "", aircraftTailN: "", logPageNumber: "1", totalPages: "1", observerName: "" });
        setTimes({ tachStart: "", tachShutdown: "", hobbsStart: "", hobbsShutdown: "", takeoffTime: "", landingTime: "", enteredSearchArea: "", departedSearchArea: "" });
        setFuelOil({ fuelGallons: "", fuelCost: "", oilQt: "" });
        setNotes("");
        
        // Clear Crew Manifest
        setCrewManifest([
          { name: "", capid: "", position: "PIC", qualification: "MP" },
          { name: "", capid: "", position: "Crew", qualification: "" }
        ]);
        
        // Clear Event Log
        eventSeqRef.current = 1;
        setEvents([createEmptyEvent(1)]);
        
        // Clear Target Locations
        setTargetLocations([
          { passes: ["", "", "", ""], estimate: "" },
          { passes: ["", "", "", ""], estimate: "" }
        ]);
        
        // Clear Radio Call Signs
        setRadioCallSigns({ aircraft: "", missionBase: "" });
        
        // Clear Crosshair Target Locate
        setCrosshairPoints([]);
        setCrosshairResult(null);
        setCrosshairAnalysis(null);
        setCrosshairShowMap(false);
        setCrosshairMapHtml('');
        targetSeqRef.current = 0;
        
        // Clear ELT Assist
        setEltObservations([]);
        setEltResult(null);
        setEltShowMap(false);
        setEltShowMapModal(false);
        setEltMapHtml('');
        setEltSolutions([]);
        setEltSettings({ r10: 0.5, k: 2, sigmaTheta: 20, resolution: 0.25, confidenceMode: 'auto', manualUncertainty: 50 });
        eltSolutionSeqRef.current = 0;
        eltObsSeqRef.current = 0;
        
        // Clear Search Probability Model
        setAdsbTrack(null);
        setSarsatPings([]);
        setSearchProbModel(null);
        setShowProbModel(false);
        
        // Clear Search Planning
        setSpState(prev => ({
          ...prev,
          patternType: 'gridParallelTrack',
          poiInput: '',
          poi: null,
          detectedGrid: null,
          spacing: 0.5,
          groundspeed: 90,
          entryCorner: 'NW',
          lastPlan: null,
          planHistory: [],
          showMap: false,
          showG1000Guide: false
        }));
        
        // Clear Command Tools / Coverage Analysis
        setCmdState(prev => ({
          ...prev,
          searchAreaMode: 'grid',
          gridInput: '',
          selectedGrids: [],
          pointInput: '',
          routePoints: [],
          coverageWidth: 0.5,
          flights: [],
          coverageGrid: null,
          showSettings: false,
          showMap: false,
          mapKey: 0,
          analysisGrids: [],
          showEighthGrids: false,
          showGapSelector: false,
          gapOptions: [],
          selectedGap: null,
          flightsOutsideArea: false,
          someFlightsOutside: false,
          pointsInsideArea: 0,
          pointsOutsideArea: 0,
          detectedFlightGrid: null,
          missionRecommendation: null,
          showMissionModal: false,
          suggestedGrid: null
        }));
        
        console.log('All application data cleared');
      }
    };
    
    // Text size multipliers for accessibility
    const getTextScale = () => {
      switch(textSize) {
        case 'large': return 1.25;
        case 'xlarge': return 1.5;
        default: return 1;
      }
    };
    const ts = (baseSize) => Math.round(parseFloat(baseSize) * getTextScale()) + 'px';
    
    // Enlarge modal renderer
    const renderEnlargeModal = () => {
      if (!enlargeModal.open) return null;
      return React.createElement("div", {
        style: {
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: "rgba(0,0,0,0.9)",
          zIndex: 9999,
          display: "flex",
          flexDirection: "column",
          padding: "20px"
        },
        onClick: () => setEnlargeModal({ open: false, title: "", content: "" })
      },
        React.createElement("div", {
          style: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: "20px"
          }
        },
          React.createElement("div", { style: { fontSize: "24px", fontWeight: "700", color: "#f6e05e" }}, enlargeModal.title),
          React.createElement("button", {
            style: {
              background: "rgba(255,255,255,0.2)",
              border: "none",
              borderRadius: "50%",
              width: "50px",
              height: "50px",
              fontSize: "28px",
              color: "#fff",
              cursor: "pointer"
            },
            onClick: () => setEnlargeModal({ open: false, title: "", content: "" })
          }, "")
        ),
        React.createElement("div", {
          style: {
            flex: 1,
            overflow: "auto",
            background: "rgba(255,255,255,0.05)",
            borderRadius: "12px",
            padding: "24px",
            fontSize: "28px",
            lineHeight: "1.6",
            color: "#fff",
            fontFamily: "monospace"
          },
          onClick: (e) => e.stopPropagation()
        }, enlargeModal.content)
      );
    };
    
    // Enlarge button component for multi-line text
    const EnlargeButton = ({ title, content }) => {
      return React.createElement("button", {
        style: {
          background: "rgba(99,179,237,0.2)",
          border: "1px solid rgba(99,179,237,0.4)",
          borderRadius: "6px",
          padding: "6px 10px",
          fontSize: ts("11"),
          color: "#63b3ed",
          cursor: "pointer",
          marginLeft: "8px",
          display: "inline-flex",
          alignItems: "center",
          gap: "4px"
        },
        onClick: (e) => {
          e.stopPropagation();
          setEnlargeModal({ open: true, title, content });
        }
      }, " Enlarge");
    };
    
    const styles = {
      container: { minHeight: "100vh", background: "linear-gradient(135deg, #0c1929 0%, #1a365d 50%, #234e82 100%)", fontFamily: '-apple-system, BlinkMacSystemFont, "SF Mono", monospace', color: "#e2e8f0", paddingBottom: "100px" },
      header: { background: "linear-gradient(180deg, rgba(0,0,0,0.4) 0%, transparent 100%)", borderBottom: "1px solid rgba(255,255,255,0.1)", padding: "12px 16px", display: "flex", alignItems: "center", justifyContent: "space-between", position: "sticky", top: 0, zIndex: 100, backdropFilter: "blur(10px)" },
      logo: { display: "flex", alignItems: "center", gap: "12px" },
      logoCircle: { width: "44px", height: "44px", borderRadius: "50%", background: "linear-gradient(135deg, #c53030 0%, #9b2c2c 100%)", display: "flex", alignItems: "center", justifyContent: "center", boxShadow: "0 4px 12px rgba(0,0,0,0.3)", border: "2px solid #f6e05e", color: "white", fontWeight: "bold", fontSize: ts("12") },
      title: { fontSize: ts("14"), fontWeight: "700", color: "#f6e05e" },
      subtitle: { fontSize: ts("10"), color: "#a0aec0", letterSpacing: "1px" },
      zuluTime: { background: "rgba(0,0,0,0.3)", padding: "6px 12px", borderRadius: "6px", fontSize: ts("12"), fontWeight: "600", color: "#68d391", border: "1px solid rgba(104, 211, 145, 0.3)" },
      tabs: { display: "flex", gap: "2px", padding: "8px 12px", background: "rgba(0,0,0,0.2)", overflowX: "auto", WebkitOverflowScrolling: "touch" },
      tab: { padding: "12px 16px", fontSize: ts("11"), fontWeight: "600", letterSpacing: "0.5px", textTransform: "uppercase", border: "none", borderRadius: "6px", cursor: "pointer", whiteSpace: "nowrap", fontFamily: "inherit", minHeight: "48px", touchAction: "manipulation" },
      tabActive: { background: "linear-gradient(135deg, #dd6b20 0%, #c05621 100%)", color: "#fff", boxShadow: "0 4px 12px rgba(221, 107, 32, 0.4)" },
      tabInactive: { background: "rgba(255,255,255,0.05)", color: "#a0aec0" },
      content: { padding: "16px", maxWidth: "800px", margin: "0 auto" },
      section: { background: "rgba(255,255,255,0.03)", borderRadius: "12px", border: "1px solid rgba(255,255,255,0.08)", marginBottom: "16px", overflow: "hidden" },
      sectionHeader: { background: "linear-gradient(90deg, rgba(221,107,32,0.3) 0%, transparent 100%)", padding: "14px 16px", borderBottom: "1px solid rgba(255,255,255,0.08)", fontSize: ts("13"), fontWeight: "700", letterSpacing: "1px", textTransform: "uppercase", color: "#f6e05e", display: "flex", alignItems: "center", gap: "8px" },
      sectionBody: { padding: "16px" },
      fieldGroup: { display: "grid", gap: "14px" },
      field: { display: "flex", flexDirection: "column", gap: "6px" },
      label: { fontSize: ts("11"), fontWeight: "600", letterSpacing: "0.5px", textTransform: "uppercase", color: "#a0aec0" },
      input: { background: "rgba(0,0,0,0.3)", border: "1px solid rgba(255,255,255,0.15)", borderRadius: "8px", padding: "14px", fontSize: ts("16"), color: "#fff", fontFamily: "inherit", outline: "none", width: "100%", boxSizing: "border-box", minHeight: "50px" },
      textarea: { minHeight: "100px", resize: "vertical" },
      button: { background: "linear-gradient(135deg, #dd6b20 0%, #c05621 100%)", color: "#fff", border: "none", borderRadius: "10px", padding: "16px 24px", fontSize: ts("14"), fontWeight: "700", cursor: "pointer", fontFamily: "inherit", boxShadow: "0 4px 12px rgba(221, 107, 32, 0.3)", minHeight: "52px", touchAction: "manipulation" },
      buttonSecondary: { background: "rgba(255,255,255,0.1)", color: "#e2e8f0", boxShadow: "none" },
      buttonSmall: { padding: "12px 16px", fontSize: ts("12"), minHeight: "48px" },
      buttonDanger: { background: "linear-gradient(135deg, #c53030 0%, #9b2c2c 100%)" },
      checkbox: { width: "28px", height: "28px", accentColor: "#dd6b20" },
      eventCard: { background: "rgba(0,0,0,0.2)", borderRadius: "10px", padding: "16px", marginBottom: "16px", border: "1px solid rgba(255,255,255,0.05)" },
      grid2: { display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "14px" },
      grid3: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "12px" },
      grid4: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: "12px" },
      calculated: { background: "rgba(104, 211, 145, 0.1)", border: "1px solid rgba(104, 211, 145, 0.3)", borderRadius: "8px", padding: "12px", color: "#68d391" },
      footer: { position: "fixed", bottom: 0, left: 0, right: 0, background: "linear-gradient(180deg, transparent 0%, rgba(12, 25, 41, 0.95) 20%, #0c1929 100%)", padding: "16px", display: "flex", gap: "12px", justifyContent: "center" },
      timeButton: { background: "rgba(104, 211, 145, 0.2)", border: "2px solid #68d391", color: "#68d391", borderRadius: "8px", padding: "12px 16px", fontSize: ts("13"), fontWeight: "700", cursor: "pointer", fontFamily: "inherit", minHeight: "48px", touchAction: "manipulation" },
      // Reference section styles
      refNav: { display: "flex", flexWrap: "wrap", gap: "8px", marginBottom: "16px" },
      refNavBtn: { padding: "12px 16px", fontSize: ts("11"), fontWeight: "600", border: "none", borderRadius: "8px", cursor: "pointer", fontFamily: "inherit", minHeight: "44px", touchAction: "manipulation" },
      refNavActive: { background: "#dd6b20", color: "#fff" },
      refNavInactive: { background: "rgba(255,255,255,0.1)", color: "#a0aec0" },
      refCard: { background: "rgba(0,0,0,0.2)", borderRadius: "8px", padding: "12px", marginBottom: "8px", border: "1px solid rgba(255,255,255,0.05)" },
      refTable: { width: "100%", borderCollapse: "collapse", fontSize: ts("12") },
      refTh: { background: "rgba(221,107,32,0.3)", padding: "8px", textAlign: "left", borderBottom: "1px solid rgba(255,255,255,0.1)" },
      refTd: { padding: "8px", borderBottom: "1px solid rgba(255,255,255,0.05)" },
      refHighlight: { background: "rgba(104, 211, 145, 0.1)", border: "1px solid rgba(104, 211, 145, 0.3)", borderRadius: "4px", padding: "2px 6px", fontSize: ts("11"), color: "#68d391" },
      pre: { background: "rgba(0,0,0,0.3)", padding: "12px", borderRadius: "6px", overflow: "auto", fontSize: ts("11"), lineHeight: "1.4", whiteSpace: "pre-wrap", fontFamily: "monospace" },
      searchInput: { background: "rgba(0,0,0,0.3)", border: "1px solid rgba(255,255,255,0.15)", borderRadius: "8px", padding: "14px", fontSize: ts("16"), color: "#fff", width: "100%", marginBottom: "12px", minHeight: "50px" },
      selectLarge: { background: "rgba(0,0,0,0.3)", border: "1px solid rgba(255,255,255,0.15)", borderRadius: "8px", padding: "16px 14px", fontSize: ts("18"), color: "#fff", fontFamily: "inherit", outline: "none", width: "100%", boxSizing: "border-box", minHeight: "58px", cursor: "pointer", WebkitAppearance: "none", appearance: "none", backgroundImage: "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23f6e05e' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E\")", backgroundRepeat: "no-repeat", backgroundPosition: "right 12px center", paddingRight: "44px" }
    };
    const [zuluClock, setZuluClock] = useState(getCurrentZuluTime());
    useEffect(() => {
      const interval = setInterval(() => setZuluClock(getCurrentZuluTime()), 1e3);
      return () => clearInterval(interval);
    }, []);
    
    // Home Screen with large navigation buttons
    const renderHomeTab = () => {
      const menuItems = [
        { id: "mission", icon: "", label: "Mission Info", desc: "Aircraft, crew, mission details", color: "#dd6b20" },
        { id: "times", icon: "", label: "Times & Fuel", desc: "Tach, Hobbs, flight times", color: "#3182ce" },
        { id: "events", icon: "", label: "Event Log", desc: "Record observations & positions", color: "#38a169" },
        { id: "crosshair", icon: "", label: "Target Locate", desc: "Crosshair triangulation tool", color: "#d69e2e" },
        { id: "eltAssist", icon: "", label: "ELT Assist", desc: "ELT signal tracking & SARSAT", color: "#ed8936" },
        { id: "searchPlanner", icon: "", label: "Search Planner", desc: "Generate search patterns", color: "#805ad5" },
        { id: "commandTools", icon: "", label: "Command Tools", desc: "Coverage analysis for IC/Planners", color: "#3182ce" },
        { id: "radio", icon: "", label: "Radio Calls", desc: "CAP radio call templates", color: "#3182ce" },
        { id: "coComms", icon: "", label: "CO Comms", desc: "Colorado frequencies & callsigns", color: "#2b6cb0" },
        { id: "emergency", icon: "", label: "Emergency", desc: "Emergency procedures & checklists", color: "#c53030" },
        { id: "reference", icon: "", label: "Reference", desc: "Charts, conversions, calculators", color: "#718096" },
        { id: "proficiency", icon: "", label: "Proficiency", desc: "CAPS 71-4 flight profiles", color: "#38a169" },
        { id: "demo", icon: "", label: "Demos", desc: "Interactive examples & tutorials", color: "#805ad5" }
      ];
      
      const homeStyles = {
        container: {
          padding: "8px"
        },
        welcome: {
          textAlign: "center",
          marginBottom: "24px",
          padding: "20px",
          background: "linear-gradient(135deg, rgba(221,107,32,0.2), rgba(192,86,33,0.1))",
          borderRadius: "16px",
          border: "1px solid rgba(221,107,32,0.3)"
        },
        welcomeTitle: {
          fontSize: ts("28"),
          fontWeight: "700",
          color: "#f6e05e",
          marginBottom: "8px"
        },
        welcomeSub: {
          fontSize: ts("14"),
          color: "#a0aec0"
        },
        grid: {
          display: "grid",
          gridTemplateColumns: "repeat(2, 1fr)",
          gap: "12px"
        },
        menuButton: {
          background: "rgba(0,0,0,0.3)",
          border: "2px solid rgba(255,255,255,0.1)",
          borderRadius: "16px",
          padding: "20px 16px",
          cursor: "pointer",
          textAlign: "center",
          transition: "all 0.2s",
          minHeight: "120px",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          gap: "8px"
        },
        menuIcon: {
          fontSize: ts("36"),
          marginBottom: "4px"
        },
        menuLabel: {
          fontSize: ts("16"),
          fontWeight: "700",
          color: "#fff"
        },
        menuDesc: {
          fontSize: ts("11"),
          color: "#a0aec0",
          lineHeight: "1.3"
        },
        quickActions: {
          marginTop: "24px",
          padding: "16px",
          background: "rgba(104,211,145,0.1)",
          borderRadius: "12px",
          border: "1px solid rgba(104,211,145,0.3)"
        },
        quickTitle: {
          fontSize: ts("12"),
          fontWeight: "700",
          color: "#68d391",
          textTransform: "uppercase",
          marginBottom: "12px",
          letterSpacing: "1px"
        },
        quickGrid: {
          display: "grid",
          gridTemplateColumns: "repeat(3, 1fr)",
          gap: "8px"
        },
        quickBtn: {
          background: "rgba(0,0,0,0.3)",
          border: "1px solid rgba(104,211,145,0.3)",
          borderRadius: "8px",
          padding: "12px 8px",
          cursor: "pointer",
          textAlign: "center",
          color: "#68d391",
          fontSize: ts("11"),
          fontWeight: "600"
        }
      };
      
      return React.createElement("div", { style: homeStyles.container },
        // Welcome header with CAP logo
        React.createElement("div", { style: homeStyles.welcome },
          React.createElement("img", { 
            src: "https://www.gocivilairpatrol.com/local/public/shared/assets/images/websites/CAP-2017-logo-horizontal-optimized-d73f31575f10142a77f0888cdfb36256.png", 
            alt: "Civil Air Patrol",
            style: { height: "50px", marginBottom: "12px", objectFit: "contain" }
          }),
          React.createElement("div", { style: homeStyles.welcomeTitle }, "Mission Aircrew Toolkit"),
          React.createElement("div", { style: homeStyles.welcomeSub }, 
            "Mission: ", missionInfo.missionNumber || "Not Set", "  ", zuluClock, "Z"
          )
        ),
        
        // Main menu grid
        React.createElement("div", { style: homeStyles.grid },
          menuItems.map(item => 
            React.createElement("button", {
              key: item.id,
              style: {
                ...homeStyles.menuButton,
                borderColor: `${item.color}60`,
                background: `linear-gradient(135deg, ${item.color}20, ${item.color}10)`
              },
              onClick: () => {
                // Check if CO Comms requires passcode
                if (item.id === "coComms" && !commsUnlocked) {
                  const code = prompt("Enter passcode to view Communications");
                  if (code === null) return;
                  if (String(code).trim() !== "1942") {
                    alert("Incorrect passcode.");
                    return;
                  }
                  setCommsUnlocked(true);
                }
                switchTab(item.id);
              }
            },
              React.createElement("div", { style: homeStyles.menuIcon }, item.icon),
              React.createElement("div", { style: { ...homeStyles.menuLabel, color: item.color === "#c53030" ? "#fc8181" : "#fff" }}, item.label),
              React.createElement("div", { style: homeStyles.menuDesc }, item.desc)
            )
          )
        ),
        
        // Active Proficiency Profile Status
        proficiencyState.selectedProfile && (() => {
          const profile = proficiencyProfiles.find(p => p.id === proficiencyState.selectedProfile);
          if (!profile) return null;
          
          // Calculate minimum requirements (same logic as profile tab)
          let minReq = 0, minReqMet = 0, routItems = 0, routCompleted = 0;
          (profile.sections || []).forEach(section => {
            if (section.type === 'routine') {
              (section.groups || []).forEach(group => {
                (group.items || []).forEach(item => {
                  routItems++;
                  if (proficiencyState.completedItems[item.id]) routCompleted++;
                });
              });
            } else if (section.type === 'required' || section.type === 'block') {
              // Collect pickPath groups
              const pathGroups = {};
              const regularGroups = [];
              (section.groups || []).forEach(group => {
                if (group.separator) return;
                if (group.pickPath && group.pathId) pathGroups[group.pathId] = group;
                else regularGroups.push(group);
              });
              // Handle pickPath - need all items in ONE path
              const pathIds = Object.keys(pathGroups);
              if (pathIds.length > 0) {
                minReq++;
                if (pathIds.some(pid => (pathGroups[pid].items || []).every(item => proficiencyState.completedItems[item.id]))) minReqMet++;
              }
              // Handle regular groups
              regularGroups.forEach(group => {
                if (group.pickOne) {
                  minReq++;
                  const anyFullyComplete = (group.items || []).some(item => {
                    if (!proficiencyState.completedItems[item.id]) return false;
                    if (item.subChecklist && item.subChecklist.items) {
                      return item.subChecklist.items.every(si => proficiencyState.completedItems[si.id]);
                    }
                    return true;
                  });
                  if (anyFullyComplete) minReqMet++;
                } else {
                  (group.items || []).forEach(item => {
                    minReq++;
                    if (proficiencyState.completedItems[item.id]) minReqMet++;
                    if (item.subChecklist && item.subChecklist.items && proficiencyState.completedItems[item.id]) {
                      item.subChecklist.items.forEach(si => {
                        minReq++;
                        if (proficiencyState.completedItems[si.id]) minReqMet++;
                      });
                    }
                  });
                }
              });
            }
          });
          const progress = minReq > 0 ? (minReqMet / minReq) * 100 : 0;
          
          return React.createElement("div", { 
            style: { 
              marginTop: "16px", 
              padding: "16px", 
              background: "linear-gradient(135deg, rgba(56,161,105,0.2), rgba(49,130,206,0.15))", 
              borderRadius: "12px", 
              border: "2px solid rgba(104,211,145,0.4)",
              cursor: "pointer"
            },
            onClick: () => switchTab("proficiency")
          },
            React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "8px" } },
              React.createElement("div", null,
                React.createElement("div", { style: { fontSize: ts("11"), color: "#68d391", fontWeight: "600" } }, "ACTIVE PROFILE P", profile.id),
                React.createElement("div", { style: { fontSize: ts("16"), fontWeight: "700", color: "#fff" } }, profile.name)
              ),
              React.createElement("div", { style: { fontSize: ts("24") } }, progress === 100 ? "" : "")
            ),
            React.createElement("div", { style: { marginBottom: "8px" } },
              React.createElement("div", { style: { height: "8px", background: "rgba(0,0,0,0.3)", borderRadius: "4px", overflow: "hidden" } },
                React.createElement("div", { style: { height: "100%", width: progress + "%", background: progress === 100 ? "linear-gradient(90deg, #38a169, #68d391)" : "linear-gradient(90deg, #3182ce, #63b3ed)", transition: "width 0.3s" } })
              )
            ),
            React.createElement("div", { style: { display: "flex", justifyContent: "space-between", fontSize: ts("11"), color: "#a0aec0" } },
              React.createElement("span", null, "Required: ", minReqMet, "/", minReq),
              routItems > 0 && React.createElement("span", null, "Routine: ", routCompleted, "/", routItems),
              React.createElement("span", { style: { color: "#68d391" } }, "Tap to continue ")
            )
          );
        })(),
        
        // Quick actions section
        React.createElement("div", { style: homeStyles.quickActions },
          React.createElement("div", { style: homeStyles.quickTitle }, " Quick Actions"),
          React.createElement("div", { style: homeStyles.quickGrid },
            React.createElement("button", {
              style: homeStyles.quickBtn,
              onClick: () => { switchTab("events"); }
            }, "\u2795 New Event"),
            React.createElement("button", {
              style: homeStyles.quickBtn,
              onClick: () => { switchTab("times"); }
            }, " Log Time"),
            React.createElement("button", {
              style: homeStyles.quickBtn,
              onClick: () => setShowShareModal(true)
            }, " Export")
          )
        ),
        
        // Version info
        React.createElement("div", { style: { textAlign: "center", marginTop: "24px", fontSize: ts("10"), color: "#718096" }},
          "Mission Aircrew Toolkit (MAT) v3.0  Civil Air Patrol"
        )
      );
    };
    
    const renderMissionTab = () => {
      const missionSymbols = [
        { value: "", label: "Select Symbol..." },
        { value: "A1", label: "A1 - SAR" },
        { value: "A2", label: "A2 - Disaster Relief" },
        { value: "A3", label: "A3 - HLS" },
        { value: "A5", label: "A5 - Training/Eval" },
        { value: "A6", label: "A6 - CD/Counterdrug" },
        { value: "A7", label: "A7 - Check Ride/Prof" },
        { value: "A8", label: "A8 - O-Flights" },
        { value: "A9", label: "A9 - Cadet O-Flights" },
        { value: "A12", label: "A12 - Proficiency" },
        { value: "A15", label: "A15 - Unit Training" },
        { value: "A24", label: "A24 - Re-Training" },
        { value: "B5", label: "B5 - Training (Non-AFAM)" },
        { value: "B7", label: "B7 - Check Ride (Non-AFAM)" },
        { value: "B12", label: "B12 - Prof (Non-AFAM)" },
        { value: "C", label: "C - Corporate" }
      ];
      const qualifications = ["", "MP", "MO", "MS", "AP", "TMP", "CFII", "IP", "Other"];
      const positions = ["PIC", "MO", "MS", "AP", "MP", "Trainee", "Other"];
      
      const updateCrewMember = (index, field, value) => {
        const updated = [...crewManifest];
        updated[index] = { ...updated[index], [field]: value };
        setCrewManifest(updated);
      };
      
      const addCrewMember = () => {
        if (crewManifest.length < 7) {
          setCrewManifest([...crewManifest, { name: "", capid: "", position: "Crew", qualification: "" }]);
        }
      };
      
      const removeCrewMember = (index) => {
        if (crewManifest.length > 1) {
          setCrewManifest(crewManifest.filter((_, i) => i !== index));
        }
      };
      
      return React.createElement("div", null,
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, " Mission Information"),
          React.createElement("div", { style: styles.sectionBody },
            React.createElement("div", { style: styles.fieldGroup },
              React.createElement("div", { style: styles.grid2 },
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: styles.label }, "Mission #"),
                  React.createElement("input", { style: styles.input, type: "text", value: missionInfo.missionNumber, onChange: (e) => setMissionInfo({ ...missionInfo, missionNumber: e.target.value }), placeholder: "e.g., 26-T-3912" })),
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: styles.label }, "Mission Symbol"),
                  React.createElement("select", { style: styles.selectLarge, value: missionInfo.missionSymbol, onChange: (e) => setMissionInfo({ ...missionInfo, missionSymbol: e.target.value }) },
                    missionSymbols.map(s => React.createElement("option", { key: s.value, value: s.value }, s.label))))),
              React.createElement("div", { style: styles.grid2 },
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: styles.label }, "Sortie #"),
                  React.createElement("input", { style: styles.input, type: "text", value: missionInfo.sortieNumber, onChange: (e) => setMissionInfo({ ...missionInfo, sortieNumber: e.target.value }), placeholder: "e.g., A0013" })),
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: styles.label }, "Date (UTC)"),
                  React.createElement("div", { style: { display: "flex", gap: "8px" }},
                    React.createElement("input", { style: { ...styles.input, flex: 1 }, type: "text", value: missionInfo.dateZ, onChange: (e) => setMissionInfo({ ...missionInfo, dateZ: e.target.value.toUpperCase() }), placeholder: "DDMMMYYYY" }),
                    React.createElement("button", { style: styles.timeButton, onClick: () => setMissionInfo({ ...missionInfo, dateZ: getZuluDate() }) }, "TODAY")))),
              React.createElement("div", { style: styles.grid2 },
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: styles.label }, "Aircraft N"),
                  React.createElement("input", { style: styles.input, type: "text", value: missionInfo.aircraftTailN, onChange: (e) => setMissionInfo({ ...missionInfo, aircraftTailN: e.target.value }), placeholder: "Tail #" })),
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: styles.label }, "Observer Name"),
                  React.createElement("input", { style: styles.input, type: "text", value: missionInfo.observerName, onChange: (e) => setMissionInfo({ ...missionInfo, observerName: e.target.value }), placeholder: "Your name" }))),
              React.createElement("div", { style: styles.field },
                React.createElement("label", { style: styles.label }, "Route of Flight"),
                React.createElement("input", { style: styles.input, type: "text", value: missionInfo.routeOfFlight, onChange: (e) => setMissionInfo({ ...missionInfo, routeOfFlight: e.target.value }), placeholder: "e.g., KAPA - DEN111 vicinity - KFLY" }))))),
        
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, " Crew Manifest"),
          React.createElement("div", { style: styles.sectionBody },
            crewManifest.map((crew, index) => React.createElement("div", { key: index, style: { background: "rgba(255,255,255,0.03)", padding: "12px", borderRadius: "8px", marginBottom: "8px", border: "1px solid rgba(255,255,255,0.08)" }},
              React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "8px" }},
                React.createElement("span", { style: { fontSize: "11px", fontWeight: "600", color: "#f6e05e" }}, "CREW " + (index + 1)),
                crewManifest.length > 1 && React.createElement("button", { style: { background: "rgba(229,62,62,0.2)", border: "none", color: "#fc8181", padding: "4px 8px", borderRadius: "4px", fontSize: "10px", cursor: "pointer" }, onClick: () => removeCrewMember(index) }, " REMOVE")),
              React.createElement("div", { style: styles.grid2 },
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: { ...styles.label, fontSize: "10px" }}, "Name"),
                  React.createElement("input", { style: styles.input, type: "text", value: crew.name, onChange: (e) => updateCrewMember(index, "name", e.target.value), placeholder: "Last, First" })),
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: { ...styles.label, fontSize: "10px" }}, "CAPID"),
                  React.createElement("input", { style: styles.input, type: "text", inputMode: "numeric", value: crew.capid, onChange: (e) => updateCrewMember(index, "capid", e.target.value), placeholder: "6 digits" }))),
              React.createElement("div", { style: styles.grid2 },
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: { ...styles.label, fontSize: "10px" }}, "Position"),
                  React.createElement("select", { style: styles.selectLarge, value: crew.position, onChange: (e) => updateCrewMember(index, "position", e.target.value) },
                    positions.map(p => React.createElement("option", { key: p, value: p }, p)))),
                React.createElement("div", { style: styles.field },
                  React.createElement("label", { style: { ...styles.label, fontSize: "10px" }}, "Qualification"),
                  React.createElement("select", { style: styles.selectLarge, value: crew.qualification, onChange: (e) => updateCrewMember(index, "qualification", e.target.value) },
                    qualifications.map(q => React.createElement("option", { key: q, value: q }, q || "(None)"))))))),
            crewManifest.length < 7 && React.createElement("button", { style: { ...styles.button, width: "100%", marginTop: "8px" }, onClick: addCrewMember }, "+ ADD CREW MEMBER"))),
        
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, " Timer"),
          React.createElement("div", { style: styles.sectionBody },
            React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "12px", marginBottom: "12px" }},
              React.createElement("label", { style: { display: "flex", alignItems: "center", gap: "8px", cursor: "pointer" }},
                React.createElement("input", { type: "checkbox", checked: opsTimerEnabled, onChange: (e) => { setOpsTimerEnabled(e.target.checked); if (e.target.checked && !opsTimerLastReset) { setOpsTimerLastReset(Date.now()); setOpsTimerRemaining(opsTimerMinutes * 60); } }, style: { width: "20px", height: "20px" } }),
                React.createElement("span", { style: { color: "#e2e8f0", fontSize: "14px" }}, "Enable Timer")),
              React.createElement("select", { style: { ...styles.input, width: "100px" }, value: opsTimerMinutes, onChange: (e) => { setOpsTimerMinutes(parseInt(e.target.value)); if (opsTimerEnabled) { setOpsTimerLastReset(Date.now()); setOpsTimerRemaining(parseInt(e.target.value) * 60); } } },
                React.createElement("option", { value: "15" }, "15 min"),
                React.createElement("option", { value: "30" }, "30 min"),
                React.createElement("option", { value: "45" }, "45 min"),
                React.createElement("option", { value: "60" }, "60 min"))),
            opsTimerEnabled && React.createElement("div", { style: { background: opsTimerRemaining <= 0 ? "rgba(229,62,62,0.2)" : opsTimerRemaining <= 120 ? "rgba(221,107,32,0.2)" : "rgba(56,161,105,0.1)", padding: "12px", borderRadius: "8px", textAlign: "center" }},
              React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", marginBottom: "4px" }}, "TIME REMAINING"),
              React.createElement("div", { style: { fontSize: "32px", fontWeight: "700", color: opsTimerRemaining <= 0 ? "#fc8181" : opsTimerRemaining <= 120 ? "#fbd38d" : "#68d391" }}, opsTimerRemaining !== null ? Math.floor(opsTimerRemaining / 60) + ":" + (opsTimerRemaining % 60).toString().padStart(2, "0") : "--:--"),
              React.createElement("button", { style: { ...styles.button, marginTop: "8px" }, onClick: () => { setOpsTimerLastReset(Date.now()); setOpsTimerRemaining(opsTimerMinutes * 60); } }, " RESET TIMER")),
            React.createElement("div", { style: { fontSize: "10px", color: "#718096", marginTop: "8px" }}, "Timer appears in header. Click RESET when needed."))),
        
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, " Notes & Instructions"),
          React.createElement("div", { style: styles.sectionBody },
            React.createElement("textarea", { style: { ...styles.input, ...styles.textarea }, value: notes, onChange: (e) => setNotes(e.target.value), placeholder: "Notes, radio channels, ATIS..." }))));
    };
    const renderTimesTab = () => {
      return React.createElement("div", null, 
        React.createElement("div", { style: styles.section }, 
          React.createElement("div", { style: styles.sectionHeader }, " Tach & Hobbs"), 
          React.createElement("div", { style: styles.sectionBody }, 
            React.createElement("div", { style: { ...styles.grid2, marginBottom: "16px" } }, 
              React.createElement("div", { style: { textAlign: "center", fontWeight: "600", color: "#f6e05e" } }, "TACH"), 
              React.createElement("div", { style: { textAlign: "center", fontWeight: "600", color: "#f6e05e" } }, "HOBBS")), 
            React.createElement("div", { style: styles.fieldGroup }, 
              React.createElement("div", null, 
                React.createElement("div", { style: { ...styles.label, marginBottom: "8px" } }, "Engine Start"), 
                React.createElement("div", { style: styles.grid2 }, 
                  React.createElement("input", { style: styles.input, type: "text", inputMode: "decimal", value: times.tachStart, onChange: (e) => setTimes({ ...times, tachStart: e.target.value }), placeholder: "Tach" }), 
                  React.createElement("input", { style: styles.input, type: "text", inputMode: "decimal", value: times.hobbsStart, onChange: (e) => setTimes({ ...times, hobbsStart: e.target.value }), placeholder: "Hobbs" }))), 
              React.createElement("div", null, 
                React.createElement("div", { style: { ...styles.label, marginBottom: "8px" } }, "Shutdown"), 
                React.createElement("div", { style: styles.grid2 }, 
                  React.createElement("input", { style: styles.input, type: "text", inputMode: "decimal", value: times.tachShutdown, onChange: (e) => setTimes({ ...times, tachShutdown: e.target.value }), placeholder: "Tach" }), 
                  React.createElement("input", { style: styles.input, type: "text", inputMode: "decimal", value: times.hobbsShutdown, onChange: (e) => setTimes({ ...times, hobbsShutdown: e.target.value }), placeholder: "Hobbs" }))), 
              React.createElement("div", { style: styles.calculated }, 
                React.createElement("div", { style: { ...styles.label, marginBottom: "8px", color: "#68d391" } }, "Elapsed (Auto)"), 
                React.createElement("div", { style: styles.grid2 }, 
                  React.createElement("div", { style: { textAlign: "center", fontSize: "18px", fontWeight: "700" } }, calculated.tachElapsed || ""), 
                  React.createElement("div", { style: { textAlign: "center", fontSize: "18px", fontWeight: "700" } }, calculated.hobbsElapsed || "")))))), 
        React.createElement("div", { style: styles.section }, 
          React.createElement("div", { style: styles.sectionHeader }, " Flight Times (UTC)"), 
          React.createElement("div", { style: styles.sectionBody }, 
            React.createElement("div", { style: styles.fieldGroup }, 
              [{ key: "takeoffTime", label: " Takeoff" }, { key: "enteredSearchArea", label: " Entered Search" }, { key: "departedSearchArea", label: " Departed Search" }, { key: "landingTime", label: " Landing" }].map(({ key, label }) => 
                React.createElement("div", { key, style: styles.field }, 
                  React.createElement("label", { style: styles.label }, label), 
                  React.createElement("div", { style: { display: "flex", gap: "8px", alignItems: "center" } }, 
                    React.createElement("input", { style: { ...styles.input, flex: 1, fontFamily: "monospace" }, type: "text", placeholder: "DDMMMYYYY HHMMZ", value: times[key], onChange: (e) => setTimes({ ...times, [key]: e.target.value.toUpperCase() }) }), 
                    React.createElement("button", { style: styles.timeButton, onClick: () => setTimes({ ...times, [key]: getZuluDateTime() }) }, "NOW")))),
              React.createElement("div", { style: styles.calculated }, 
                React.createElement("div", { style: styles.grid2 }, 
                  React.createElement("div", null, 
                    React.createElement("div", { style: { ...styles.label, color: "#68d391" } }, "Search Time"), 
                    React.createElement("div", { style: { fontSize: "18px", fontWeight: "700" } }, calculated.searchTime ? calculated.searchTime + " hrs" : "")), 
                  React.createElement("div", null, 
                    React.createElement("div", { style: { ...styles.label, color: "#68d391" } }, "Enroute"), 
                    React.createElement("div", { style: { fontSize: "18px", fontWeight: "700" } }, calculated.enrouteTime ? calculated.enrouteTime + " hrs" : ""))))))), 
        React.createElement("div", { style: styles.section }, 
          React.createElement("div", { style: styles.sectionHeader }, " Fuel & Oil"), 
          React.createElement("div", { style: styles.sectionBody }, 
            React.createElement("div", { style: styles.grid3 }, 
              React.createElement("div", { style: styles.field }, 
                React.createElement("label", { style: styles.label }, "Fuel (gal)"), 
                React.createElement("input", { style: styles.input, type: "text", inputMode: "decimal", value: fuelOil.fuelGallons, onChange: (e) => setFuelOil({ ...fuelOil, fuelGallons: e.target.value }) })), 
              React.createElement("div", { style: styles.field }, 
                React.createElement("label", { style: styles.label }, "Cost ($)"), 
                React.createElement("input", { style: styles.input, type: "text", inputMode: "decimal", value: fuelOil.fuelCost, onChange: (e) => setFuelOil({ ...fuelOil, fuelCost: e.target.value }) })), 
              React.createElement("div", { style: styles.field }, 
                React.createElement("label", { style: styles.label }, "Oil (qt)"), 
                React.createElement("input", { style: styles.input, type: "text", inputMode: "decimal", value: fuelOil.oilQt, onChange: (e) => setFuelOil({ ...fuelOil, oilQt: e.target.value }) }))))));
    };
    const renderEventsTab = () => {
      const primaryEventTypes = [
        { value: "Engine Start", label: " ENG START", color: "#38a169" },
        { value: "Wheels Up", label: " WHEELS UP", color: "#3182ce" },
        { value: "In Grid", label: " IN GRID", color: "#805ad5" },
        { value: "Out of Grid", label: " OUT GRID", color: "#718096" },
        { value: "Ops Normal", label: "\u2714 OPS NORMAL", color: "#38a169" },
        { value: "RTB", label: " RTB", color: "#dd6b20" },
        { value: "Wheels Down", label: " WHEELS DN", color: "#3182ce" },
        { value: "Engine Stop", label: " ENG STOP", color: "#e53e3e" }
      ];
      const moreEventTypes = [
        { value: "Sighting", label: " SIGHTING", color: "#3182ce" },
        { value: "ELT Signal", label: " ELT", color: "#e53e3e" },
        { value: "Target Located", label: " TARGET VISUAL", color: "#38a169" },
        { value: "Target Position Calculated", label: " TARGET CALC", color: "#d69e2e" },
        { value: "Checkpoint", label: "\u2714 CHKPT", color: "#805ad5" },
        { value: "Weather Change", label: " WX CHG", color: "#dd6b20" },
        { value: "Other", label: " OTHER", color: "#718096" }
      ];
      const toggleShowMore = (eventId) => {
        setShowMoreEventTypes((prev) => ({ ...prev, [eventId]: !prev[eventId] }));
      };
      
      // Check if an event has data (considered "in progress" or "complete")
      const isEventComplete = (evt) => evt.eventType && evt.timeZ;
      const isEventEmpty = (evt) => !evt.eventType && !evt.timeZ && !evt.notes && !evt.latDeg;
      
      return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { style: styles.section }, /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u{1F4CD} Events Log ", /* @__PURE__ */ React.createElement("span", { style: { fontSize: ts("12"), fontWeight: "400", color: "#a0aec0", marginLeft: "8px" } }, events.filter(e => isEventComplete(e)).length, " saved"), /* @__PURE__ */ React.createElement("button", { style: { ...styles.button, ...styles.buttonSmall, marginLeft: "auto" }, onClick: addEvent }, "+ ADD EVENT")), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, events.map((event, index) => /* @__PURE__ */ React.createElement("div", { key: event.id, style: { ...styles.eventCard, border: isEventEmpty(event) ? "2px dashed rgba(104,211,145,0.5)" : isEventComplete(event) ? "1px solid rgba(104,211,145,0.3)" : "1px solid rgba(255,255,255,0.05)", background: isEventEmpty(event) ? "rgba(104,211,145,0.05)" : "rgba(0,0,0,0.2)" } }, /* @__PURE__ */ React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "16px" } }, /* @__PURE__ */ React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "12px" } }, /* @__PURE__ */ React.createElement("span", { style: { fontWeight: "700", color: "#f6e05e", fontSize: ts("16") } }, "Event #", event.eventNum || index + 1), isEventComplete(event) ? /* @__PURE__ */ React.createElement("span", { style: { background: "rgba(104,211,145,0.2)", color: "#68d391", padding: "4px 10px", borderRadius: "12px", fontSize: ts("11"), fontWeight: "600", border: "1px solid rgba(104,211,145,0.3)" } }, "\u2714 SAVED") : isEventEmpty(event) ? /* @__PURE__ */ React.createElement("span", { style: { background: "rgba(99,179,237,0.2)", color: "#63b3ed", padding: "4px 10px", borderRadius: "12px", fontSize: ts("11"), fontWeight: "600", border: "1px solid rgba(99,179,237,0.3)" } }, "\u25CF NEW") : /* @__PURE__ */ React.createElement("span", { style: { background: "rgba(246,224,94,0.2)", color: "#f6e05e", padding: "4px 10px", borderRadius: "12px", fontSize: ts("11"), fontWeight: "600", border: "1px solid rgba(246,224,94,0.3)" } }, "\u25CF IN PROGRESS")), events.length > 1 && /* @__PURE__ */ React.createElement("button", { style: { ...styles.button, ...styles.buttonSmall, ...styles.buttonDanger }, onClick: () => removeEvent(event.id) }, "\u2715 REMOVE")), /* @__PURE__ */ React.createElement("div", { style: styles.fieldGroup }, /* @__PURE__ */ React.createElement("div", { style: styles.field }, /* @__PURE__ */ React.createElement("label", { style: styles.label }, "Event Type"), /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px", marginTop: "6px" } }, primaryEventTypes.map((type) => /* @__PURE__ */ React.createElement(
        "button",
        {
          key: type.value,
          style: {
            minHeight: "56px",
            padding: "12px 8px",
            fontSize: ts("12"),
            fontWeight: "700",
            background: event.eventType === type.value ? `linear-gradient(135deg, ${type.color}, ${type.color}dd)` : "rgba(0,0,0,0.3)",
            border: event.eventType === type.value ? `3px solid ${type.color}` : "2px solid rgba(255,255,255,0.15)",
            borderRadius: "10px",
            color: event.eventType === type.value ? "#fff" : "#a0aec0",
            fontFamily: "inherit",
            cursor: "pointer",
            touchAction: "manipulation",
            boxShadow: event.eventType === type.value ? `0 4px 12px ${type.color}44` : "none"
          },
          onClick: () => selectEventType(event.id, type.value)
        },
        type.label
      )), /* @__PURE__ */ React.createElement(
        "button",
        {
          style: {
            minHeight: "56px",
            padding: "12px 8px",
            fontSize: "12px",
            fontWeight: "700",
            background: showMoreEventTypes[event.id] ? "linear-gradient(135deg, #4a5568, #2d3748)" : "rgba(0,0,0,0.3)",
            border: showMoreEventTypes[event.id] ? "3px solid #a0aec0" : "2px solid rgba(255,255,255,0.15)",
            borderRadius: "10px",
            color: showMoreEventTypes[event.id] ? "#fff" : "#a0aec0",
            fontFamily: "inherit",
            cursor: "pointer",
            touchAction: "manipulation"
          },
          onClick: () => toggleShowMore(event.id)
        },
        showMoreEventTypes[event.id] ? "\u25B2 LESS" : "\u25BC MORE"
      )), showMoreEventTypes[event.id] && /* @__PURE__ */ React.createElement("div", { style: {
        display: "grid",
        gridTemplateColumns: "repeat(3, 1fr)",
        gap: "8px",
        marginTop: "8px",
        padding: "12px",
        background: "rgba(0,0,0,0.2)",
        borderRadius: "10px",
        border: "1px solid rgba(255,255,255,0.1)"
      } }, moreEventTypes.map((type) => /* @__PURE__ */ React.createElement(
        "button",
        {
          key: type.value,
          style: {
            minHeight: "56px",
            padding: "12px 8px",
            fontSize: "11px",
            fontWeight: "700",
            background: event.eventType === type.value ? `linear-gradient(135deg, ${type.color}, ${type.color}dd)` : "rgba(0,0,0,0.3)",
            border: event.eventType === type.value ? `3px solid ${type.color}` : "2px solid rgba(255,255,255,0.15)",
            borderRadius: "10px",
            color: event.eventType === type.value ? "#fff" : "#a0aec0",
            fontFamily: "inherit",
            cursor: "pointer",
            touchAction: "manipulation",
            boxShadow: event.eventType === type.value ? `0 4px 12px ${type.color}44` : "none"
          },
          onClick: () => selectEventType(event.id, type.value)
        },
        type.label
      ))), event.eventType && /* @__PURE__ */ React.createElement("div", { style: { marginTop: "8px", padding: "10px 12px", background: "rgba(104,211,145,0.1)", borderRadius: "8px", border: "1px solid rgba(104,211,145,0.3)", textAlign: "center" } }, /* @__PURE__ */ React.createElement("span", { style: { color: "#68d391", fontWeight: "700", fontSize: "14px" } }, "\u2713 ", event.eventType))), /* @__PURE__ */ React.createElement("div", { style: styles.field }, /* @__PURE__ */ React.createElement("label", { style: styles.label }, "Date/Time (UTC)"), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "8px", alignItems: "center" } }, /* @__PURE__ */ React.createElement("input", { style: { ...styles.input, flex: 1 }, type: "text", placeholder: "DDMMMYYYY", value: event.dateZ || "", onChange: (e) => updateEvent(event.id, "dateZ", e.target.value.toUpperCase()) }), /* @__PURE__ */ React.createElement("input", { style: { ...styles.input, width: "70px" }, type: "text", inputMode: "numeric", placeholder: "HHMM", value: event.timeZ, onChange: (e) => updateEvent(event.id, "timeZ", e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0", fontSize: "12px" } }, "Z"), /* @__PURE__ */ React.createElement("button", { style: styles.timeButton, onClick: () => setEventDateTime(event.id) }, "NOW"))), /* @__PURE__ */ React.createElement("div", { style: { background: "rgba(99,179,237,0.1)", padding: "12px", borderRadius: "8px", border: "1px solid rgba(99,179,237,0.2)", marginTop: "8px" } }, /* @__PURE__ */ React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "10px" } }, /* @__PURE__ */ React.createElement("label", { style: { ...styles.label, margin: 0, color: "#63b3ed", fontWeight: "600" } }, "\u{1F6F0}\uFE0F Position"), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "6px" } }, /* @__PURE__ */ React.createElement(
        "button",
        {
          style: { ...styles.button, background: "linear-gradient(135deg, #38a169, #2f855a)", padding: "8px 14px", fontSize: "13px", fontWeight: "700" },
          onClick: () => {
            if (!navigator.geolocation) {
              alert("GPS not available");
              return;
            }
            navigator.geolocation.getCurrentPosition(
              (pos) => {
                const lat = pos.coords.latitude;
                const lon = Math.abs(pos.coords.longitude);
                const latDdm = gpsUtils.ddToDdm(lat);
                const lonDdm = gpsUtils.ddToDdm(lon);
                const grid = gpsUtils.calculateCapGrid(lat, -lon);
                setEvents(events.map((e) => e.id === event.id ? {
                  ...e,
                  latDeg: latDdm.deg.toString(),
                  latMin: latDdm.min.toFixed(3),
                  longDeg: lonDdm.deg.toString(),
                  longMin: lonDdm.min.toFixed(3),
                  capGrid: grid?.full || ""
                } : e));
              },
              (err) => alert("GPS Error: " + err.message),
              { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
            );
          }
        },
        "\u{1F4CD} GPS"
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          style: { ...styles.button, ...styles.buttonSmall, background: "linear-gradient(135deg, #3182ce, #2b6cb0)", padding: "8px 10px" },
          onClick: () => openGpsModal(event.id, event.latDeg, event.latMin, event.longDeg, event.longMin)
        },
        "\u2699\uFE0F Tools"
      ))), /* @__PURE__ */ React.createElement("div", { style: styles.grid2 }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("label", { style: styles.label }, "Lat N (deg\xB0 min')"), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "4px", alignItems: "center" } }, /* @__PURE__ */ React.createElement("input", { style: { ...styles.input, width: "60px", textAlign: "center" }, type: "text", inputMode: "numeric", placeholder: "DD", value: event.latDeg, onChange: (e) => updateEvent(event.id, "latDeg", e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0" } }, "\xB0"), /* @__PURE__ */ React.createElement("input", { style: { ...styles.input, flex: 1 }, type: "text", inputMode: "decimal", placeholder: "MM.MMM", value: event.latMin, onChange: (e) => updateEvent(event.id, "latMin", e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0" } }, "'"))), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("label", { style: styles.label }, "Long W (deg\xB0 min')"), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "4px", alignItems: "center" } }, /* @__PURE__ */ React.createElement("input", { style: { ...styles.input, width: "60px", textAlign: "center" }, type: "text", inputMode: "numeric", placeholder: "DDD", value: event.longDeg, onChange: (e) => updateEvent(event.id, "longDeg", e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0" } }, "\xB0"), /* @__PURE__ */ React.createElement("input", { style: { ...styles.input, flex: 1 }, type: "text", inputMode: "decimal", placeholder: "MM.MMM", value: event.longMin, onChange: (e) => updateEvent(event.id, "longMin", e.target.value) }), /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0" } }, "'")))), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "8px", marginTop: "10px" } }, /* @__PURE__ */ React.createElement(
        "button",
        {
          style: { ...styles.button, ...styles.buttonSmall, flex: 1, background: "linear-gradient(135deg, #38a169, #2f855a)", padding: "10px" },
          onClick: () => {
            if (!navigator.geolocation) {
              alert("GPS not available");
              return;
            }
            navigator.geolocation.getCurrentPosition(
              (pos) => {
                const lat = pos.coords.latitude;
                const lon = Math.abs(pos.coords.longitude);
                const latDdm = gpsUtils.ddToDdm(lat);
                const lonDdm = gpsUtils.ddToDdm(lon);
                const grid = gpsUtils.calculateCapGrid(lat, -lon);
                setEvents(events.map((e) => e.id === event.id ? {
                  ...e,
                  latDeg: latDdm.deg.toString(),
                  latMin: latDdm.min.toFixed(3),
                  longDeg: lonDdm.deg.toString(),
                  longMin: lonDdm.min.toFixed(3),
                  capGrid: grid?.full || ""
                } : e));
              },
              (err) => alert("GPS Error: " + err.message),
              { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
            );
          }
        },
        "\u{1F4CD} GET GPS"
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          style: { ...styles.button, ...styles.buttonSmall, flex: 1, background: "rgba(99,179,237,0.2)", border: "1px solid rgba(99,179,237,0.4)", color: "#63b3ed" },
          onClick: () => {
            if (event.latDeg && event.longDeg) {
              const lat = gpsUtils.ddmToDd(event.latDeg, event.latMin || 0);
              const lon = gpsUtils.ddmToDd(event.longDeg, event.longMin || 0);
              window.open(`https://www.openstreetmap.org/?mlat=${lat}&mlon=-${lon}&zoom=14`, "_blank");
            } else {
              alert("Enter coordinates first");
            }
          }
        },
        "\u{1F5FA}\uFE0F View Map"
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          style: { ...styles.button, ...styles.buttonSmall, flex: 1, background: "rgba(246,224,94,0.2)", border: "1px solid rgba(246,224,94,0.4)", color: "#f6e05e" },
          onClick: () => {
            if (event.latDeg && event.longDeg) {
              const lat = gpsUtils.ddmToDd(event.latDeg, event.latMin || 0);
              const lon = gpsUtils.ddmToDd(event.longDeg, event.longMin || 0);
              const grid = gpsUtils.calculateCapGrid(lat, -lon);
              updateEvent(event.id, "capGrid", grid?.full || "N/A");
            } else {
              alert("Enter coordinates first");
            }
          }
        },
        "\u{1F5FA}\uFE0F Calc Grid"
      )), event.capGrid && /* @__PURE__ */ React.createElement("div", { style: { marginTop: "10px", padding: "8px 12px", background: "linear-gradient(135deg, rgba(246,224,94,0.15), rgba(237,137,54,0.15))", borderRadius: "6px", border: "1px solid rgba(246,224,94,0.3)", textAlign: "center" } }, /* @__PURE__ */ React.createElement("span", { style: { fontSize: "11px", color: "#a0aec0" } }, "CAP Grid: "), /* @__PURE__ */ React.createElement("span", { style: { fontSize: "16px", fontWeight: "700", color: "#f6e05e", fontFamily: "monospace", letterSpacing: "1px" } }, event.capGrid))), /* @__PURE__ */ React.createElement("div", { style: { ...styles.grid2, marginTop: "12px" } }, /* @__PURE__ */ React.createElement("div", { style: styles.field }, /* @__PURE__ */ React.createElement("label", { style: styles.label }, "Alt MSL"), /* @__PURE__ */ React.createElement("input", { style: styles.input, type: "text", inputMode: "numeric", placeholder: "ft", value: event.altMSL, onChange: (e) => updateEvent(event.id, "altMSL", e.target.value) })), /* @__PURE__ */ React.createElement("div", { style: styles.field }, /* @__PURE__ */ React.createElement("label", { style: styles.label }, "Alt AGL"), /* @__PURE__ */ React.createElement("input", { style: styles.input, type: "text", inputMode: "numeric", placeholder: "ft", value: event.altAGL, onChange: (e) => updateEvent(event.id, "altAGL", e.target.value) }))), /* @__PURE__ */ React.createElement("div", { style: styles.grid3 }, /* @__PURE__ */ React.createElement("div", { style: styles.field }, /* @__PURE__ */ React.createElement("label", { style: styles.label }, "Heading"), /* @__PURE__ */ React.createElement("input", { style: styles.input, type: "text", inputMode: "numeric", placeholder: "\xB0", value: event.heading, onChange: (e) => updateEvent(event.id, "heading", e.target.value) })), /* @__PURE__ */ React.createElement("div", { style: styles.field }, /* @__PURE__ */ React.createElement("label", { style: styles.label }, "Airspeed"), /* @__PURE__ */ React.createElement("input", { style: styles.input, type: "text", inputMode: "numeric", placeholder: "kts", value: event.airspeed, onChange: (e) => updateEvent(event.id, "airspeed", e.target.value) })), /* @__PURE__ */ React.createElement("div", { style: styles.field }, /* @__PURE__ */ React.createElement("label", { style: styles.label }, "Gnd Spd"), /* @__PURE__ */ React.createElement("input", { style: styles.input, type: "text", inputMode: "numeric", placeholder: "kts", value: event.groundSpeed, onChange: (e) => updateEvent(event.id, "groundSpeed", e.target.value) }))), /* @__PURE__ */ React.createElement("div", { style: { marginTop: "16px", background: "rgba(246,224,94,0.08)", padding: "14px", borderRadius: "10px", border: "1px solid rgba(246,224,94,0.25)" } }, /* @__PURE__ */ React.createElement("label", { style: { ...styles.label, color: "#f6e05e", fontWeight: "600", marginBottom: "10px", display: "block" } }, "\u{1F4DD} Notes"), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "10px", marginBottom: "12px", flexWrap: "wrap" } }, /* @__PURE__ */ React.createElement(
        "button",
        {
          style: {
            minHeight: "56px",
            minWidth: "100px",
            flex: 1,
            padding: "14px 18px",
            fontSize: "15px",
            fontWeight: "700",
            background: "linear-gradient(135deg, #38a169, #2f855a)",
            border: "2px solid #48bb78",
            borderRadius: "10px",
            color: "#fff",
            fontFamily: "inherit",
            cursor: "pointer",
            touchAction: "manipulation"
          },
          onClick: () => {
            const timestamp = getZuluTimeOnly();
            const newNote = event.notes ? event.notes + "\n" + timestamp + " - Ops Normal" : timestamp + " - Ops Normal";
            updateEvent(event.id, "notes", newNote);
          }
        },
        "\u2713 OPS NORMAL"
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          style: {
            minHeight: "56px",
            minWidth: "100px",
            flex: 1,
            padding: "14px 18px",
            fontSize: "15px",
            fontWeight: "700",
            background: "linear-gradient(135deg, #dd6b20, #c05621)",
            border: "2px solid #ed8936",
            borderRadius: "10px",
            color: "#fff",
            fontFamily: "inherit",
            cursor: "pointer",
            touchAction: "manipulation"
          },
          onClick: () => {
            const timestamp = getZuluTimeOnly();
            const newNote = event.notes ? event.notes + "\n" + timestamp + " - RTB" : timestamp + " - RTB";
            updateEvent(event.id, "notes", newNote);
          }
        },
        "\u21A9 RTB"
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          style: {
            minHeight: "56px",
            minWidth: "100px",
            flex: 1,
            padding: "14px 18px",
            fontSize: "15px",
            fontWeight: "700",
            background: "linear-gradient(135deg, #3182ce, #2b6cb0)",
            border: "2px solid #4299e1",
            borderRadius: "10px",
            color: "#fff",
            fontFamily: "inherit",
            cursor: "pointer",
            touchAction: "manipulation"
          },
          onClick: () => {
            setPirepData({
              aircraft: "",
              altitude: event.altMSL || "",
              clouds: "",
              turbulence: "",
              icing: "",
              visibility: "",
              remarks: ""
            });
            setPirepModal({ open: true, eventId: event.id });
          }
        },
        "\u2601 PIREP"
      ), /* @__PURE__ */ React.createElement(
        "div",
        {
          style: {
            marginTop: "14px",
            background: "rgba(0,0,0,0.2)",
            border: "1px dashed rgba(255,255,255,0.25)",
            borderRadius: "10px",
            padding: "10px"
          }
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            style: {
              fontSize: "11px",
              color: "#a0aec0",
              fontWeight: "700",
              letterSpacing: "1px",
              marginBottom: "8px"
            }
          },
          "QUICK DETAILS"
        ),
        (event.eventType === "Target Located" || event.eventType === "Target Position Calculated" || event.eventType === "ELT Signal" || event.eventType === "Weather Change" || event.eventType === "Sighting") && /* @__PURE__ */ React.createElement(
          "div",
          { style: { display: "flex", flexWrap: "wrap", gap: "8px" } },
          ...(event.eventType === "Target Located" ? [
            { label: "Target Confirmed" },
            { label: "High Confidence" },
            { label: "Low Confidence" },
            { label: "Survivor Located" }
          ] : event.eventType === "Target Position Calculated" ? [
            { label: "Crosshair Method" },
            { label: "ELT Triangulation" },
            { label: "High Confidence" },
            { label: "Low Confidence" },
            { label: "Re-fly Recommended" }
          ] : event.eventType === "ELT Signal" ? [
            { label: "Strong Signal" },
            { label: "Weak Signal" }
          ] : event.eventType === "Weather Change" ? [
            { label: "Visibility Decreasing" },
            { label: "Wind Increasing" },
            { label: "Turbulence Increasing" },
            { label: "Rain" },
            { label: "Snow" },
            { label: "Conditions Improved" },
            { label: "Poor conditions, RTB" }
          ] : [
            { label: "Possible Target" },
            { label: "Person" },
            { label: "Vehicle" },
            { label: "Aircraft" },
            { label: "Fire" },
            { label: "Reflection" }
          ]).map((opt) => /* @__PURE__ */ React.createElement(
            "button",
            {
              key: opt.label,
              type: "button",
              style: {
                padding: "10px 12px",
                fontSize: "13px",
                fontWeight: "800",
                background: "rgba(255,255,255,0.08)",
                border: "1px solid rgba(255,255,255,0.18)",
                borderRadius: "10px",
                color: "#fff",
                fontFamily: "inherit",
                cursor: "pointer",
                touchAction: "manipulation"
              },
              onClick: () => {
                const timestamp = getZuluTimeOnly();
                const prefix = event.eventType === "Weather Change" ? "WX CHG" : event.eventType === "ELT Signal" ? "ELT" : event.eventType === "Target Located" ? "TARGET VISUAL" : event.eventType === "Target Position Calculated" ? "TARGET CALC" : "SIGHTING";
                const line = timestamp + " - " + prefix + " - " + opt.label;
                const newNote = event.notes ? event.notes + "\n" + line : line;
                updateEvent(event.id, "notes", newNote);
              }
            },
            opt.label
          ))
        )
      )
), /* @__PURE__ */ React.createElement(
        "textarea",
        {
          style: {
            ...styles.input,
            minHeight: "120px",
            resize: "vertical",
            fontSize: "16px",
            lineHeight: "1.5",
            padding: "14px"
          },
          placeholder: "Enter observation notes...",
          value: event.notes,
          onChange: (e) => updateEvent(event.id, "notes", e.target.value)
        }
      ), /* @__PURE__ */ React.createElement("div", { style: { display: "flex", gap: "12px", marginTop: "16px", paddingTop: "16px", borderTop: "2px solid rgba(255,255,255,0.1)" } },
        /* @__PURE__ */ React.createElement("button", {
          style: {
            ...styles.button,
            flex: 1,
            background: "linear-gradient(135deg, #38a169, #2f855a)",
            fontSize: ts("15"),
            padding: "16px",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: "8px"
          },
          onClick: () => {
            // Mark this event as saved (could add visual feedback)
            if (!event.eventType) {
              alert("Please select an event type before saving.");
              return;
            }
            // Add a new blank event
            addEvent();
            // Scroll to top of events or to the new event
            window.scrollTo({ top: 0, behavior: 'smooth' });
          }
        }, "\u2714 SAVE & NEW EVENT"),
        /* @__PURE__ */ React.createElement("button", {
          style: {
            ...styles.button,
            ...styles.buttonSecondary,
            flex: 1,
            border: "2px solid rgba(255,255,255,0.2)",
            fontSize: ts("14"),
            padding: "16px"
          },
          onClick: () => {
            if (confirm("Reset this event? All data will be cleared.")) {
              const resetEvent = createEmptyEvent(event.eventNum);
              resetEvent.id = event.id;
              setEvents(events.map(e => e.id === event.id ? resetEvent : e));
            }
          }
        }, " RESET EVENT")
      ))))))), /* @__PURE__ */ React.createElement(
        GpsToolsModal,
        {
          isOpen: gpsModalOpen,
          onClose: () => setGpsModalOpen(false),
          onApply: handleGpsApply,
          initialLat: gpsModalInitialLat,
          initialLon: gpsModalInitialLon,
          eventId: gpsModalEventId
        }
      ), /* @__PURE__ */ React.createElement(
        PirepModal,
        {
          isOpen: pirepModal.open,
          onClose: () => setPirepModal({ open: false, eventId: null }),
          data: pirepData,
          setData: setPirepData,
          onSave: (pirepString) => {
            const timestamp = getZuluTimeOnly();
            const eventId = pirepModal.eventId;
            const event = events.find((e) => e.id === eventId);
            if (event) {
              const newNote = event.notes ? event.notes + "\n" + timestamp + " - " + pirepString : timestamp + " - " + pirepString;
              updateEvent(eventId, "notes", newNote);
            }
          },
          onRadioCall: () => setPirepRadioCall({ open: true, eventId: pirepModal.eventId })
        }
      ), /* @__PURE__ */ React.createElement(
        PirepRadioCallOverlay,
        {
          isOpen: pirepRadioCall.open,
          onClose: () => {
            setPirepRadioCall({ open: false, eventId: null });
            setPirepModal({ open: false, eventId: null });
          },
          pirepData: pirepData,
          event: events.find((e) => e.id === pirepRadioCall.eventId),
          missionInfo: missionInfo
        }
      ));
    };
    const renderCrosshairTab = () => {
      // Helper: Calculate bearing between two points (in degrees)
      const calcBearing = (lat1, lon1, lat2, lon2) => {
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const lat1Rad = lat1 * Math.PI / 180;
        const lat2Rad = lat2 * Math.PI / 180;
        const y = Math.sin(dLon) * Math.cos(lat2Rad);
        const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
        let bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
      };
      
      // Helper: Convert point to decimal degrees
      const pointToDD = (pt) => ({
        lat: gpsUtils.ddmToDd(pt.latDeg, pt.latMin),
        lon: -gpsUtils.ddmToDd(pt.lonDeg, pt.lonMin) // West is negative
      });
      
      // Helper: Calculate angle difference (handles wraparound)
      const angleDiff = (a1, a2) => {
        let diff = Math.abs(a1 - a2) % 360;
        return diff > 180 ? 360 - diff : diff;
      };
      
      // AUTOMATIC PATH DETECTION: Analyze points and find best intersection
      const analyzeAndCalculate = () => {
        if (crosshairPoints.length < 4) {
          alert("Need at least 4 points to calculate intersection.\n\nMark 2+ points on first pass, then 2+ points on second pass.");
          return;
        }
        
        // Initialize quality metrics
        let qualityMetrics = {
          crossingAngle: 0,
          avgBearing1: 0,
          avgBearing2: 0,
          closestApproachNM: 0,
          pathDetectionMethod: 'unknown',
          methodsCompared: []
        };
        
        // Convert all points to decimal degrees
        const pts = crosshairPoints.map((pt, idx) => ({
          ...pt,
          idx,
          dd: pointToDD(pt)
        }));
        
        // PRIMARY METHOD: Bearing-based clustering
        // Calculate bearing between consecutive points
        const segments = [];
        for (let i = 0; i < pts.length - 1; i++) {
          const bearing = calcBearing(pts[i].dd.lat, pts[i].dd.lon, pts[i+1].dd.lat, pts[i+1].dd.lon);
          segments.push({
            startIdx: i,
            endIdx: i + 1,
            bearing,
            startPt: pts[i],
            endPt: pts[i+1]
          });
        }
        
        // Group segments by similar bearing (within 30 degrees)
        const pathGroups = [];
        let currentGroup = [segments[0]];
        
        for (let i = 1; i < segments.length; i++) {
          const prevBearing = currentGroup[currentGroup.length - 1].bearing;
          const currBearing = segments[i].bearing;
          const diff = angleDiff(prevBearing, currBearing);
          
          if (diff < 30) {
            // Similar bearing, add to current group
            currentGroup.push(segments[i]);
          } else {
            // Significant bearing change - start new group
            if (currentGroup.length > 0) pathGroups.push(currentGroup);
            currentGroup = [segments[i]];
          }
        }
        if (currentGroup.length > 0) pathGroups.push(currentGroup);
        
        let path1Points, path2Points, method;
        
        if (pathGroups.length >= 2) {
          // SUCCESS: Found distinct path groups by bearing
          // Use the two largest groups
          pathGroups.sort((a, b) => b.length - a.length);
          
          // Get all points from each path group
          const group1Indices = new Set();
          pathGroups[0].forEach(seg => {
            group1Indices.add(seg.startIdx);
            group1Indices.add(seg.endIdx);
          });
          
          const group2Indices = new Set();
          pathGroups[1].forEach(seg => {
            group2Indices.add(seg.startIdx);
            group2Indices.add(seg.endIdx);
          });
          
          path1Points = pts.filter(pt => group1Indices.has(pt.idx));
          path2Points = pts.filter(pt => group2Indices.has(pt.idx));
          
          const avgBearing1 = pathGroups[0].reduce((sum, s) => sum + s.bearing, 0) / pathGroups[0].length;
          const avgBearing2 = pathGroups[1].reduce((sum, s) => sum + s.bearing, 0) / pathGroups[1].length;
          const crossAngle = angleDiff(avgBearing1, avgBearing2);
          
          method = `Auto-detected paths (${Math.round(avgBearing1)} and ${Math.round(avgBearing2)})`;
          
          // Store quality metrics
          qualityMetrics = {
            ...qualityMetrics,
            crossingAngle: crossAngle,
            avgBearing1: avgBearing1,
            avgBearing2: avgBearing2,
            pathDetectionMethod: 'bearing-based clustering'
          };
        } else {
          // FALLBACK: Best-fit line method
          // Split points roughly in half and fit lines
          const midIdx = Math.floor(pts.length / 2);
          path1Points = pts.slice(0, midIdx);
          path2Points = pts.slice(midIdx);
          method = "Points split at midpoint";
          
          // Estimate crossing angle from split paths
          if (path1Points.length >= 2 && path2Points.length >= 2) {
            const b1 = calcBearing(path1Points[0].dd.lat, path1Points[0].dd.lon, 
                                   path1Points[path1Points.length-1].dd.lat, path1Points[path1Points.length-1].dd.lon);
            const b2 = calcBearing(path2Points[0].dd.lat, path2Points[0].dd.lon,
                                   path2Points[path2Points.length-1].dd.lat, path2Points[path2Points.length-1].dd.lon);
            qualityMetrics = {
              ...qualityMetrics,
              crossingAngle: angleDiff(b1, b2),
              avgBearing1: b1,
              avgBearing2: b2,
              pathDetectionMethod: 'midpoint split (fallback)'
            };
          }
        }
        
        if (path1Points.length < 2 || path2Points.length < 2) {
          alert("Could not detect two distinct paths.\n\nTry marking points more clearly on two different headings.");
          return;
        }
        
        // Calculate closest approach between paths
        let minPathDist = Infinity;
        let closestPair = null;
        path1Points.forEach((p1, i) => {
          path2Points.forEach((p2, j) => {
            const d = Math.sqrt(
              Math.pow((p1.dd.lat - p2.dd.lat) * 60, 2) + 
              Math.pow((p1.dd.lon - p2.dd.lon) * 60 * Math.cos(p1.dd.lat * Math.PI / 180), 2)
            );
            if (d < minPathDist) {
              minPathDist = d;
              closestPair = { p1, p2, i, j };
            }
          });
        });
        qualityMetrics.closestApproachNM = minPathDist;
        
        // === MULTI-METHOD INTERSECTION CALCULATION ===
        // Calculate using multiple methods, then select best based on geometry
        
        const allLats = [...path1Points, ...path2Points].map(p => p.dd.lat);
        const allLons = [...path1Points, ...path2Points].map(p => p.dd.lon);
        const lat0 = allLats.reduce((a, b) => a + b, 0) / allLats.length;
        const cosLat0 = Math.cos(lat0 * Math.PI / 180) || 1;
        
        const project = (lat, lon) => ({ x: lon * cosLat0, y: lat });
        const unproject = (x, y) => ({ lat: y, lon: x / cosLat0 });
        
        // Data bounds for validation
        const dataMinX = Math.min(...allLons) * cosLat0;
        const dataMaxX = Math.max(...allLons) * cosLat0;
        const dataMinY = Math.min(...allLats);
        const dataMaxY = Math.max(...allLats);
        const dataRangeX = dataMaxX - dataMinX;
        const dataRangeY = dataMaxY - dataMinY;
        const margin = 2;
        
        const isInBounds = (x, y) => 
          x >= dataMinX - margin * dataRangeX && x <= dataMaxX + margin * dataRangeX &&
          y >= dataMinY - margin * dataRangeY && y <= dataMaxY + margin * dataRangeY;
        
        // Helper: Line intersection from two points each
        const intersectTwoPointLines = (p1a, p1b, p2a, p2b) => {
          const a1 = project(p1a.dd.lat, p1a.dd.lon);
          const a2 = project(p1b.dd.lat, p1b.dd.lon);
          const b1 = project(p2a.dd.lat, p2a.dd.lon);
          const b2 = project(p2b.dd.lat, p2b.dd.lon);
          
          const x1 = a1.x, y1 = a1.y, x2 = a2.x, y2 = a2.y;
          const x3 = b1.x, y3 = b1.y, x4 = b2.x, y4 = b2.y;
          
          const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
          if (Math.abs(denom) < 1e-12) return null;
          
          const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
          const ix = x1 + t * (x2 - x1);
          const iy = y1 + t * (y2 - y1);
          
          if (!isInBounds(ix, iy)) return null;
          
          const result = unproject(ix, iy);
          return { lat: result.lat, lon: result.lon };
        };
        
        // PCA-based line fitting with center weighting
        const fitLinePCA = (points) => {
          const n = points.length;
          const center = (n - 1) / 2;
          const sigma = n / 2.5;
          
          const projected = points.map((p, i) => {
            const weight = Math.exp(-Math.pow((i - center) / sigma, 2));
            return { ...project(p.dd.lat, p.dd.lon), weight };
          });
          
          const totalWeight = projected.reduce((sum, p) => sum + p.weight, 0);
          const cx = projected.reduce((sum, p) => sum + p.x * p.weight, 0) / totalWeight;
          const cy = projected.reduce((sum, p) => sum + p.y * p.weight, 0) / totalWeight;
          
          let cxx = 0, cxy = 0, cyy = 0;
          projected.forEach(p => {
            const dx = p.x - cx;
            const dy = p.y - cy;
            cxx += p.weight * dx * dx;
            cxy += p.weight * dx * dy;
            cyy += p.weight * dy * dy;
          });
          
          const trace = cxx + cyy;
          const det = cxx * cyy - cxy * cxy;
          const discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));
          const lambda1 = trace / 2 + discriminant;
          
          let dx, dy;
          if (Math.abs(cxy) > 1e-12) {
            dx = lambda1 - cyy;
            dy = cxy;
          } else if (cxx >= cyy) {
            dx = 1; dy = 0;
          } else {
            dx = 0; dy = 1;
          }
          
          const len = Math.sqrt(dx * dx + dy * dy);
          dx /= len; dy /= len;
          
          const a = -dy;
          const b = dx;
          const c = -(a * cx + b * cy);
          
          return { a, b, c, cx, cy };
        };
        
        // Calculate all methods
        const methods = [];
        
        // METHOD 1: Endpoints
        const endpointsResult = intersectTwoPointLines(
          path1Points[0], path1Points[path1Points.length - 1],
          path2Points[0], path2Points[path2Points.length - 1]
        );
        if (endpointsResult) {
          methods.push({
            name: 'Endpoints',
            lat: endpointsResult.lat,
            lon: endpointsResult.lon,
            description: 'Line through first and last points of each path'
          });
        }
        
        // METHOD 2: PCA Center-Weighted
        const line1 = fitLinePCA(path1Points);
        const line2 = fitLinePCA(path2Points);
        const pcaDet = line1.a * line2.b - line2.a * line1.b;
        
        if (Math.abs(pcaDet) >= 1e-12) {
          const pcaIx = (line1.b * line2.c - line2.b * line1.c) / pcaDet;
          const pcaIy = (line2.a * line1.c - line1.a * line2.c) / pcaDet;
          
          if (isInBounds(pcaIx, pcaIy)) {
            const pcaResult = unproject(pcaIx, pcaIy);
            methods.push({
              name: 'PCA Center-Weighted',
              lat: pcaResult.lat,
              lon: pcaResult.lon,
              description: 'Best-fit lines weighted toward center of each path'
            });
          }
        }
        
        // METHOD 3: Midpoints (middle segment of each path)
        if (path1Points.length >= 3 && path2Points.length >= 3) {
          const mid1 = Math.floor(path1Points.length / 2);
          const mid2 = Math.floor(path2Points.length / 2);
          const midpointsResult = intersectTwoPointLines(
            path1Points[mid1 - 1], path1Points[mid1 + 1 < path1Points.length ? mid1 + 1 : mid1],
            path2Points[mid2 - 1], path2Points[mid2 + 1 < path2Points.length ? mid2 + 1 : mid2]
          );
          if (midpointsResult) {
            methods.push({
              name: 'Midpoints',
              lat: midpointsResult.lat,
              lon: midpointsResult.lon,
              description: 'Line through middle portion of each path'
            });
          }
        }
        
        // METHOD 4: Closest Approach (always available as fallback)
        const closestApproachResult = {
          name: 'Closest Approach',
          lat: (closestPair.p1.dd.lat + closestPair.p2.dd.lat) / 2,
          lon: (closestPair.p1.dd.lon + closestPair.p2.dd.lon) / 2,
          description: `Midpoint where paths come within ${minPathDist.toFixed(3)} NM`
        };
        methods.push(closestApproachResult);
        
        // Store all methods for transparency
        qualityMetrics.methodsCompared = methods;
        
        // SELECT BEST METHOD based on crossing angle
        let selectedMethod;
        let finalLat, finalLon, finalMethodName;
        
        const crossAngle = qualityMetrics.crossingAngle;
        
        if (crossAngle < 15) {
          // Very shallow angle - use closest approach only
          selectedMethod = methods.find(m => m.name === 'Closest Approach');
          finalMethodName = 'Closest Approach (shallow angle fallback)';
        } else if (crossAngle < 30) {
          // Shallow angle - prefer closest approach but check if methods agree
          const lineResults = methods.filter(m => m.name !== 'Closest Approach');
          if (lineResults.length >= 2) {
            // Check if line methods are consistent (within 0.1 NM of each other)
            const spread = Math.max(...lineResults.map(m1 => 
              Math.max(...lineResults.map(m2 => 
                Math.sqrt(Math.pow((m1.lat - m2.lat) * 60, 2) + Math.pow((m1.lon - m2.lon) * 60 * cosLat0, 2))
              ))
            ));
            if (spread < 0.1) {
              // Methods agree - use PCA or Endpoints
              selectedMethod = methods.find(m => m.name === 'Endpoints') || methods.find(m => m.name === 'PCA Center-Weighted');
              finalMethodName = selectedMethod.name + ' (methods consistent)';
            } else {
              // Methods disagree - use closest approach
              selectedMethod = methods.find(m => m.name === 'Closest Approach');
              finalMethodName = 'Closest Approach (line methods inconsistent)';
            }
          } else {
            selectedMethod = methods.find(m => m.name === 'Closest Approach');
            finalMethodName = 'Closest Approach (insufficient line solutions)';
          }
        } else if (crossAngle >= 75) {
          // Excellent geometry - prefer Endpoints (historically most accurate at 90)
          selectedMethod = methods.find(m => m.name === 'Endpoints') || methods.find(m => m.name === 'PCA Center-Weighted');
          finalMethodName = selectedMethod.name + ' (excellent geometry)';
        } else {
          // Good geometry (30-75) - use PCA center-weighted
          selectedMethod = methods.find(m => m.name === 'PCA Center-Weighted') || methods.find(m => m.name === 'Endpoints');
          finalMethodName = selectedMethod ? selectedMethod.name : 'Closest Approach';
          if (!selectedMethod) {
            selectedMethod = methods.find(m => m.name === 'Closest Approach');
            finalMethodName = 'Closest Approach (no line solution)';
          }
        }
        
        finalLat = selectedMethod.lat;
        finalLon = selectedMethod.lon;
        
        // Store analysis for display
        setCrosshairAnalysis({
          path1Points,
          path2Points,
          method,
          totalPoints: crosshairPoints.length,
          qualityMetrics,
          selectedMethodName: finalMethodName
        });

        const latDdm = gpsUtils.ddToDdm(finalLat);
        const lonDdm = gpsUtils.ddToDdm(Math.abs(finalLon));

        // Build result
        const grid = gpsUtils.calculateCapGrid(finalLat, finalLon);
        const ddText = gpsUtils.formatDd(finalLat, finalLon);
        const ddmText = gpsUtils.formatDdm(finalLat, finalLon);
        const dmsText = gpsUtils.formatDms(finalLat, finalLon);

        targetSeqRef.current = (targetSeqRef.current || 0) + 1;
        const targetLabel = "Target #" + targetSeqRef.current;
        
        // Calculate quality score (0-100) with aggressive penalty for shallow angles
        let angleScore;
        if (crossAngle < 15) {
          angleScore = crossAngle * 2; // 0-30 points for <15
        } else if (crossAngle < 30) {
          angleScore = 30 + (crossAngle - 15) * 2; // 30-60 points for 15-30
        } else {
          angleScore = Math.min(100, (crossAngle / 90) * 100); // Normal scaling for >30
        }
        
        const pointsScore = Math.min(100, ((path1Points.length + path2Points.length) / 10) * 100);
        const approachScore = qualityMetrics.closestApproachNM < 0.1 ? 100 : 
                              qualityMetrics.closestApproachNM < 0.2 ? 75 :
                              qualityMetrics.closestApproachNM < 0.5 ? 50 : 25;
        const qualityScore = Math.round((angleScore * 0.6) + (pointsScore * 0.15) + (approachScore * 0.25));
        
        // Quality rating with expected accuracy
        let qualityRating, qualityColor, expectedAccuracy;
        if (qualityScore >= 80) {
          qualityRating = 'EXCELLENT';
          qualityColor = '#38a169';
          expectedAccuracy = '<200 ft';
        } else if (qualityScore >= 60) {
          qualityRating = 'GOOD';
          qualityColor = '#68d391';
          expectedAccuracy = '200-1000 ft';
        } else if (qualityScore >= 40) {
          qualityRating = 'FAIR';
          qualityColor = '#d69e2e';
          expectedAccuracy = '1000-3000 ft';
        } else {
          qualityRating = 'POOR';
          qualityColor = '#e53e3e';
          expectedAccuracy = '>3000 ft - Re-fly recommended';
        }

        const resultObj = {
          latDeg: latDdm.deg,
          latMin: latDdm.min.toFixed(3),
          lonDeg: lonDdm.deg,
          lonMin: lonDdm.min.toFixed(3),
          latDD: finalLat,
          lonDD: finalLon,
          timestamp: getZuluTimeOnly(),
          method: finalMethodName,
          capGrid: grid.full,
          ddText,
          ddmText,
          dmsText,
          targetLabel,
          path1Count: path1Points.length,
          path2Count: path2Points.length,
          // Quality metrics
          crossingAngle: qualityMetrics.crossingAngle,
          closestApproachNM: qualityMetrics.closestApproachNM,
          avgBearing1: qualityMetrics.avgBearing1,
          avgBearing2: qualityMetrics.avgBearing2,
          pathDetectionMethod: qualityMetrics.pathDetectionMethod,
          qualityScore,
          qualityRating,
          qualityColor,
          expectedAccuracy,
          methodsCompared: qualityMetrics.methodsCompared,
          usedFallback: finalMethodName.includes('fallback') || finalMethodName.includes('Closest Approach')
        };

        setCrosshairResult(resultObj);
        
        // Store analysis reference for export functions
        const analysisRef = {
          path1Points,
          path2Points,
          method,
          totalPoints: crosshairPoints.length,
          qualityMetrics,
          selectedMethodName: finalMethodName
        };
        setCrosshairAnalysis(analysisRef);

        // Auto-add to events with comprehensive logging
        eventSeqRef.current = (eventSeqRef.current || 1) + 1;
        const fullNotes = addCalculationToLog(resultObj, analysisRef);
        
        const newEvent = {
          id: Date.now() + Math.random(),
          eventNum: eventSeqRef.current,
          eventType: "Target Position Calculated",
          timeZ: resultObj.timestamp,
          latDeg: resultObj.latDeg.toString(),
          latMin: resultObj.latMin,
          longDeg: resultObj.lonDeg.toString(),
          longMin: resultObj.lonMin,
          altMSL: "",
          altAGL: "",
          heading: "",
          airspeed: "",
          groundSpeed: "",
          capGrid: resultObj.capGrid,
          notes: fullNotes
        };
        setEvents([newEvent, ...events]);

        // Cockpit feedback
        alert(
          resultObj.targetLabel + "\n" +
          "Quality: " + resultObj.qualityRating + " (" + resultObj.qualityScore + "%)\n" +
          "Expected: " + resultObj.expectedAccuracy + "\n\n" +
          "CAP Grid: " + resultObj.capGrid + "\n" +
          "DD: " + resultObj.ddText + "\n" +
          "DDM: " + resultObj.ddmText + "\n" +
          "DMS: " + resultObj.dmsText
        );
      };

      const addCurrentPosition = () => {
        if (!navigator.geolocation) {
          alert("GPS not supported");
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const lat = pos.coords.latitude;
            const lon = Math.abs(pos.coords.longitude);
            const latDdm = gpsUtils.ddToDdm(lat);
            const lonDdm = gpsUtils.ddToDdm(lon);
            const point = {
              id: Date.now(),
              latDeg: latDdm.deg.toString(),
              latMin: latDdm.min.toFixed(3),
              lonDeg: lonDdm.deg.toString(),
              lonMin: lonDdm.min.toFixed(3),
              time: getZuluTimeOnly()
            };
            setCrosshairPoints(prev => [...prev, point]);
            setCrosshairResult(null); // Clear previous result when adding new points
            setCrosshairAnalysis(null);
          },
          (err) => alert("GPS Error: " + err.message),
          { enableHighAccuracy: true, timeout: 1e4 }
        );
      };
      
      const clearAllPoints = () => {
        setCrosshairPoints([]);
        setCrosshairResult(null);
        setCrosshairAnalysis(null);
      };
      
      const removePoint = (id) => {
        setCrosshairPoints(prev => prev.filter(pt => pt.id !== id));
        setCrosshairResult(null);
        setCrosshairAnalysis(null);
      };
      
      // Import KML/KMZ/GPX file for crosshair analysis
      const importCrosshairFile = async (file) => {
        try {
          let points = [];
          const fileName = file.name.toLowerCase();
          
          if (fileName.endsWith('.kmz')) {
            // KMZ is a zipped KML
            const arrayBuffer = await file.arrayBuffer();
            const JSZip = window.JSZip;
            if (!JSZip) {
              alert('Loading JSZip library... Please try again.');
              const script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
              document.head.appendChild(script);
              return;
            }
            const zip = await JSZip.loadAsync(arrayBuffer);
            const kmlFile = zip.file(/\.kml$/i)[0];
            if (!kmlFile) {
              alert('No KML file found in KMZ archive');
              return;
            }
            const kmlText = await kmlFile.async('text');
            points = parseKmlForCrosshair(kmlText);
          } else if (fileName.endsWith('.kml')) {
            const kmlText = await file.text();
            points = parseKmlForCrosshair(kmlText);
          } else if (fileName.endsWith('.gpx')) {
            const gpxText = await file.text();
            points = parseGpxForCrosshair(gpxText);
          } else if (fileName.endsWith('.csv') || fileName.endsWith('.txt')) {
            const csvText = await file.text();
            points = parseCsvForCrosshair(csvText);
          } else {
            alert('Unsupported file format. Please use KML, KMZ, GPX, or CSV.');
            return;
          }
          
          if (points.length < 4) {
            alert('Need at least 4 points for analysis. Found ' + points.length + ' points.');
            return;
          }
          
          // Convert to crosshair point format
          const crosshairPts = points.map((pt, i) => {
            const latDdm = gpsUtils.ddToDdm(pt.lat);
            const lonDdm = gpsUtils.ddToDdm(Math.abs(pt.lon));
            return {
              id: Date.now() + i,
              latDeg: latDdm.deg.toString(),
              latMin: latDdm.min.toFixed(3),
              lonDeg: lonDdm.deg.toString(),
              lonMin: lonDdm.min.toFixed(3),
              time: pt.time || getZuluTimeOnly()
            };
          });
          
          setCrosshairPoints(crosshairPts);
          setCrosshairResult(null);
          setCrosshairAnalysis(null);
          alert('Imported ' + crosshairPts.length + ' points from ' + file.name + '\n\nReview the points, then tap CALCULATE.');
        } catch (err) {
          alert('Error importing file: ' + err.message);
        }
      };
      
      // Parse KML file for track points
      const parseKmlForCrosshair = (kmlText) => {
        const parser = new DOMParser();
        const kml = parser.parseFromString(kmlText, 'text/xml');
        const points = [];
        
        // Try gx:Track coordinates
        const gxCoords = kml.querySelectorAll('gx\\:coord, coord');
        const whenElements = kml.querySelectorAll('when');
        
        if (gxCoords.length > 0) {
          gxCoords.forEach((coord, i) => {
            const parts = coord.textContent.trim().split(/\s+/);
            if (parts.length >= 2) {
              const lon = parseFloat(parts[0]);
              const lat = parseFloat(parts[1]);
              if (!isNaN(lat) && !isNaN(lon)) {
                let time = getZuluTimeOnly();
                if (whenElements[i]) {
                  const dt = new Date(whenElements[i].textContent);
                  if (!isNaN(dt.getTime())) {
                    time = dt.toISOString().substr(11, 8);
                  }
                }
                points.push({ lat, lon, time });
              }
            }
          });
        }
        
        // Try LineString coordinates
        if (points.length === 0) {
          const coordElements = kml.querySelectorAll('coordinates');
          coordElements.forEach(coordEl => {
            const coordText = coordEl.textContent.trim();
            const coordPairs = coordText.split(/\s+/);
            coordPairs.forEach(pair => {
              const parts = pair.split(',');
              if (parts.length >= 2) {
                const lon = parseFloat(parts[0]);
                const lat = parseFloat(parts[1]);
                if (!isNaN(lat) && !isNaN(lon)) {
                  points.push({ lat, lon, time: getZuluTimeOnly() });
                }
              }
            });
          });
        }
        
        // Try Placemarks with Point
        if (points.length === 0) {
          const placemarks = kml.querySelectorAll('Placemark');
          placemarks.forEach(pm => {
            const pointCoord = pm.querySelector('Point coordinates');
            if (pointCoord) {
              const parts = pointCoord.textContent.trim().split(',');
              if (parts.length >= 2) {
                const lon = parseFloat(parts[0]);
                const lat = parseFloat(parts[1]);
                if (!isNaN(lat) && !isNaN(lon)) {
                  points.push({ lat, lon, time: getZuluTimeOnly() });
                }
              }
            }
          });
        }
        
        return points;
      };
      
      // Parse GPX file for track points
      const parseGpxForCrosshair = (gpxText) => {
        const parser = new DOMParser();
        const gpx = parser.parseFromString(gpxText, 'text/xml');
        const points = [];
        
        // Track points
        const trkpts = gpx.querySelectorAll('trkpt');
        trkpts.forEach(pt => {
          const lat = parseFloat(pt.getAttribute('lat'));
          const lon = parseFloat(pt.getAttribute('lon'));
          if (!isNaN(lat) && !isNaN(lon)) {
            let time = getZuluTimeOnly();
            const timeEl = pt.querySelector('time');
            if (timeEl) {
              const dt = new Date(timeEl.textContent);
              if (!isNaN(dt.getTime())) {
                time = dt.toISOString().substr(11, 8);
              }
            }
            points.push({ lat, lon, time });
          }
        });
        
        // Waypoints
        const wpts = gpx.querySelectorAll('wpt');
        wpts.forEach(pt => {
          const lat = parseFloat(pt.getAttribute('lat'));
          const lon = parseFloat(pt.getAttribute('lon'));
          if (!isNaN(lat) && !isNaN(lon)) {
            points.push({ lat, lon, time: getZuluTimeOnly() });
          }
        });
        
        return points;
      };
      
      // Parse CSV file for coordinates
      const parseCsvForCrosshair = (csvText) => {
        const points = [];
        const lines = csvText.trim().split('\n');
        
        lines.forEach((line, i) => {
          // Skip header row if it looks like headers
          if (i === 0 && (line.toLowerCase().includes('lat') || line.toLowerCase().includes('lon'))) {
            return;
          }
          
          const parts = line.split(/[,\t]/);
          if (parts.length >= 2) {
            // Try to find lat/lon values
            let lat = null, lon = null;
            parts.forEach(p => {
              const val = parseFloat(p.trim());
              if (!isNaN(val)) {
                if (val >= -90 && val <= 90 && lat === null) {
                  lat = val;
                } else if (val >= -180 && val <= 180 && lon === null) {
                  lon = val;
                }
              }
            });
            if (lat !== null && lon !== null) {
              points.push({ lat, lon, time: getZuluTimeOnly() });
            }
          }
        });
        
        return points;
      };
      
      // Copy intersection to clipboard
      const copyIntersection = () => {
        if (!crosshairResult) return;
        const text = 
          crosshairResult.targetLabel + '\n' +
          'CAP Grid: ' + crosshairResult.capGrid + '\n' +
          'DD: ' + crosshairResult.ddText + '\n' +
          'DDM: ' + crosshairResult.ddmText + '\n' +
          'DMS: ' + crosshairResult.dmsText + '\n' +
          'Quality: ' + crosshairResult.qualityRating + ' (' + crosshairResult.qualityScore + '%)\n' +
          'Expected Accuracy: ' + crosshairResult.expectedAccuracy + '\n' +
          'Crossing Angle: ' + Math.round(crosshairResult.crossingAngle) + '\n' +
          'Method: ' + crosshairResult.method;
        
        navigator.clipboard.writeText(text).then(() => {
          alert('Copied to clipboard!');
        }).catch(() => {
          // Fallback for older browsers
          const textarea = document.createElement('textarea');
          textarea.value = text;
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand('copy');
          document.body.removeChild(textarea);
          alert('Copied to clipboard!');
        });
      };
      
      // Export to ForeFlight (creates a FPL file or opens ForeFlight URL)
      const exportToForeflight = () => {
        if (!crosshairResult) return;
        
        // ForeFlight URL scheme for creating a waypoint
        const lat = crosshairResult.latDD;
        const lon = crosshairResult.lonDD;
        const name = 'TGT' + (targetSeqRef.current || 1);
        
        // Try ForeFlight URL scheme first (works on iOS/iPad)
        const foreflightUrl = 'foreflight://maps/search?q=' + lat.toFixed(6) + ',' + lon.toFixed(6);
        
        // Also create a GPX file as backup
        const gpxContent = '<?xml version="1.0" encoding="UTF-8"?>\n' +
          '<gpx version="1.1" creator="MAT Crosshair">\n' +
          '  <wpt lat="' + lat.toFixed(6) + '" lon="' + lon.toFixed(6) + '">\n' +
          '    <name>' + name + '</name>\n' +
          '    <desc>' + crosshairResult.targetLabel + ' - ' + crosshairResult.qualityRating + ' (' + crosshairResult.qualityScore + '%)</desc>\n' +
          '  </wpt>\n' +
          '</gpx>';
        
        // Create download link
        const blob = new Blob([gpxContent], { type: 'application/gpx+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = name + '_' + crosshairResult.capGrid.replace(/\s+/g, '-') + '.gpx';
        
        // Ask user which method
        if (confirm('Export to ForeFlight:\n\n OK = Open in ForeFlight app (iOS/iPad)\n Cancel = Download GPX file\n\nNote: GPX can be imported into ForeFlight via Files app.')) {
          window.location.href = foreflightUrl;
        } else {
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
      };
      
      // View on map with flight tracks - styled like Command Module maps
      // Standard Map Colors (high visibility on OSM):
      // - Flight tracks/paths: #000000 (black) weight 3-4
      // - Grid boundaries: #ff00ff (magenta) weight 3, dashed
      // - Target/POI markers: #e53e3e (red)
      // - Uncertainty areas: #000000 (black) dashed, low fill opacity
      // - Path 1: #0066cc (dark blue) 
      // - Path 2: #006600 (dark green)
      // - Data points: white fill with colored border
      const generateCrosshairMapHtml = () => {
        if (!crosshairResult || !crosshairAnalysis) return '';
        
        const path1Coords = crosshairAnalysis.path1Points.map(p => [p.dd.lat, p.dd.lon]);
        const path2Coords = crosshairAnalysis.path2Points.map(p => [p.dd.lat, p.dd.lon]);
        const targetLat = crosshairResult.latDD;
        const targetLon = crosshairResult.lonDD;
        
        // Standard map colors
        const mapColors = {
          path1: '#0066cc',      // Dark blue - high visibility
          path2: '#006600',      // Dark green - high visibility
          target: '#cc0000',     // Dark red
          uncertainty: '#000000', // Black for uncertainty circle
          grid: '#ff00ff'        // Magenta for CAP grid reference
        };
        
        // Calculate expected accuracy circle radius in meters
        let accuracyRadius = 60; // default for excellent
        if (crosshairResult.qualityScore < 40) accuracyRadius = 1000;
        else if (crosshairResult.qualityScore < 60) accuracyRadius = 500;
        else if (crosshairResult.qualityScore < 80) accuracyRadius = 200;
        
        // Quality color for UI elements (not map)
        const qualityColor = crosshairResult.qualityColor || '#f6e05e';
        
        return [
          '<!DOCTYPE html>',
          '<html style="height:100%;margin:0"><head>',
          '<title>Target ' + crosshairResult.targetLabel + ' - ' + crosshairResult.capGrid + '</title>',
          '<meta name="viewport" content="width=device-width, initial-scale=1.0">',
          '<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>',
          '<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></scr' + 'ipt>',
          '<style>',
          'html,body{height:100%;margin:0;padding:0}',
          'body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif}',
          '#map{height:100%;width:100%}',
          '.info-panel{position:absolute;top:10px;right:10px;background:linear-gradient(135deg,rgba(26,32,44,0.95),rgba(45,55,72,0.95));color:#fff;padding:0;border-radius:12px;z-index:1000;max-width:320px;box-shadow:0 4px 20px rgba(0,0,0,0.4);border:2px solid ' + qualityColor + ';overflow:hidden}',
          '.info-header{background:linear-gradient(90deg,rgba(221,107,32,0.3),transparent);padding:12px 16px;border-bottom:1px solid rgba(255,255,255,0.1)}',
          '.info-header h3{margin:0;color:#f6e05e;font-size:16px}',
          '.info-body{padding:16px}',
          '.cap-grid{background:rgba(0,0,0,0.4);padding:12px;border-radius:8px;text-align:center;margin-bottom:12px;border:2px solid #f6e05e}',
          '.cap-grid-label{font-size:10px;color:#a0aec0;text-transform:uppercase;letter-spacing:1px;margin-bottom:4px}',
          '.cap-grid-value{font-size:22px;font-weight:700;color:#f6e05e;font-family:monospace;letter-spacing:2px}',
          '.coords{background:rgba(0,0,0,0.3);padding:10px;border-radius:6px;margin-bottom:12px}',
          '.coord-row{display:flex;justify-content:space-between;font-size:12px;padding:4px 0}',
          '.coord-label{color:#a0aec0}',
          '.coord-value{color:#68d391;font-family:monospace}',
          '.quality-bar{background:rgba(0,0,0,0.3);padding:10px;border-radius:6px;margin-bottom:12px}',
          '.quality-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}',
          '.quality-label{font-size:10px;color:#a0aec0;text-transform:uppercase}',
          '.quality-value{font-size:13px;font-weight:700;color:' + qualityColor + ';padding:2px 8px;background:rgba(0,0,0,0.3);border-radius:4px}',
          '.quality-track{height:6px;background:rgba(255,255,255,0.1);border-radius:3px;overflow:hidden}',
          '.quality-fill{height:100%;background:' + qualityColor + ';border-radius:3px;width:' + crosshairResult.qualityScore + '%}',
          '.quality-stats{display:flex;justify-content:space-between;margin-top:6px;font-size:10px;color:#718096}',
          '.legend{display:flex;gap:12px;justify-content:center;padding:10px;background:rgba(0,0,0,0.2);border-radius:6px;font-size:11px}',
          '.legend-item{display:flex;align-items:center;gap:4px}',
          '.legend-dot{width:10px;height:10px;border-radius:50%}',
          '.legend-line{width:16px;height:3px;border-radius:2px}',
          '@media(max-width:480px){.info-panel{top:auto;bottom:10px;right:10px;left:10px;max-width:none}}',
          '</style>',
          '</head><body>',
          '<div id="map"></div>',
          '<div class="info-panel">',
          '<div class="info-header">',
          '<h3> ' + crosshairResult.targetLabel + '</h3>',
          '</div>',
          '<div class="info-body">',
          '<div class="cap-grid">',
          '<div class="cap-grid-label">CAP Grid</div>',
          '<div class="cap-grid-value">' + crosshairResult.capGrid + '</div>',
          '</div>',
          '<div class="coords">',
          '<div class="coord-row"><span class="coord-label">Latitude N</span><span class="coord-value">' + crosshairResult.latDeg + ' ' + crosshairResult.latMin + "'" + '</span></div>',
          '<div class="coord-row"><span class="coord-label">Longitude W</span><span class="coord-value">' + crosshairResult.lonDeg + ' ' + crosshairResult.lonMin + "'" + '</span></div>',
          '<div class="coord-row"><span class="coord-label">DD</span><span class="coord-value">' + crosshairResult.latDD.toFixed(5) + ', ' + crosshairResult.lonDD.toFixed(5) + '</span></div>',
          '</div>',
          '<div class="quality-bar">',
          '<div class="quality-header">',
          '<span class="quality-label">Solution Quality</span>',
          '<span class="quality-value">' + crosshairResult.qualityRating + ' (' + crosshairResult.qualityScore + '%)</span>',
          '</div>',
          '<div class="quality-track"><div class="quality-fill"></div></div>',
          '<div class="quality-stats">',
          '<span>Crossing: ' + Math.round(crosshairResult.crossingAngle) + '</span>',
          '<span>Expected: ' + crosshairResult.expectedAccuracy + '</span>',
          '</div>',
          '</div>',
          '<div class="legend">',
          '<div class="legend-item"><div class="legend-line" style="background:#0066cc"></div> Path 1 (' + path1Coords.length + ')</div>',
          '<div class="legend-item"><div class="legend-line" style="background:#006600"></div> Path 2 (' + path2Coords.length + ')</div>',
          '<div class="legend-item"><div class="legend-dot" style="background:#cc0000"></div> Target</div>',
          '</div>',
          '</div>',
          '</div>',
          '<scr' + 'ipt>',
          'var map=L.map("map").setView([' + targetLat + ',' + targetLon + '],15);',
          'L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{attribution:"OpenStreetMap"}).addTo(map);',
          // Accuracy/uncertainty circle - black dashed
          'L.circle([' + targetLat + ',' + targetLon + '],{radius:' + accuracyRadius + ',color:"#000000",weight:3,fillColor:"#000000",fillOpacity:0.08,dashArray:"8,6"}).addTo(map);',
          'var path1Coords=' + JSON.stringify(path1Coords) + ';',
          'var path2Coords=' + JSON.stringify(path2Coords) + ';',
          // Path 1 - Dark Blue with thick line
          'var path1=L.polyline(path1Coords,{color:"#0066cc",weight:5,opacity:1.0}).addTo(map);',
          'path1Coords.forEach(function(c,i){L.circleMarker(c,{radius:7,color:"#0066cc",weight:3,fillColor:"#ffffff",fillOpacity:1.0}).bindPopup("Path 1 Point #"+(i+1)).addTo(map);});',
          // Path 2 - Dark Green with thick line
          'var path2=L.polyline(path2Coords,{color:"#006600",weight:5,opacity:1.0}).addTo(map);',
          'path2Coords.forEach(function(c,i){L.circleMarker(c,{radius:7,color:"#006600",weight:3,fillColor:"#ffffff",fillOpacity:1.0}).bindPopup("Path 2 Point #"+(i+1)).addTo(map);});',
          // Target marker - Red with high visibility
          'var targetIcon=L.divIcon({className:"target-marker",html:"<div style=\\"background:#cc0000;color:white;padding:6px 12px;border-radius:6px;font-size:13px;font-weight:bold;white-space:nowrap;box-shadow:0 2px 8px rgba(0,0,0,0.5);border:3px solid white\\">TARGET</div>",iconSize:[80,32],iconAnchor:[40,16]});',
          'L.marker([' + targetLat + ',' + targetLon + '],{icon:targetIcon}).bindPopup("<b>' + crosshairResult.targetLabel + '</b><br>CAP Grid: ' + crosshairResult.capGrid + '<br>' + crosshairResult.ddmText + '").addTo(map).openPopup();',
          'var allPoints=path1Coords.concat(path2Coords);allPoints.push([' + targetLat + ',' + targetLon + ']);',
          'map.fitBounds(allPoints,{padding:[50,50]});',
          '</scr' + 'ipt>',
          '</body></html>'
        ].join('\n');
      };
      
      // Show map inline
      const viewOnMapWithTracks = () => {
        if (!crosshairResult || !crosshairAnalysis) return;
        const html = generateCrosshairMapHtml();
        setCrosshairMapHtml(html);
        setCrosshairShowMap(true);
      };
      
      // Pop out map to new window
      const popOutCrosshairMap = () => {
        const html = crosshairMapHtml || generateCrosshairMapHtml();
        const mapWindow = window.open('', '_blank');
        if (mapWindow) {
          mapWindow.document.write(html);
          mapWindow.document.close();
        } else {
          alert('Please allow popups to view the map.');
        }
      };
      
      // Add calculation to mission log with all details
      const addCalculationToLog = (resultObj, analysis) => {
        // Build comprehensive notes with all data points
        let pointsList = 'DATA POINTS USED:\n';
        
        if (analysis && analysis.path1Points) {
          pointsList += '\nPath 1 (bearing ~' + Math.round(resultObj.avgBearing1) + '):\n';
          analysis.path1Points.forEach((pt, i) => {
            pointsList += '  #' + (i+1) + ': ' + pt.dd.lat.toFixed(5) + ', ' + pt.dd.lon.toFixed(5) + '\n';
          });
        }
        
        if (analysis && analysis.path2Points) {
          pointsList += '\nPath 2 (bearing ~' + Math.round(resultObj.avgBearing2) + '):\n';
          analysis.path2Points.forEach((pt, i) => {
            pointsList += '  #' + (i+1) + ': ' + pt.dd.lat.toFixed(5) + ', ' + pt.dd.lon.toFixed(5) + '\n';
          });
        }
        
        // Methods comparison
        let methodsText = '\nMETHODS COMPARED:\n';
        if (resultObj.methodsCompared) {
          resultObj.methodsCompared.forEach(m => {
            const selected = resultObj.method.includes(m.name) ? ' ' : '  ';
            methodsText += selected + m.name + ': ' + m.lat.toFixed(5) + ', ' + m.lon.toFixed(5) + '\n';
          });
        }
        
        const fullNotes = resultObj.targetLabel + ' (Crosshair Intersection)\n' +
          '\n' +
          'RESULT:\n' +
          '  CAP Grid: ' + resultObj.capGrid + '\n' +
          '  DD: ' + resultObj.ddText + '\n' +
          '  DDM: ' + resultObj.ddmText + '\n' +
          '  DMS: ' + resultObj.dmsText + '\n' +
          '\nQUALITY ASSESSMENT:\n' +
          '  Rating: ' + resultObj.qualityRating + ' (' + resultObj.qualityScore + '%)\n' +
          '  Expected Accuracy: ' + resultObj.expectedAccuracy + '\n' +
          '  Crossing Angle: ' + Math.round(resultObj.crossingAngle) + '\n' +
          '  Path Separation: ' + resultObj.closestApproachNM.toFixed(3) + ' NM\n' +
          '\nMETHOD:\n' +
          '  ' + resultObj.method + '\n' +
          '  Path Detection: ' + resultObj.pathDetectionMethod + '\n' +
          methodsText +
          pointsList;
        
        return fullNotes;
      };

      // Get status indicator
      const getStatusInfo = () => {
        const count = crosshairPoints.length;
        if (count === 0) return { color: "#718096", text: "No points marked", ready: false };
        if (count === 1) return { color: "#e53e3e", text: "1 point - need 3+ more", ready: false };
        if (count === 2) return { color: "#e53e3e", text: "2 points - need 2+ more", ready: false };
        if (count === 3) return { color: "#d69e2e", text: "3 points - need 1+ more", ready: false };
        return { color: "#38a169", text: count + " points - READY", ready: true };
      };
      
      const status = getStatusInfo();

      return React.createElement("div", null,
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, "\u{1F3AF} Crosshair Target Locator"),
          React.createElement("div", { style: styles.sectionBody },
            // Instructions
            React.createElement("div", { style: {
              background: "rgba(99,179,237,0.1)",
              padding: "14px",
              borderRadius: "10px",
              marginBottom: "16px",
              border: "1px solid rgba(99,179,237,0.2)"
            } },
              React.createElement("p", { style: { margin: 0, fontSize: ts("13"), color: "#a0aec0", lineHeight: "1.5" } },
                React.createElement("strong", { style: { color: "#63b3ed" } }, "How to use:"),
                React.createElement("br", null),
                React.createElement("strong", { style: { color: "#f6e05e" } }, "1."),
                " Fly over target, ",
                React.createElement("strong", null, "hold steady heading"),
                ", tap MARK 3-5 times",
                React.createElement("br", null),
                React.createElement("strong", { style: { color: "#f6e05e" } }, "2."),
                " Turn 60-90 and fly back over target, tap MARK 3-5 times",
                React.createElement("br", null),
                React.createElement("strong", { style: { color: "#f6e05e" } }, "3."),
                " Tap CALCULATE",
                React.createElement("br", null),
                React.createElement("br", null),
                React.createElement("span", { style: { fontSize: ts("11"), color: "#718096" } },
                  "\u{2139}\uFE0F Best results: 90 crossing angle, consistent heading on each pass, mark points near target"
                )
              )
            ),
            
            // Status indicator
            React.createElement("div", { style: {
              background: "rgba(0,0,0,0.3)",
              padding: "12px 16px",
              borderRadius: "10px",
              marginBottom: "16px",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              border: "2px solid " + status.color
            } },
              React.createElement("span", { style: { fontSize: ts("14"), fontWeight: "700", color: status.color } },
                "\u{1F4CD} " + status.text
              ),
              crosshairPoints.length > 0 && React.createElement("button", {
                onClick: clearAllPoints,
                style: {
                  background: "rgba(229,62,62,0.2)",
                  border: "1px solid #e53e3e",
                  borderRadius: "6px",
                  padding: "6px 12px",
                  color: "#fc8181",
                  fontSize: ts("11"),
                  fontWeight: "600",
                  cursor: "pointer"
                }
              }, "CLEAR ALL")
            ),
            
            // MARK POSITION button and Import row
            React.createElement("div", { style: { display: "flex", gap: "10px", marginBottom: "16px" } },
              React.createElement("button", {
                onClick: addCurrentPosition,
                style: {
                  flex: 2,
                  minHeight: "80px",
                  padding: "20px",
                  fontSize: ts("20"),
                  fontWeight: "700",
                  background: "linear-gradient(135deg, #3182ce, #2b6cb0)",
                  border: "none",
                  borderRadius: "12px",
                  color: "#fff",
                  fontFamily: "inherit",
                  cursor: "pointer",
                  touchAction: "manipulation",
                  boxShadow: "0 4px 15px rgba(0,0,0,0.3)"
                }
              }, "\u{1F4CD} MARK"),
              React.createElement("label", {
                style: {
                  flex: 1,
                  minHeight: "80px",
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                  justifyContent: "center",
                  padding: "10px",
                  fontSize: ts("12"),
                  fontWeight: "700",
                  background: "linear-gradient(135deg, #805ad5, #6b46c1)",
                  border: "none",
                  borderRadius: "12px",
                  color: "#fff",
                  fontFamily: "inherit",
                  cursor: "pointer",
                  touchAction: "manipulation",
                  boxShadow: "0 4px 15px rgba(0,0,0,0.3)"
                }
              },
                React.createElement("span", { style: { fontSize: ts("24"), marginBottom: "4px" } }, "\u{1F4C2}"),
                React.createElement("span", null, "IMPORT"),
                React.createElement("span", { style: { fontSize: ts("9"), opacity: 0.8 } }, "KML/GPX"),
                React.createElement("input", {
                  type: "file",
                  accept: ".kml,.kmz,.gpx,.csv,.txt",
                  style: { display: "none" },
                  onChange: (e) => {
                    if (e.target.files && e.target.files[0]) {
                      importCrosshairFile(e.target.files[0]);
                      e.target.value = '';
                    }
                  }
                })
              )
            ),
            
            // Points list
            React.createElement("div", { style: { marginBottom: "16px" } },
              React.createElement("div", { style: { fontSize: ts("12"), fontWeight: "700", color: "#63b3ed", marginBottom: "8px", textTransform: "uppercase" } },
                "Marked Points (" + crosshairPoints.length + ")"
              ),
              React.createElement("div", { style: { background: "rgba(0,0,0,0.2)", borderRadius: "8px", padding: "10px", maxHeight: "180px", overflowY: "auto" } },
                crosshairPoints.length === 0 
                  ? React.createElement("div", { style: { color: "#718096", fontSize: ts("12"), textAlign: "center", padding: "20px" } }, "No points marked yet")
                  : crosshairPoints.map((pt, i) => React.createElement("div", { 
                      key: pt.id, 
                      style: { 
                        fontSize: ts("12"), 
                        color: "#e2e8f0", 
                        padding: "8px", 
                        borderBottom: "1px solid rgba(255,255,255,0.05)",
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "center"
                      } 
                    },
                      React.createElement("span", null,
                        React.createElement("span", { style: { color: "#f6e05e", fontWeight: "700" } }, "#" + (i + 1) + " "),
                        pt.time + "Z  N " + pt.latDeg + " " + pt.latMin + "' W " + pt.lonDeg + " " + pt.lonMin + "'"
                      ),
                      React.createElement("button", {
                        onClick: () => removePoint(pt.id),
                        style: {
                          background: "transparent",
                          border: "none",
                          color: "#fc8181",
                          cursor: "pointer",
                          padding: "4px 8px",
                          fontSize: ts("14")
                        }
                      }, "")
                    ))
              )
            ),
            
            // Analysis info (shown after calculation)
            crosshairAnalysis && React.createElement("div", { style: {
              background: "rgba(99,179,237,0.1)",
              padding: "12px",
              borderRadius: "8px",
              marginBottom: "16px",
              border: "1px solid rgba(99,179,237,0.3)"
            } },
              React.createElement("div", { style: { fontSize: ts("11"), color: "#63b3ed", fontWeight: "700", marginBottom: "4px" } }, "PATH DETECTION"),
              React.createElement("div", { style: { fontSize: ts("12"), color: "#a0aec0" } },
                "Path 1: " + crosshairAnalysis.path1Points.length + " points  Path 2: " + crosshairAnalysis.path2Points.length + " points"
              ),
              React.createElement("div", { style: { fontSize: ts("11"), color: "#718096", marginTop: "4px" } }, crosshairAnalysis.method)
            ),
            
            // CALCULATE button
            React.createElement("button", {
              onClick: analyzeAndCalculate,
              disabled: !status.ready,
              style: {
                width: "100%",
                minHeight: "64px",
                marginBottom: "16px",
                padding: "18px",
                fontSize: ts("16"),
                fontWeight: "700",
                background: status.ready ? "linear-gradient(135deg, #d69e2e, #b7791f)" : "rgba(255,255,255,0.1)",
                border: "none",
                borderRadius: "12px",
                color: status.ready ? "#fff" : "#718096",
                fontFamily: "inherit",
                cursor: status.ready ? "pointer" : "not-allowed",
                touchAction: "manipulation"
              }
            }, "\u{1F3AF} CALCULATE INTERSECTION"),
            
            // Result display
            crosshairResult && React.createElement("div", { style: {
              background: "linear-gradient(135deg, rgba(246,224,94,0.15), rgba(237,137,54,0.1))",
              borderRadius: "12px",
              padding: "20px",
              border: "2px solid #f6e05e"
            } },
              React.createElement("div", { style: { textAlign: "center", marginBottom: "16px" } },
                React.createElement("div", { style: { fontSize: ts("14"), color: "#a0aec0", marginBottom: "4px" } }, "\u{1F3AF} TARGET LOCATION"),
                React.createElement("div", { style: { fontSize: ts("11"), color: "#718096" } }, crosshairResult.timestamp + "Z")
              ),
              
              // Quality Indicator
              React.createElement("div", { style: { 
                background: "rgba(0,0,0,0.3)", 
                padding: "12px", 
                borderRadius: "8px", 
                marginBottom: "16px",
                border: "2px solid " + crosshairResult.qualityColor
              } },
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "8px" } },
                  React.createElement("span", { style: { fontSize: ts("11"), color: "#a0aec0", fontWeight: "600" } }, "SOLUTION QUALITY"),
                  React.createElement("span", { style: { 
                    fontSize: ts("14"), 
                    fontWeight: "700", 
                    color: crosshairResult.qualityColor,
                    padding: "4px 12px",
                    background: "rgba(0,0,0,0.3)",
                    borderRadius: "4px"
                  } }, crosshairResult.qualityRating + " (" + crosshairResult.qualityScore + "%)")
                ),
                // Quality bar
                React.createElement("div", { style: { 
                  height: "8px", 
                  background: "rgba(255,255,255,0.1)", 
                  borderRadius: "4px",
                  overflow: "hidden"
                } },
                  React.createElement("div", { style: { 
                    width: crosshairResult.qualityScore + "%", 
                    height: "100%", 
                    background: crosshairResult.qualityColor,
                    borderRadius: "4px",
                    transition: "width 0.3s"
                  } })
                ),
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", marginTop: "8px", fontSize: ts("10"), color: "#718096" } },
                  React.createElement("span", null, "Crossing: " + Math.round(crosshairResult.crossingAngle) + ""),
                  React.createElement("span", null, "Paths: " + crosshairResult.closestApproachNM.toFixed(3) + " NM apart")
                )
              ),
              
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", marginBottom: "16px" } },
                React.createElement("div", { style: { background: "rgba(0,0,0,0.3)", padding: "12px", borderRadius: "8px", textAlign: "center" } },
                  React.createElement("div", { style: { fontSize: ts("10"), color: "#a0aec0", marginBottom: "4px" } }, "LATITUDE N"),
                  React.createElement("div", { style: { fontSize: ts("18"), fontWeight: "700", color: "#f6e05e", fontFamily: "monospace" } }, crosshairResult.latDeg + "\u00B0 " + crosshairResult.latMin + "'")
                ),
                React.createElement("div", { style: { background: "rgba(0,0,0,0.3)", padding: "12px", borderRadius: "8px", textAlign: "center" } },
                  React.createElement("div", { style: { fontSize: ts("10"), color: "#a0aec0", marginBottom: "4px" } }, "LONGITUDE W"),
                  React.createElement("div", { style: { fontSize: ts("18"), fontWeight: "700", color: "#f6e05e", fontFamily: "monospace" } }, crosshairResult.lonDeg + "\u00B0 " + crosshairResult.lonMin + "'")
                )
              ),
              React.createElement("div", { style: { background: "rgba(0,0,0,0.3)", padding: "12px", borderRadius: "8px", textAlign: "center", marginBottom: "16px" } },
                React.createElement("div", { style: { fontSize: ts("10"), color: "#a0aec0", marginBottom: "4px" } }, "CAP GRID"),
                React.createElement("div", { style: { fontSize: ts("22"), fontWeight: "700", color: "#f6e05e", fontFamily: "monospace", letterSpacing: "2px" } }, crosshairResult.capGrid)
              ),
              
              // Assumptions & Method Details (collapsible)
              React.createElement("details", { style: { 
                background: "rgba(0,0,0,0.2)", 
                borderRadius: "8px", 
                marginBottom: "16px",
                border: "1px solid rgba(255,255,255,0.1)"
              } },
                React.createElement("summary", { style: { 
                  padding: "12px", 
                  cursor: "pointer", 
                  fontSize: ts("12"), 
                  fontWeight: "600", 
                  color: "#a0aec0",
                  userSelect: "none"
                } }, "\u{1F4CB} Solution Details & Assumptions"),
                React.createElement("div", { style: { 
                  padding: "12px", 
                  paddingTop: "0",
                  fontSize: ts("11"), 
                  color: "#a0aec0",
                  lineHeight: "1.6"
                } },
                  React.createElement("div", { style: { marginBottom: "10px" } },
                    React.createElement("strong", { style: { color: "#63b3ed" } }, "Method: "),
                    crosshairResult.method
                  ),
                  React.createElement("div", { style: { marginBottom: "10px" } },
                    React.createElement("strong", { style: { color: "#63b3ed" } }, "Path Detection: "),
                    crosshairResult.pathDetectionMethod
                  ),
                  React.createElement("div", { style: { marginBottom: "10px" } },
                    React.createElement("strong", { style: { color: "#63b3ed" } }, "Input Data: "),
                    crosshairResult.path1Count + " points on Path 1 (bearing ~" + Math.round(crosshairResult.avgBearing1) + "\u00B0), " +
                    crosshairResult.path2Count + " points on Path 2 (bearing ~" + Math.round(crosshairResult.avgBearing2) + "\u00B0)"
                  ),
                  React.createElement("div", { style: { marginBottom: "10px" } },
                    React.createElement("strong", { style: { color: "#63b3ed" } }, "Crossing Angle: "),
                    Math.round(crosshairResult.crossingAngle) + "\u00B0",
                    crosshairResult.crossingAngle < 30 ? 
                      React.createElement("span", { style: { color: "#fc8181", marginLeft: "8px" } }, "\u26A0\uFE0F Shallow angle reduces accuracy") :
                      crosshairResult.crossingAngle >= 60 ?
                        React.createElement("span", { style: { color: "#68d391", marginLeft: "8px" } }, "\u2714 Good geometry") :
                        React.createElement("span", { style: { color: "#f6e05e", marginLeft: "8px" } }, "Acceptable")
                  ),
                  React.createElement("div", { style: { marginBottom: "10px" } },
                    React.createElement("strong", { style: { color: "#63b3ed" } }, "Path Separation: "),
                    crosshairResult.closestApproachNM.toFixed(3) + " NM at closest approach",
                    crosshairResult.closestApproachNM > 0.2 ?
                      React.createElement("span", { style: { color: "#fc8181", marginLeft: "8px" } }, "\u26A0\uFE0F Paths may not cross over target") :
                      React.createElement("span", { style: { color: "#68d391", marginLeft: "8px" } }, "\u2714 Paths converge well")
                  ),
                  React.createElement("div", { style: { marginBottom: "10px" } },
                    React.createElement("strong", { style: { color: "#63b3ed" } }, "Expected Accuracy: "),
                    React.createElement("span", { style: { color: crosshairResult.qualityColor, fontWeight: "600" } }, crosshairResult.expectedAccuracy)
                  ),
                  // Methods Compared
                  crosshairResult.methodsCompared && crosshairResult.methodsCompared.length > 1 && React.createElement("div", { style: { 
                    marginTop: "10px", 
                    padding: "8px", 
                    background: "rgba(99,179,237,0.1)", 
                    borderRadius: "4px",
                    border: "1px solid rgba(99,179,237,0.3)"
                  } },
                    React.createElement("strong", { style: { color: "#63b3ed", fontSize: ts("10") } }, "Methods Compared:"),
                    React.createElement("div", { style: { marginTop: "6px", fontSize: ts("10") } },
                      crosshairResult.methodsCompared.map((m, i) => 
                        React.createElement("div", { key: i, style: { 
                          padding: "4px 0",
                          color: m.name === crosshairResult.method.split(' ')[0] || crosshairResult.method.includes(m.name) ? "#68d391" : "#718096"
                        } },
                          (m.name === crosshairResult.method.split(' ')[0] || crosshairResult.method.includes(m.name) ? "\u2713 " : "  ") +
                          m.name + ": " + m.lat.toFixed(5) + ", " + m.lon.toFixed(5)
                        )
                      )
                    )
                  ),
                  crosshairResult.usedFallback && React.createElement("div", { style: { 
                    marginTop: "10px", 
                    padding: "8px", 
                    background: "rgba(214,158,46,0.2)", 
                    borderRadius: "4px",
                    border: "1px solid #d69e2e"
                  } },
                    React.createElement("strong", { style: { color: "#f6e05e" } }, "\u26A0\uFE0F Fallback Used: "),
                    "Line intersection unreliable due to shallow crossing angle or paths not crossing. Using closest approach midpoint."
                  ),
                  React.createElement("div", { style: { 
                    marginTop: "12px", 
                    paddingTop: "10px",
                    borderTop: "1px solid rgba(255,255,255,0.1)",
                    fontSize: ts("10"),
                    color: "#718096"
                  } },
                    React.createElement("strong", null, "Assumptions: "),
                    "Aircraft GPS accuracy typical for aviation receivers. ",
                    "Both paths represent intentional overflights of same target. ",
                    "Pilot maintained consistent heading during each pass. ",
                    "Multi-method comparison selects best result based on crossing geometry."
                  ),
                  React.createElement("div", { style: { marginTop: "8px", fontSize: ts("10"), color: "#718096" } },
                    React.createElement("strong", null, "Coordinate Formats: "),
                    React.createElement("br", null),
                    "DD: " + crosshairResult.ddText,
                    React.createElement("br", null),
                    "DDM: " + crosshairResult.ddmText,
                    React.createElement("br", null),
                    "DMS: " + crosshairResult.dmsText
                  )
                )
              ),
              
              // Export buttons row 1
              React.createElement("div", { style: { display: "flex", gap: "8px", marginBottom: "8px" } },
                React.createElement("button", {
                  onClick: copyIntersection,
                  style: {
                    flex: 1,
                    minHeight: "48px",
                    padding: "12px",
                    fontSize: ts("12"),
                    fontWeight: "700",
                    background: "linear-gradient(135deg, #4a5568, #2d3748)",
                    border: "2px solid #718096",
                    borderRadius: "10px",
                    color: "#fff",
                    fontFamily: "inherit",
                    cursor: "pointer",
                    touchAction: "manipulation"
                  }
                }, "\u{1F4CB} COPY"),
                React.createElement("button", {
                  onClick: exportToForeflight,
                  style: {
                    flex: 1,
                    minHeight: "48px",
                    padding: "12px",
                    fontSize: ts("12"),
                    fontWeight: "700",
                    background: "linear-gradient(135deg, #2f855a, #276749)",
                    border: "2px solid #48bb78",
                    borderRadius: "10px",
                    color: "#fff",
                    fontFamily: "inherit",
                    cursor: "pointer",
                    touchAction: "manipulation"
                  }
                }, "\u{2708}\uFE0F FOREFLIGHT")
              ),
              
              // View on Map button
              React.createElement("div", { style: { display: "flex", gap: "8px" } },
                React.createElement("button", {
                  onClick: viewOnMapWithTracks,
                  style: {
                    flex: 1,
                    minHeight: "48px",
                    padding: "12px",
                    fontSize: ts("12"),
                    fontWeight: "700",
                    background: "linear-gradient(135deg, #3182ce, #2b6cb0)",
                    border: "2px solid #4299e1",
                    borderRadius: "10px",
                    color: "#fff",
                    fontFamily: "inherit",
                    cursor: "pointer",
                    touchAction: "manipulation"
                  }
                }, "\u{1F5FA}\uFE0F VIEW MAP")
              )
            )
          )
        ),
        // Inline Map Modal
        crosshairShowMap && React.createElement("div", {
          style: {
            position: "fixed",
            top: 0, left: 0, right: 0, bottom: 0,
            background: "rgba(0,0,0,0.95)",
            zIndex: 10000,
            display: "flex",
            flexDirection: "column"
          }
        },
          // Modal header
          React.createElement("div", {
            style: {
              padding: "12px 16px",
              background: "linear-gradient(135deg, #1a202c, #2d3748)",
              borderBottom: "2px solid #d69e2e",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              gap: "12px"
            }
          },
            React.createElement("div", { style: { fontSize: "16px", fontWeight: "700", color: "#f6e05e" } }, "\u{1F3AF} Crosshair Target Map"),
            React.createElement("div", { style: { display: "flex", gap: "8px" } },
              React.createElement("button", {
                onClick: popOutCrosshairMap,
                style: { background: "rgba(49,130,206,0.3)", border: "2px solid #63b3ed", borderRadius: "8px", padding: "8px 16px", color: "#63b3ed", fontWeight: "700", cursor: "pointer", fontSize: "14px" }
              }, "\u{1F5D7} Pop Out"),
              React.createElement("button", {
                onClick: () => setCrosshairShowMap(false),
                style: { background: "rgba(229,62,62,0.3)", border: "2px solid #fc8181", borderRadius: "8px", padding: "8px 16px", color: "#fc8181", fontWeight: "700", cursor: "pointer", fontSize: "14px" }
              }, "\u2715 Close")
            )
          ),
          // Map iframe container
          React.createElement("div", { style: { flex: 1, position: "relative", minHeight: 0 } },
            React.createElement("iframe", {
              srcDoc: crosshairMapHtml,
              style: { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", border: "none" },
              title: "Crosshair Target Map"
            })
          )
        )
      );
    };

    // ELT Assist Tab - ELT Signal Triangulation Tool
    const renderEltAssistTab = () => {
      
      // Generate ELT result map HTML
      const generateEltMapHtml = () => {
        if (!eltResult) return '';
        
        const centerLat = eltResult.centroid.lat;
        const centerLon = eltResult.centroid.lon;
        const observations = eltObservations.filter(o => o.lat && o.lon);
        
        return [
          '<!DOCTYPE html>',
          '<html style="height:100%;margin:0"><head>',
          '<title>ELT Solution - ' + (eltResult.capGrid || 'Unknown Grid') + '</title>',
          '<meta name="viewport" content="width=device-width, initial-scale=1.0">',
          '<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>',
          '<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></scr' + 'ipt>',
          '<style>',
          'html,body{height:100%;margin:0;padding:0}',
          'body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif}',
          '#map{height:100%;width:100%}',
          '.info-panel{position:absolute;top:10px;right:10px;background:linear-gradient(135deg,rgba(26,32,44,0.95),rgba(45,55,72,0.95));color:#fff;padding:0;border-radius:12px;z-index:1000;max-width:300px;box-shadow:0 4px 20px rgba(0,0,0,0.4);border:2px solid #ed8936;overflow:hidden}',
          '.info-header{background:linear-gradient(90deg,rgba(237,137,54,0.3),transparent);padding:12px 16px;border-bottom:1px solid rgba(255,255,255,0.1)}',
          '.info-header h3{margin:0;color:#f6e05e;font-size:16px}',
          '.info-body{padding:16px}',
          '.cap-grid{background:rgba(0,0,0,0.4);padding:12px;border-radius:8px;text-align:center;margin-bottom:12px;border:2px solid #f6e05e}',
          '.cap-grid-label{font-size:10px;color:#a0aec0;text-transform:uppercase;letter-spacing:1px;margin-bottom:4px}',
          '.cap-grid-value{font-size:20px;font-weight:700;color:#f6e05e;font-family:monospace;letter-spacing:2px}',
          '.coords{background:rgba(0,0,0,0.3);padding:10px;border-radius:6px;margin-bottom:12px}',
          '.coord-row{display:flex;justify-content:space-between;font-size:12px;padding:4px 0}',
          '.coord-label{color:#a0aec0}',
          '.coord-value{color:#68d391;font-family:monospace}',
          '.stats{background:rgba(0,0,0,0.3);padding:10px;border-radius:6px;font-size:11px}',
          '.stat-row{display:flex;justify-content:space-between;padding:3px 0}',
          '.stat-label{color:#a0aec0}',
          '.stat-value{color:#ed8936;font-weight:600}',
          '.legend{display:flex;gap:10px;justify-content:center;padding:10px;background:rgba(0,0,0,0.2);border-radius:6px;font-size:10px;margin-top:12px;flex-wrap:wrap}',
          '.legend-item{display:flex;align-items:center;gap:4px}',
          '.legend-dot{width:10px;height:10px;border-radius:50%}',
          '@media(max-width:480px){.info-panel{top:auto;bottom:10px;right:10px;left:10px;max-width:none}}',
          '</style>',
          '</head><body>',
          '<div id="map"></div>',
          '<div class="info-panel">',
          '<div class="info-header">',
          '<h3> ELT Triangulation Solution</h3>',
          '</div>',
          '<div class="info-body">',
          '<div class="cap-grid">',
          '<div class="cap-grid-label">Probable Location</div>',
          '<div class="cap-grid-value">' + (eltResult.capGrid || 'N/A') + '</div>',
          '</div>',
          '<div class="coords">',
          '<div class="coord-row"><span class="coord-label">Centroid</span><span class="coord-value">' + centerLat.toFixed(5) + ', ' + centerLon.toFixed(5) + '</span></div>',
          '<div class="coord-row"><span class="coord-label">Uncertainty</span><span class="coord-value">' + (eltResult.uncertainty ? eltResult.uncertainty.toFixed(1) : 'N/A') + ' nm</span></div>',
          '</div>',
          '<div class="stats">',
          '<div class="stat-row"><span class="stat-label">Observations</span><span class="stat-value">' + observations.length + '</span></div>',
          '<div class="stat-row"><span class="stat-label">Method</span><span class="stat-value">' + (eltResult.method || 'Triangulation') + '</span></div>',
          '</div>',
          '<div class="legend">',
          '<div class="legend-item"><div class="legend-dot" style="background:#cc0000"></div> ELT Location</div>',
          '<div class="legend-item"><div class="legend-dot" style="background:#3182ce"></div> Observations</div>',
          '<div class="legend-item"><div class="legend-dot" style="background:rgba(0,0,0,0.3);border:2px dashed #000"></div> Uncertainty</div>',
          '</div>',
          '</div>',
          '</div>',
          '<scr' + 'ipt>',
          'var map=L.map("map").setView([' + centerLat + ',' + centerLon + '],12);',
          'L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{attribution:"OpenStreetMap"}).addTo(map);',
          // Uncertainty circle
          'L.circle([' + centerLat + ',' + centerLon + '],{radius:' + ((eltResult.uncertainty || 2) * 1852) + ',color:"#000000",weight:2,fillColor:"#000000",fillOpacity:0.1,dashArray:"8,6"}).addTo(map);',
          // Observation points
          'var obs=' + JSON.stringify(observations.map(o => ({ lat: parseFloat(o.lat), lon: parseFloat(o.lon), label: o.label || 'Obs' }))) + ';',
          'obs.forEach(function(o){L.circleMarker([o.lat,o.lon],{radius:8,color:"#3182ce",weight:3,fillColor:"#ffffff",fillOpacity:1.0}).bindPopup(o.label).addTo(map);});',
          // ELT location marker
          'var eltIcon=L.divIcon({className:"elt-marker",html:"<div style=\\"background:#cc0000;color:white;padding:6px 10px;border-radius:6px;font-size:12px;font-weight:bold;white-space:nowrap;box-shadow:0 2px 8px rgba(0,0,0,0.5);border:3px solid white\\"> ELT</div>",iconSize:[70,32],iconAnchor:[35,16]});',
          'L.marker([' + centerLat + ',' + centerLon + '],{icon:eltIcon}).bindPopup("<b>Probable ELT Location</b><br>' + (eltResult.capGrid || '') + '<br>' + centerLat.toFixed(5) + ', ' + centerLon.toFixed(5) + '").addTo(map).openPopup();',
          // Fit bounds
          'var allPts=[[' + centerLat + ',' + centerLon + ']];obs.forEach(function(o){allPts.push([o.lat,o.lon]);});',
          'if(allPts.length>1){map.fitBounds(allPts,{padding:[50,50]});}',
          '</scr' + 'ipt>',
          '</body></html>'
        ].join('\n');
      };
      
      // Show ELT map inline
      const viewEltMap = () => {
        if (!eltResult) return;
        const html = generateEltMapHtml();
        setEltMapHtml(html);
        setEltShowMapModal(true);
      };
      
      // Pop out ELT map to new window
      const popOutEltMap = () => {
        const html = eltMapHtml || generateEltMapHtml();
        const mapWindow = window.open('', '_blank');
        if (mapWindow) {
          mapWindow.document.write(html);
          mapWindow.document.close();
        } else {
          alert('Please allow popups to view the map.');
        }
      };
      
      // Import KML/KMZ file function
      const importKmlKmz = async (file) => {
        try {
          let kmlText;
          
          if (file.name.toLowerCase().endsWith('.kmz')) {
            // KMZ is a zipped KML - use JSZip via CDN
            const arrayBuffer = await file.arrayBuffer();
            const JSZip = window.JSZip;
            if (!JSZip) {
              alert('Loading JSZip library... Please try again in a moment.');
              // Dynamically load JSZip
              const script = document.createElement('script');
              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
              document.head.appendChild(script);
              return;
            }
            const zip = await JSZip.loadAsync(arrayBuffer);
            const kmlFile = zip.file(/\.kml$/i)[0];
            if (!kmlFile) {
              alert('No KML file found in KMZ archive');
              return;
            }
            kmlText = await kmlFile.async('text');
          } else {
            // Plain KML file
            kmlText = await file.text();
          }
          
          // Parse KML
          const parser = new DOMParser();
          const kml = parser.parseFromString(kmlText, 'text/xml');
          
          // Find all Placemarks with D_Sol style (detection points)
          const placemarks = kml.querySelectorAll('Placemark');
          const imported = [];
          
          placemarks.forEach((pm, idx) => {
            const styleUrl = pm.querySelector('styleUrl');
            if (!styleUrl) return;
            
            // Only process detection points (D_Sol) not rings (R_RINGS)
            const style = styleUrl.textContent;
            if (!style.includes('D_Sol') && !style.includes('Sol0')) return;
            if (style.includes('R_RINGS')) return;
            
            // Get coordinates
            const point = pm.querySelector('Point coordinates');
            if (!point) return;
            
            const coords = point.textContent.trim().split(',');
            if (coords.length < 2) return;
            
            const lon = parseFloat(coords[0]);
            const lat = parseFloat(coords[1]);
            
            // Get extended data
            let detectTime = '';
            let errorNm = '';
            let msgNum = '';
            
            const dataElements = pm.querySelectorAll('ExtendedData Data');
            dataElements.forEach(d => {
              const name = d.getAttribute('name');
              const value = d.querySelector('value');
              if (!value) return;
              
              if (name === 'DETECT TIME') {
                detectTime = value.textContent.trim().replace('Z', '');
              } else if (name === 'ERROR') {
                // Parse "011 NM" format
                const match = value.textContent.match(/(\d+)/);
                if (match) errorNm = match[1];
              } else if (name === 'USMCC MESSAGE NUMBER') {
                msgNum = value.textContent.trim();
              }
            });
            
            // Get timestamp if available
            const timestamp = pm.querySelector('TimeStamp when');
            if (timestamp && !detectTime) {
              const ts = timestamp.textContent;
              const match = ts.match(/T(\d{2}):(\d{2})/);
              if (match) {
                detectTime = match[1] + match[2];
              }
            }
            
            // Convert to DDM
            const latDdm = gpsUtils.ddToDdm(lat);
            const lonDdm = gpsUtils.ddToDdm(Math.abs(lon));
            
            eltObsSeqRef.current = (eltObsSeqRef.current || 0) + 1;
            
            imported.push({
              id: Date.now() + Math.random() + idx,
              obsNum: eltObsSeqRef.current,
              timeZ: detectTime || '',
              source: 'sarsat',
              latDeg: latDdm.deg.toString(),
              latMin: latDdm.min.toFixed(3),
              lonDeg: lonDdm.deg.toString(),
              lonMin: lonDdm.min.toFixed(3),
              altMSL: '',
              altAGL: '30000', // Satellite detection - high altitude
              strength: 5,
              directRange: errorNm || '',
              rangeAccuracy: errorNm ? (parseFloat(errorNm) * 0.3).toFixed(1) : '', // 30% uncertainty
              dfBearing: '',
              bearingRef: 'TRUE',
              bearingAccuracy: '20',
              notes: `SARSAT Import${msgNum ? ' - MSG#' + msgNum : ''}`,
              useInCalc: true
            });
          });
          
          if (imported.length === 0) {
            alert('No valid ELT detection points found in file');
            return;
          }
          
          // Add to observations
          setEltObservations([...imported, ...eltObservations]);
          alert(`Imported ${imported.length} ELT detection points from ${file.name}`);
          
        } catch (err) {
          console.error('KML import error:', err);
          alert('Error importing file: ' + err.message);
        }
      };
      
      // Import ADS-B track from FlightAware KML
      const importAdsbTrack = async (file) => {
        try {
          const kmlText = await file.text();
          const parser = new DOMParser();
          const kml = parser.parseFromString(kmlText, 'text/xml');
          
          // Find gx:Track element
          const track = kml.querySelector('Track') || kml.getElementsByTagName('gx:Track')[0];
          if (!track) {
            alert('No flight track found in KML file');
            return;
          }
          
          // Extract timestamps
          const whenElements = track.querySelectorAll('when') || track.getElementsByTagName('when');
          const times = Array.from(whenElements).map(w => w.textContent.trim());
          
          // Extract coordinates (gx:coord format: lon lat alt)
          const coordElements = track.querySelectorAll('coord') || track.getElementsByTagName('gx:coord');
          const coords = Array.from(coordElements).map(c => {
            const parts = c.textContent.trim().split(/\s+/);
            return {
              lon: parseFloat(parts[0]),
              lat: parseFloat(parts[1]),
              alt: parseFloat(parts[2]) || 0
            };
          });
          
          if (coords.length === 0) {
            alert('No track coordinates found in file');
            return;
          }
          
          // Get aircraft ID from Placemark name
          const placemarkName = kml.querySelector('Placemark n, Placemark name');
          const aircraftId = placemarkName ? placemarkName.textContent.trim() : 'Unknown';
          
          // Get departure airport
          const depPlacemark = Array.from(kml.querySelectorAll('Placemark')).find(p => {
            const name = p.querySelector('n, name');
            return name && name.textContent.includes('Airport') && !name.textContent.includes('INVALID');
          });
          const departureAirport = depPlacemark ? depPlacemark.querySelector('n, name').textContent.replace(' Airport', '') : '';
          
          // Build track data
          const trackData = {
            aircraftId,
            departureAirport,
            importTime: new Date().toISOString(),
            points: coords.map((c, i) => ({
              time: times[i] || '',
              lat: c.lat,
              lon: c.lon,
              altM: c.alt,
              altFt: Math.round(c.alt * 3.28084)
            }))
          };
          
          // Calculate last known heading and speed
          if (trackData.points.length >= 2) {
            const p1 = trackData.points[trackData.points.length - 2];
            const p2 = trackData.points[trackData.points.length - 1];
            
            // Calculate bearing
            const lat1 = p1.lat * Math.PI / 180;
            const lat2 = p2.lat * Math.PI / 180;
            const dLon = (p2.lon - p1.lon) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            trackData.lastHeading = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;
            
            // Calculate groundspeed
            if (p1.time && p2.time) {
              const t1 = new Date(p1.time);
              const t2 = new Date(p2.time);
              const dtHours = (t2 - t1) / 3600000;
              
              // Haversine distance
              const R = 3440.065; // NM
              const dLat = (p2.lat - p1.lat) * Math.PI / 180;
              const a = Math.sin(dLat/2)**2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon/2)**2;
              const dist = 2 * R * Math.asin(Math.sqrt(a));
              
              trackData.lastGroundspeed = dtHours > 0 ? Math.round(dist / dtHours) : 0;
            }
            
            trackData.lastPosition = p2;
            trackData.lastTime = p2.time;
          }
          
          setAdsbTrack(trackData);
          alert(`Imported ADS-B track: ${aircraftId}\n${trackData.points.length} position reports\nLast position: ${trackData.lastPosition?.lat.toFixed(4)}N, ${Math.abs(trackData.lastPosition?.lon).toFixed(4)}W\nLast heading: ${trackData.lastHeading?.toFixed(0)}\nGroundspeed: ${trackData.lastGroundspeed} kts`);
          
        } catch (err) {
          console.error('ADS-B import error:', err);
          alert('Error importing ADS-B file: ' + err.message);
        }
      };
      
      // Specific handler for SARSAT files
      const handleSarsatImport = (e) => {
        const file = e.target.files[0];
        if (file) {
          importKmlKmz(file);
        }
        e.target.value = '';
      };
      
      // Specific handler for ADS-B files
      const handleAdsbImport = (e) => {
        const file = e.target.files[0];
        if (file) {
          importAdsbTrack(file);
        }
        e.target.value = '';
      };
      
      // Helper to create observation
      const addObservation = () => {
        if (!newEltObs.latDeg || !newEltObs.latMin || !newEltObs.lonDeg || !newEltObs.lonMin) {
          alert('Position required (Lat/Lon)');
          return;
        }
        eltObsSeqRef.current = (eltObsSeqRef.current || 0) + 1;
        const obs = {
          id: Date.now() + Math.random(),
          obsNum: eltObsSeqRef.current,
          ...newEltObs,
          timeZ: newEltObs.timeZ || getZuluTimeOnly()
        };
        setEltObservations([obs, ...eltObservations]);
        // Reset form but keep some defaults
        setNewEltObs({
          timeZ: '',
          source: 'audio',
          latDeg: '',
          latMin: '',
          lonDeg: '',
          lonMin: '',
          altMSL: newEltObs.altMSL,
          altAGL: newEltObs.altAGL,
          strength: 5,
          directRange: '',
          rangeAccuracy: '',
          dfBearing: '',
          bearingRef: 'MAG',
          bearingAccuracy: '20',
          notes: '',
          useInCalc: true
        });
      };

      // Remove observation
      const removeObservation = (id) => {
        setEltObservations(eltObservations.filter(o => o.id !== id));
      };

      // Toggle use in calculation
      const toggleObsUse = (id) => {
        setEltObservations(eltObservations.map(o => 
          o.id === id ? { ...o, useInCalc: !o.useInCalc } : o
        ));
      };

      // Get current GPS position
      const captureGPS = () => {
        if (!navigator.geolocation) {
          alert('GPS not available');
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            const latDdm = gpsUtils.ddToDdm(lat);
            const lonDdm = gpsUtils.ddToDdm(Math.abs(lon));
            
            // Get altitude if available (in meters, convert to feet)
            // Note: altitude from GPS is MSL, we estimate AGL
            let altMSL = '';
            let altAGL = '';
            if (pos.coords.altitude !== null) {
              const altFt = Math.round(pos.coords.altitude * 3.28084);
              altMSL = altFt.toString();
              // Rough AGL estimate (user should verify/adjust)
              // Default to MSL - 5000 ft as rough terrain estimate for Colorado
              altAGL = Math.max(500, altFt - 5000).toString();
            }
            
            setNewEltObs({
              ...newEltObs,
              latDeg: latDdm.deg.toString(),
              latMin: latDdm.min.toFixed(3),
              lonDeg: lonDdm.deg.toString(),
              lonMin: lonDdm.min.toFixed(3),
              altMSL: altMSL || newEltObs.altMSL,
              altAGL: altAGL || newEltObs.altAGL,
              timeZ: getZuluTimeOnly()
            });
            
            // Show altitude info to user
            if (pos.coords.altitude !== null) {
              const altFt = Math.round(pos.coords.altitude * 3.28084);
              const horizonNm = (1.06 * (Math.sqrt(altFt) + Math.sqrt(3))).toFixed(1);
              alert(`Position captured!\nAltitude: ${altFt} ft MSL\nRadio Horizon: ~${horizonNm} NM\n\nVerify/adjust AGL altitude for your terrain.`);
            }
          },
          (err) => alert('GPS error: ' + err.message),
          { enableHighAccuracy: true, timeout: 10000 }
        );
      };
      
      // Calculate radio horizon from altitude (NM)
      // Formula: d_LOS(nm) ~ 1.06  (sqrth_aircraft + sqrth_elt)
      // Assumes ELT antenna at ~3 ft
      const calcRadioHorizon = (altAglFt) => {
        if (!altAglFt || altAglFt <= 0) return null;
        const h1 = parseFloat(altAglFt);
        const h2 = 3; // ELT antenna height estimate
        return 1.06 * (Math.sqrt(h1) + Math.sqrt(h2));
      };
      
      // Estimate search range based on signal strength and altitude
      // From radio horizon math: strength gives secondary constraint
      // "strong"  <=25% of horizon, "moderate"  <=50%, "weak"  <=90-100%
      const estimateSearchRange = (strength, altAglFt) => {
        const horizon = calcRadioHorizon(altAglFt || 1500);
        if (!horizon) return null;
        
        // Map 1-10 strength to % of radio horizon
        // 10 = very strong (close), 1 = barely audible (near horizon)
        // Strength 10: ~10% of horizon
        // Strength 5: ~50% of horizon  
        // Strength 1: ~100% of horizon
        const pctOfHorizon = 1.0 - (strength - 1) * 0.1; // 1010%, 550%, 1100%
        
        const maxRange = horizon * pctOfHorizon;
        const minRange = horizon * Math.max(0, pctOfHorizon - 0.25);
        
        return {
          horizon: horizon.toFixed(1),
          minRange: minRange.toFixed(1),
          maxRange: maxRange.toFixed(1),
          pct: Math.round(pctOfHorizon * 100)
        };
      };
      
      // Generate G1000 SAR Programming Instructions
      // Based on Garmin G1000 Search and Rescue Pilot's Guide
      const generateG1000Instructions = (result) => {
        if (!result || !result.centroid) return null;
        
        // Format coordinates for G1000 entry (DDM format)
        const lat = `N ${result.centroid.latDeg} ${result.centroid.latMin}'`;
        const lon = `W ${result.centroid.lonDeg} ${result.centroid.lonMin}'`;
        
        // Calculate recommended search pattern parameters
        // Based on 50% probability area size
        const area50Nm2 = parseFloat(result.area50SizeNm2) || 25;
        const searchRadiusNm = Math.sqrt(area50Nm2 / Math.PI);
        
        // Recommend pattern based on area size and shape
        let recommendedPattern = 'PARALLEL';
        let legLength = Math.max(5, Math.min(20, searchRadiusNm * 2.5)).toFixed(1);
        let spacing = '1.0';
        let numLegs = 10;
        
        if (area50Nm2 < 10) {
          // Small area - use Expanding Square
          recommendedPattern = 'EXP SQR';
          spacing = Math.max(0.5, searchRadiusNm / 3).toFixed(1);
          numLegs = Math.min(20, Math.ceil(searchRadiusNm * 4));
        } else if (area50Nm2 < 50) {
          // Medium area - use Sector
          recommendedPattern = 'SECTOR';
          legLength = Math.max(3, searchRadiusNm * 1.5).toFixed(1);
        } else {
          // Large area - use Parallel Track
          spacing = Math.max(1.0, Math.min(3.0, searchRadiusNm / 5)).toFixed(1);
          numLegs = Math.min(40, Math.ceil((searchRadiusNm * 2) / parseFloat(spacing)));
        }
        
        return {
          waypoint: {
            name: 'USR' + (result.solutionNum || '01'),
            lat: lat,
            lon: lon,
            latDeg: result.centroid.latDeg,
            latMin: result.centroid.latMin,
            lonDeg: result.centroid.lonDeg,
            lonMin: result.centroid.lonMin
          },
          pattern: recommendedPattern,
          legLength: legLength,
          spacing: spacing,
          numLegs: numLegs,
          initialTrack: '360',
          initialTurn: 'RIGHT',
          area50: area50Nm2.toFixed(1),
          searchRadius: searchRadiusNm.toFixed(1)
        };
      };
      
      // Render G1000 Instructions Modal
      const renderG1000Modal = () => {
        if (!showG1000Instructions || !eltResult) return null;
        
        const g1000 = generateG1000Instructions(eltResult);
        if (!g1000) return null;
        
        const stepStyle = {
          padding: '12px',
          marginBottom: '8px',
          background: 'rgba(0,0,0,0.3)',
          borderRadius: '8px',
          borderLeft: '3px solid #63b3ed'
        };
        
        const knobStyle = {
          display: 'inline-block',
          padding: '2px 8px',
          background: 'rgba(99,179,237,0.3)',
          borderRadius: '4px',
          fontFamily: 'monospace',
          fontWeight: '700',
          color: '#63b3ed',
          margin: '0 2px'
        };
        
        const keyStyle = {
          display: 'inline-block',
          padding: '4px 10px',
          background: 'linear-gradient(180deg, #4a5568, #2d3748)',
          borderRadius: '4px',
          fontFamily: 'monospace',
          fontWeight: '700',
          color: '#f6e05e',
          border: '1px solid #718096',
          margin: '0 3px',
          fontSize: '11px'
        };
        
        const valueStyle = {
          fontFamily: 'monospace',
          fontWeight: '700',
          color: '#68d391',
          fontSize: '14px'
        };
        
        const noteStyle = {
          fontSize: '10px',
          color: '#a0aec0',
          fontStyle: 'italic',
          marginTop: '6px'
        };
        
        return React.createElement("div", {
          style: {
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: "rgba(0,0,0,0.9)",
            zIndex: 10000,
            overflow: "auto",
            padding: "20px"
          }
        },
          React.createElement("div", {
            style: {
              maxWidth: "600px",
              margin: "0 auto",
              background: "linear-gradient(180deg, #1a365d, #0c1929)",
              borderRadius: "12px",
              border: "1px solid rgba(99,179,237,0.3)"
            }
          },
            // Header
            React.createElement("div", {
              style: {
                padding: "16px 20px",
                borderBottom: "1px solid rgba(255,255,255,0.1)",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center"
              }
            },
              React.createElement("div", null,
                React.createElement("div", { style: { fontSize: "18px", fontWeight: "700", color: "#63b3ed" }}, 
                  " G1000 SAR Programming Guide"
                ),
                React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginTop: "4px" }},
                  "Step-by-step instructions for Solution #", eltResult.solutionNum
                )
              ),
              React.createElement("button", {
                style: {
                  background: "rgba(229,62,62,0.2)",
                  border: "1px solid rgba(229,62,62,0.5)",
                  borderRadius: "8px",
                  padding: "8px 16px",
                  color: "#fc8181",
                  cursor: "pointer",
                  fontSize: "14px"
                },
                onClick: () => setShowG1000Instructions(false)
              }, " Close")
            ),
            
            // Summary Card
            React.createElement("div", {
              style: {
                margin: "16px",
                padding: "16px",
                background: "rgba(246,224,94,0.1)",
                borderRadius: "8px",
                border: "1px solid rgba(246,224,94,0.3)"
              }
            },
              React.createElement("div", { style: { fontSize: "12px", color: "#f6e05e", fontWeight: "600", marginBottom: "12px" }},
                " TARGET COORDINATES"
              ),
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px" }},
                React.createElement("div", null,
                  React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0" }}, "LATITUDE"),
                  React.createElement("div", { style: valueStyle }, g1000.waypoint.lat)
                ),
                React.createElement("div", null,
                  React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0" }}, "LONGITUDE"),
                  React.createElement("div", { style: valueStyle }, g1000.waypoint.lon)
                )
              ),
              React.createElement("div", { style: { marginTop: "12px", paddingTop: "12px", borderTop: "1px solid rgba(255,255,255,0.1)", display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: "8px", textAlign: "center" }},
                React.createElement("div", null,
                  React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0" }}, "PATTERN"),
                  React.createElement("div", { style: { ...valueStyle, fontSize: "12px" }}, g1000.pattern)
                ),
                React.createElement("div", null,
                  React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0" }}, "50% AREA"),
                  React.createElement("div", { style: { ...valueStyle, fontSize: "12px" }}, g1000.area50, " NM")
                ),
                React.createElement("div", null,
                  React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0" }}, "SEARCH RADIUS"),
                  React.createElement("div", { style: { ...valueStyle, fontSize: "12px" }}, "~", g1000.searchRadius, " NM")
                )
              )
            ),
            
            // Instructions
            React.createElement("div", { style: { padding: "0 16px 16px" }},
              React.createElement("div", { style: { fontSize: "14px", fontWeight: "700", color: "#e2e8f0", marginBottom: "12px" }},
                "STEP-BY-STEP INSTRUCTIONS"
              ),
              
              // Step 1: Create User Waypoint
              React.createElement("div", { style: stepStyle },
                React.createElement("div", { style: { fontSize: "12px", fontWeight: "700", color: "#63b3ed", marginBottom: "8px" }},
                  "STEP 1: Create User Waypoint"
                ),
                React.createElement("div", { style: { fontSize: "11px", color: "#e2e8f0", lineHeight: "1.8" }},
                  "1. Press ", React.createElement("span", { style: keyStyle }, "FPL"), " to open Flight Plan page", React.createElement("br"),
                  "2. Press ", React.createElement("span", { style: keyStyle }, "MENU"), " key", React.createElement("br"),
                  "3. Turn ", React.createElement("span", { style: knobStyle }, "FMS"), " knob to select 'Create New User Waypoint'", React.createElement("br"),
                  "4. Press ", React.createElement("span", { style: keyStyle }, "ENT")
                ),
                React.createElement("div", { style: noteStyle },
                  "This creates a waypoint at the computed ELT location"
                )
              ),
              
              // Step 2: Enter Coordinates
              React.createElement("div", { style: stepStyle },
                React.createElement("div", { style: { fontSize: "12px", fontWeight: "700", color: "#63b3ed", marginBottom: "8px" }},
                  "STEP 2: Enter Coordinates"
                ),
                React.createElement("div", { style: { fontSize: "11px", color: "#e2e8f0", lineHeight: "1.8" }},
                  "Enter LATITUDE:", React.createElement("br"),
                  " Turn ", React.createElement("span", { style: knobStyle }, "small FMS"), " to select 'N'", React.createElement("br"),
                  " Turn ", React.createElement("span", { style: knobStyle }, "large FMS"), " to move cursor right", React.createElement("br"),
                  " Enter degrees: ", React.createElement("span", { style: valueStyle }, g1000.waypoint.latDeg, ""), React.createElement("br"),
                  " Enter minutes: ", React.createElement("span", { style: valueStyle }, g1000.waypoint.latMin, "'"), React.createElement("br"),
                  React.createElement("br"),
                  "Enter LONGITUDE:", React.createElement("br"),
                  " Turn ", React.createElement("span", { style: knobStyle }, "small FMS"), " to select 'W'", React.createElement("br"),
                  " Enter degrees: ", React.createElement("span", { style: valueStyle }, g1000.waypoint.lonDeg, ""), React.createElement("br"),
                  " Enter minutes: ", React.createElement("span", { style: valueStyle }, g1000.waypoint.lonMin, "'"), React.createElement("br"),
                  React.createElement("br"),
                  "Press ", React.createElement("span", { style: keyStyle }, "ENT"), " to confirm"
                )
              ),
              
              // Step 3: Access SAR Menu
              React.createElement("div", { style: stepStyle },
                React.createElement("div", { style: { fontSize: "12px", fontWeight: "700", color: "#63b3ed", marginBottom: "8px" }},
                  "STEP 3: Access Search and Rescue Menu"
                ),
                React.createElement("div", { style: { fontSize: "11px", color: "#e2e8f0", lineHeight: "1.8" }},
                  "1. Press ", React.createElement("span", { style: keyStyle }, "FPL"), " to display Active Flight Plan", React.createElement("br"),
                  "2. Press ", React.createElement("span", { style: keyStyle }, "MENU"), " key", React.createElement("br"),
                  "3. Turn ", React.createElement("span", { style: knobStyle }, "FMS"), " to highlight ", React.createElement("span", { style: { color: "#68d391" }}, "'Search and Rescue'"), React.createElement("br"),
                  "4. Press ", React.createElement("span", { style: keyStyle }, "ENT")
                ),
                React.createElement("div", { style: noteStyle },
                  "Note: SAR feature requires unlock card in MFD SD slot"
                )
              ),
              
              // Step 4: Configure Search Pattern
              React.createElement("div", { style: stepStyle },
                React.createElement("div", { style: { fontSize: "12px", fontWeight: "700", color: "#63b3ed", marginBottom: "8px" }},
                  "STEP 4: Configure Search Pattern"
                ),
                React.createElement("div", { style: { fontSize: "11px", color: "#e2e8f0", lineHeight: "1.8" }},
                  "Configure these recommended parameters:", React.createElement("br"), React.createElement("br"),
                  React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px" }},
                    React.createElement("div", null, "WAYPOINT:"),
                    React.createElement("div", { style: valueStyle }, "Your user waypoint"),
                    React.createElement("div", null, "PATTERN:"),
                    React.createElement("div", { style: valueStyle }, g1000.pattern),
                    React.createElement("div", null, "INITIAL DTK:"),
                    React.createElement("div", { style: valueStyle }, g1000.initialTrack, ""),
                    React.createElement("div", null, "INITIAL TURN:"),
                    React.createElement("div", { style: valueStyle }, g1000.initialTurn),
                    g1000.pattern !== 'SECTOR' && React.createElement(React.Fragment, null,
                      React.createElement("div", null, "SPACING:"),
                      React.createElement("div", { style: valueStyle }, g1000.spacing, " NM")
                    ),
                    g1000.pattern !== 'EXP SQR' && React.createElement(React.Fragment, null,
                      React.createElement("div", null, "LEG LENGTH:"),
                      React.createElement("div", { style: valueStyle }, g1000.legLength, " NM")
                    ),
                    g1000.pattern !== 'SECTOR' && React.createElement(React.Fragment, null,
                      React.createElement("div", null, "NUMBER OF LEGS:"),
                      React.createElement("div", { style: valueStyle }, g1000.numLegs)
                    )
                  )
                ),
                React.createElement("div", { style: noteStyle },
                  "Turn small FMS knob to change values, press ENT to advance"
                )
              ),
              
              // Step 5: Activate
              React.createElement("div", { style: stepStyle },
                React.createElement("div", { style: { fontSize: "12px", fontWeight: "700", color: "#63b3ed", marginBottom: "8px" }},
                  "STEP 5: Activate Search Pattern"
                ),
                React.createElement("div", { style: { fontSize: "11px", color: "#e2e8f0", lineHeight: "1.8" }},
                  "1. Turn ", React.createElement("span", { style: knobStyle }, "FMS"), " to highlight ", React.createElement("span", { style: { color: "#68d391" }}, "'ACTIVATE SAR?'"), React.createElement("br"),
                  "2. Press ", React.createElement("span", { style: keyStyle }, "ENT"), " to activate", React.createElement("br"),
                  "3. Pattern appears on Navigation Map", React.createElement("br"),
                  "4. Fly the numbered waypoints (SAR-01, SAR-02, etc.)"
                ),
                React.createElement("div", { style: noteStyle },
                  "Dashed turn leader lines show path at corners based on groundspeed"
                )
              ),
              
              // Pattern Info
              React.createElement("div", { 
                style: { 
                  marginTop: "16px",
                  padding: "12px",
                  background: "rgba(99,179,237,0.1)",
                  borderRadius: "8px",
                  border: "1px solid rgba(99,179,237,0.2)"
                }
              },
                React.createElement("div", { style: { fontSize: "11px", fontWeight: "600", color: "#63b3ed", marginBottom: "8px" }},
                  " PATTERN REFERENCE"
                ),
                React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", lineHeight: "1.6" }},
                  React.createElement("strong", null, "PARALLEL:"), " Rectangular pattern, best for large areas. Adjustable leg length, spacing, number of legs.", React.createElement("br"),
                  React.createElement("strong", null, "SECTOR:"), " Triangular pattern (3 sectors of 3 legs). Best for medium areas with known center point.", React.createElement("br"),
                  React.createElement("strong", null, "EXP SQR:"), " Expanding square from center. Best for small areas with high confidence location."
                )
              )
            )
          )
        );
      };

      // Compute probable area - uses extracted MAT.elt module
      const computeProbableArea = () => {
        // Call the extracted Bayesian probability grid algorithm
        const result = MAT.elt.computeProbableArea({
          observations: eltObservations,
          adsbTrack: adsbTrack,
          settings: eltSettings,
          probModelSettings: probModelSettings,
          gpsUtils: gpsUtils,
          getZuluTime: getZuluTimeOnly
        });
        
        // Handle error case
        if (result.error) {
          alert(result.error);
          return;
        }
        
        // Add solution number
        eltSolutionSeqRef.current = (eltSolutionSeqRef.current || 0) + 1;
        result.solutionNum = eltSolutionSeqRef.current;
        
        // Update state
        setEltResult(result);
        
        // Auto-save to solutions history
        setEltSolutions(prev => [result, ...prev]);
      };

      // Log solution to Events and save to history
      const saveSolutionToHistory = () => {
        if (!eltResult) return;
        logSolutionToEvents();
      };

      // Log observation to Events
      const logObservationToEvents = (obs) => {
        eventSeqRef.current = (eventSeqRef.current || 1) + 1;
        const noteText = `ELT OBS #${obs.obsNum} | Strength: ${obs.strength}/10 | ` +
          (obs.dfBearing ? `DF: ${obs.dfBearing} ${obs.bearingRef} ${obs.bearingAccuracy} | ` : '') +
          `Source: ${obs.source} | AGL: ${obs.altAGL || 'N/A'} ft` +
          (obs.notes ? ` | ${obs.notes}` : '');
        
        const newEvent = {
          id: Date.now() + Math.random(),
          eventNum: eventSeqRef.current,
          eventType: 'ELT Signal',
          timeZ: obs.timeZ,
          latDeg: obs.latDeg,
          latMin: obs.latMin,
          longDeg: obs.lonDeg,
          longMin: obs.lonMin,
          altMSL: obs.altMSL,
          altAGL: obs.altAGL,
          heading: obs.dfBearing || '',
          airspeed: '',
          groundSpeed: '',
          capGrid: '',
          notes: noteText
        };
        setEvents([newEvent, ...events]);
        alert('Observation logged to Events');
      };

      // Log solution to Events
      const logSolutionToEvents = () => {
        if (!eltResult) return;
        eventSeqRef.current = (eventSeqRef.current || 1) + 1;
        const noteText = `ELT ESTIMATE | Method: Probability Grid | ` +
          `Observations: ${eltResult.obsCount} | ` +
          `50% Area: ${eltResult.area50SizeNm2} NM | ` +
          `90% Area: ${eltResult.area90SizeNm2} NM | ` +
          `Grid: ${eltResult.capGrid} | ` +
          `N ${eltResult.centroid.latDeg} ${eltResult.centroid.latMin}' ` +
          `W ${eltResult.centroid.lonDeg} ${eltResult.centroid.lonMin}'`;
        
        const newEvent = {
          id: Date.now() + Math.random(),
          eventNum: eventSeqRef.current,
          eventType: 'ELT Signal',
          timeZ: eltResult.timestamp,
          latDeg: eltResult.centroid.latDeg.toString(),
          latMin: eltResult.centroid.latMin,
          longDeg: eltResult.centroid.lonDeg.toString(),
          longMin: eltResult.centroid.lonMin,
          altMSL: '',
          altAGL: '',
          heading: '',
          airspeed: '',
          groundSpeed: '',
          capGrid: eltResult.capGrid,
          notes: noteText
        };
        setEvents([newEvent, ...events]);
        alert('ELT Estimate logged to Events');
      };

      // Render SVG visualization
      const renderVisualization = () => {
        if (!eltResult || !eltResult.grid.length) return null;
        
        const svgWidth = 320;
        const svgHeight = 280;
        const padding = 25;
        const { bounds: originalBounds, centroid, observations, area50, area90 } = eltResult;
        
        // Apply zoom - shrink bounds around centroid
        const zoomFactor = eltDiagramZoom;
        const latRange = (originalBounds.maxLat - originalBounds.minLat) / zoomFactor;
        const lonRange = (originalBounds.maxLon - originalBounds.minLon) / zoomFactor;
        
        const bounds = {
          minLat: centroid.lat - latRange / 2,
          maxLat: centroid.lat + latRange / 2,
          minLon: centroid.lon - lonRange / 2,
          maxLon: centroid.lon + lonRange / 2
        };
        
        // Scale functions
        const scaleX = (lon) => padding + ((lon - bounds.minLon) / (bounds.maxLon - bounds.minLon)) * (svgWidth - 2 * padding);
        const scaleY = (lat) => svgHeight - padding - ((lat - bounds.minLat) / (bounds.maxLat - bounds.minLat)) * (svgHeight - 2 * padding);
        
        // Check if observation is within bounds (for outlier detection)
        const isInBounds = (obs) => {
          return obs.lat >= bounds.minLat && obs.lat <= bounds.maxLat &&
                 obs.lon >= bounds.minLon && obs.lon <= bounds.maxLon;
        };
        
        // Get max probability for color scaling
        const maxP = Math.max(...eltResult.grid.map(g => g.p));
        
        return React.createElement("svg", {
          width: svgWidth,
          height: svgHeight,
          style: { background: "rgba(0,0,0,0.3)", borderRadius: "8px", display: "block", margin: "0 auto" }
        },
          // 90% area (lighter)
          area90.map((g, i) => React.createElement("rect", {
            key: `a90-${i}`,
            x: scaleX(g.lon) - 2,
            y: scaleY(g.lat) - 2,
            width: 4,
            height: 4,
            fill: `rgba(237,137,54,${0.3 + (g.p / maxP) * 0.4})`
          })),
          // 50% area (brighter)
          area50.map((g, i) => React.createElement("rect", {
            key: `a50-${i}`,
            x: scaleX(g.lon) - 3,
            y: scaleY(g.lat) - 3,
            width: 6,
            height: 6,
            fill: `rgba(252,211,77,${0.5 + (g.p / maxP) * 0.5})`
          })),
          // Observation points (only those in bounds, mark outliers at edge)
          observations.map((obs, i) => {
            const inBounds = isInBounds(obs);
            if (inBounds) {
              return React.createElement("circle", {
                key: `obs-${i}`,
                cx: scaleX(obs.lon),
                cy: scaleY(obs.lat),
                r: 6,
                fill: "#3182ce",
                stroke: "#fff",
                strokeWidth: 2
              });
            } else {
              // Outlier - show as arrow at edge pointing to direction
              const clampedX = Math.max(padding, Math.min(svgWidth - padding, scaleX(obs.lon)));
              const clampedY = Math.max(padding, Math.min(svgHeight - padding, scaleY(obs.lat)));
              return React.createElement("g", { key: `obs-${i}` },
                React.createElement("circle", {
                  cx: clampedX,
                  cy: clampedY,
                  r: 5,
                  fill: "#fc8181",
                  stroke: "#fff",
                  strokeWidth: 1,
                  opacity: 0.6
                }),
                React.createElement("text", {
                  x: clampedX,
                  y: clampedY - 8,
                  fill: "#fc8181",
                  fontSize: "8px",
                  textAnchor: "middle"
                }, "outlier")
              );
            }
          }),
          // Bearing lines (if any)
          observations.filter(o => o.bearing !== null).map((obs, i) => {
            const len = 100;
            const rad = (90 - obs.bearing) * Math.PI / 180;
            const endX = scaleX(obs.lon) + Math.cos(rad) * len;
            const endY = scaleY(obs.lat) - Math.sin(rad) * len;
            return React.createElement("line", {
              key: `bear-${i}`,
              x1: scaleX(obs.lon),
              y1: scaleY(obs.lat),
              x2: endX,
              y2: endY,
              stroke: "#63b3ed",
              strokeWidth: 2,
              strokeDasharray: "4,4",
              opacity: 0.7
            });
          }),
          // Centroid marker
          React.createElement("circle", {
            cx: scaleX(centroid.lon),
            cy: scaleY(centroid.lat),
            r: 8,
            fill: "#e53e3e",
            stroke: "#fff",
            strokeWidth: 2
          }),
          React.createElement("text", {
            x: scaleX(centroid.lon) + 12,
            y: scaleY(centroid.lat) + 4,
            fill: "#fff",
            fontSize: "10px",
            fontWeight: "bold"
          }, "EST")
        );
      };

      return React.createElement("div", null,
        // G1000 Instructions Modal
        renderG1000Modal(),
        // Instructions
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, " ELT Triangulation Assistant"),
          React.createElement("div", { style: styles.sectionBody },
            React.createElement("div", { style: {
              background: "rgba(237,137,54,0.1)",
              padding: "12px",
              borderRadius: "8px",
              marginBottom: "16px",
              border: "1px solid rgba(237,137,54,0.3)"
            }},
              React.createElement("p", { style: { margin: 0, fontSize: "12px", color: "#fbd38d", lineHeight: "1.5" }},
                React.createElement("strong", null, "How to use: "),
                "Import available data sources (ADS-B track, SARSAT pings) and/or add manual observations. ",
                "The Search Probability Model combines all available data to identify likely search areas."
              )
            ),
            
            // DATA SOURCES PANEL
            React.createElement("div", { style: {
              background: "rgba(128,90,213,0.1)",
              padding: "14px",
              borderRadius: "10px",
              marginBottom: "16px",
              border: "2px solid rgba(128,90,213,0.4)"
            }},
              React.createElement("div", { style: { fontSize: "13px", color: "#b794f4", marginBottom: "12px", fontWeight: "700" }}, 
                " SEARCH PROBABILITY MODEL - Data Sources"
              ),
              
              // Data source status indicators
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "10px", marginBottom: "14px" }},
                // ADS-B Status
                React.createElement("div", { style: {
                  padding: "10px",
                  borderRadius: "8px",
                  background: adsbTrack ? "rgba(56,161,105,0.2)" : "rgba(0,0,0,0.2)",
                  border: adsbTrack ? "1px solid rgba(56,161,105,0.5)" : "1px solid rgba(255,255,255,0.1)"
                }},
                  React.createElement("div", { style: { fontSize: "10px", color: adsbTrack ? "#68d391" : "#718096", fontWeight: "600" }}, 
                    adsbTrack ? "\u2714 ADS-B LOADED" : " ADS-B TRACK"
                  ),
                  adsbTrack && React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0", marginTop: "4px" }},
                    `${adsbTrack.aircraftId}  ${adsbTrack.points?.length || 0} pts`
                  )
                ),
                // SARSAT Status
                React.createElement("div", { style: {
                  padding: "10px",
                  borderRadius: "8px",
                  background: eltObservations.some(o => o.source === 'sarsat') ? "rgba(56,161,105,0.2)" : "rgba(0,0,0,0.2)",
                  border: eltObservations.some(o => o.source === 'sarsat') ? "1px solid rgba(56,161,105,0.5)" : "1px solid rgba(255,255,255,0.1)"
                }},
                  React.createElement("div", { style: { fontSize: "10px", color: eltObservations.some(o => o.source === 'sarsat') ? "#68d391" : "#718096", fontWeight: "600" }}, 
                    eltObservations.some(o => o.source === 'sarsat') ? "\u2714 SARSAT LOADED" : " SARSAT PINGS"
                  ),
                  eltObservations.some(o => o.source === 'sarsat') && React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0", marginTop: "4px" }},
                    `${eltObservations.filter(o => o.source === 'sarsat').length} ping(s)`
                  )
                )
              ),
              
              // Import buttons row
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "10px", marginBottom: "12px" }},
                // ADS-B Import
                React.createElement("div", null,
                  React.createElement("input", {
                    type: "file",
                    accept: ".kml,.kmz",
                    onChange: handleAdsbImport,
                    style: { display: "none" },
                    id: "adsb-import-input"
                  }),
                  React.createElement("label", {
                    htmlFor: "adsb-import-input",
                    style: {
                      ...styles.button,
                      display: "block",
                      textAlign: "center",
                      cursor: "pointer",
                      background: "linear-gradient(135deg, #4299e1, #3182ce)",
                      fontSize: "11px",
                      padding: "10px"
                    }
                  }, " Import ADS-B Track")
                ),
                // SARSAT Import
                React.createElement("div", null,
                  React.createElement("input", {
                    type: "file",
                    accept: ".kml,.kmz",
                    onChange: handleSarsatImport,
                    style: { display: "none" },
                    id: "sarsat-import-input"
                  }),
                  React.createElement("label", {
                    htmlFor: "sarsat-import-input",
                    style: {
                      ...styles.button,
                      display: "block",
                      textAlign: "center",
                      cursor: "pointer",
                      background: "linear-gradient(135deg, #ed8936, #dd6b20)",
                      fontSize: "11px",
                      padding: "10px"
                    }
                  }, " Import SARSAT Pings")
                )
              ),
              
              // Help text
              React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0", marginTop: "8px", textAlign: "center" }},
                "Import ADS-B from FlightAware/ADS-B Exchange  SARSAT from USMCC KMZ"
              )
            ),
            
            // ADS-B Track Details (if loaded)
            adsbTrack && React.createElement("div", { style: {
              background: "rgba(66,153,225,0.1)",
              padding: "12px",
              borderRadius: "8px",
              marginBottom: "16px",
              border: "1px solid rgba(66,153,225,0.3)"
            }},
              React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "8px" }},
                React.createElement("div", { style: { fontSize: "12px", color: "#63b3ed", fontWeight: "600" }}, 
                  ` ADS-B: ${adsbTrack.aircraftId}`
                ),
                React.createElement("button", {
                  style: { ...styles.button, padding: "4px 10px", fontSize: "10px", background: "rgba(255,100,100,0.3)" },
                  onClick: () => setAdsbTrack(null)
                }, " Clear")
              ),
              React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0" }},
                adsbTrack.departureAirport && `From: ${adsbTrack.departureAirport}  `,
                `${adsbTrack.points?.length} position reports`,
                React.createElement("br", null),
                `Last: ${adsbTrack.lastPosition?.lat.toFixed(4)}N, ${Math.abs(adsbTrack.lastPosition?.lon).toFixed(4)}W @ ${adsbTrack.lastPosition?.altFt?.toLocaleString()} ft`,
                React.createElement("br", null),
                `Hdg: ${adsbTrack.lastHeading?.toFixed(0)}  GS: ${adsbTrack.lastGroundspeed} kts  Time: ${adsbTrack.lastTime?.split('T')[1]?.replace('Z','')}`
              )
            ),
            
            // Add Observation Form
            React.createElement("div", { style: { 
              background: "rgba(0,0,0,0.2)", 
              padding: "16px", 
              borderRadius: "10px",
              border: "1px solid rgba(255,255,255,0.1)"
            }},
              React.createElement("div", { style: { fontSize: "14px", fontWeight: "700", color: "#fbd38d", marginBottom: "12px" }}, "\u2795 Add Observation"),
              // GPS Capture button
              React.createElement("button", {
                style: { ...styles.button, width: "100%", marginBottom: "12px", background: "linear-gradient(135deg, #38a169, #2f855a)" },
                onClick: captureGPS
              }, " CAPTURE GPS POSITION"),
              // Time
              React.createElement("div", { style: { display: "flex", gap: "8px", marginBottom: "10px" }},
                React.createElement("div", { style: { flex: 1 }},
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Time (UTC)"),
                  React.createElement("input", {
                    style: { ...styles.input, fontSize: "14px" },
                    value: newEltObs.timeZ,
                    onChange: (e) => setNewEltObs({ ...newEltObs, timeZ: e.target.value }),
                    placeholder: "HHMM"
                  })
                ),
                React.createElement("button", {
                  style: { ...styles.button, ...styles.buttonSmall, alignSelf: "flex-end" },
                  onClick: () => setNewEltObs({ ...newEltObs, timeZ: getZuluTimeOnly() })
                }, "NOW")
              ),
              // Position
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: "6px", marginBottom: "10px" }},
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Lat "),
                  React.createElement("input", {
                    style: styles.input,
                    value: newEltObs.latDeg,
                    onChange: (e) => setNewEltObs({ ...newEltObs, latDeg: e.target.value }),
                    placeholder: "39"
                  })
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Lat '"),
                  React.createElement("input", {
                    style: styles.input,
                    value: newEltObs.latMin,
                    onChange: (e) => setNewEltObs({ ...newEltObs, latMin: e.target.value }),
                    placeholder: "45.123"
                  })
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Lon "),
                  React.createElement("input", {
                    style: styles.input,
                    value: newEltObs.lonDeg,
                    onChange: (e) => setNewEltObs({ ...newEltObs, lonDeg: e.target.value }),
                    placeholder: "104"
                  })
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Lon '"),
                  React.createElement("input", {
                    style: styles.input,
                    value: newEltObs.lonMin,
                    onChange: (e) => setNewEltObs({ ...newEltObs, lonMin: e.target.value }),
                    placeholder: "52.456"
                  })
                )
              ),
              // Altitude
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px", marginBottom: "10px" }},
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Alt MSL (ft)"),
                  React.createElement("input", {
                    style: styles.input,
                    value: newEltObs.altMSL,
                    onChange: (e) => setNewEltObs({ ...newEltObs, altMSL: e.target.value }),
                    placeholder: "8500"
                  })
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Alt AGL (ft)"),
                  React.createElement("input", {
                    style: styles.input,
                    value: newEltObs.altAGL,
                    onChange: (e) => setNewEltObs({ ...newEltObs, altAGL: e.target.value }),
                    placeholder: "3000"
                  })
                )
              ),
              // Signal Strength
              React.createElement("div", { style: { marginBottom: "12px" }},
                React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, 
                  "Signal Strength: ", 
                  React.createElement("span", { style: { color: "#fbd38d", fontWeight: "700" }}, newEltObs.strength, "/10")
                ),
                React.createElement("input", {
                  type: "range",
                  min: "1",
                  max: "10",
                  value: newEltObs.strength,
                  onChange: (e) => setNewEltObs({ ...newEltObs, strength: e.target.value }),
                  style: { width: "100%", marginTop: "6px" }
                }),
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", fontSize: "9px", color: "#718096" }},
                  React.createElement("span", null, "1 = Weak"),
                  React.createElement("span", null, "10 = Strong")
                ),
                // Show estimated range based on strength and altitude
                newEltObs.altAGL && React.createElement("div", { 
                  style: { 
                    marginTop: "8px", 
                    padding: "8px", 
                    background: "rgba(246,224,94,0.1)", 
                    borderRadius: "6px",
                    border: "1px solid rgba(246,224,94,0.2)",
                    fontSize: "10px"
                  }
                },
                  (() => {
                    const est = estimateSearchRange(parseInt(newEltObs.strength) || 5, parseFloat(newEltObs.altAGL));
                    if (!est) return null;
                    return React.createElement(React.Fragment, null,
                      React.createElement("div", { style: { color: "#a0aec0", marginBottom: "4px" }},
                        " Radio Horizon: ", 
                        React.createElement("span", { style: { color: "#63b3ed", fontWeight: "600" }}, est.horizon, " NM"),
                        " (at ", newEltObs.altAGL, " ft AGL)"
                      ),
                      React.createElement("div", { style: { color: "#f6e05e" }},
                        " Est. Range: ",
                        React.createElement("span", { style: { fontWeight: "700" }}, est.minRange, " - ", est.maxRange, " NM"),
                        " (~", est.pct, "% of horizon)"
                      )
                    );
                  })()
                )
              ),
              // Direct Range (optional - overrides strength)
              React.createElement("div", { style: { 
                marginBottom: "12px",
                padding: "10px",
                background: "rgba(99,179,237,0.1)",
                borderRadius: "8px",
                border: "1px solid rgba(99,179,237,0.2)"
              }},
                React.createElement("div", { style: { fontSize: "10px", color: "#63b3ed", marginBottom: "8px" }}, 
                  " Direct Range (optional - overrides strength estimate)"
                ),
                React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px" }},
                  React.createElement("div", null,
                    React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Range (NM)"),
                    React.createElement("input", {
                      style: styles.input,
                      value: newEltObs.directRange,
                      onChange: (e) => setNewEltObs({ ...newEltObs, directRange: e.target.value }),
                      placeholder: "e.g. 5.2"
                    })
                  ),
                  React.createElement("div", null,
                    React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, " Accuracy (NM)"),
                    React.createElement("input", {
                      style: styles.input,
                      value: newEltObs.rangeAccuracy,
                      onChange: (e) => setNewEltObs({ ...newEltObs, rangeAccuracy: e.target.value }),
                      placeholder: "e.g. 1.0"
                    })
                  )
                )
              ),
              // DF Bearing (optional)
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "2fr 1fr 1fr", gap: "8px", marginBottom: "10px" }},
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "DF Bearing (optional)"),
                  React.createElement("input", {
                    style: styles.input,
                    value: newEltObs.dfBearing,
                    onChange: (e) => setNewEltObs({ ...newEltObs, dfBearing: e.target.value }),
                    placeholder: "248"
                  })
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Ref"),
                  React.createElement("select", {
                    style: { ...styles.input, padding: "10px" },
                    value: newEltObs.bearingRef,
                    onChange: (e) => setNewEltObs({ ...newEltObs, bearingRef: e.target.value })
                  },
                    React.createElement("option", { value: "MAG" }, "MAG"),
                    React.createElement("option", { value: "TRUE" }, "TRUE")
                  )
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, ""),
                  React.createElement("input", {
                    style: styles.input,
                    value: newEltObs.bearingAccuracy,
                    onChange: (e) => setNewEltObs({ ...newEltObs, bearingAccuracy: e.target.value }),
                    placeholder: "20"
                  })
                )
              ),
              // Source
              React.createElement("div", { style: { marginBottom: "10px" }},
                React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Signal Source"),
                React.createElement("div", { style: { display: "flex", gap: "6px", marginTop: "6px" }},
                  ["audio", "df", "both", "sarsat"].map(src => 
                    React.createElement("button", {
                      key: src,
                      style: {
                        ...styles.button,
                        ...styles.buttonSmall,
                        flex: 1,
                        background: newEltObs.source === src ? "linear-gradient(135deg, #ed8936, #dd6b20)" : "rgba(0,0,0,0.3)",
                        border: newEltObs.source === src ? "2px solid #fbd38d" : "1px solid rgba(255,255,255,0.1)"
                      },
                      onClick: () => setNewEltObs({ ...newEltObs, source: src })
                    }, src.toUpperCase())
                  )
                )
              ),
              // Notes
              React.createElement("div", { style: { marginBottom: "12px" }},
                React.createElement("label", { style: { fontSize: "10px", color: "#a0aec0" }}, "Notes"),
                React.createElement("input", {
                  style: styles.input,
                  value: newEltObs.notes,
                  onChange: (e) => setNewEltObs({ ...newEltObs, notes: e.target.value }),
                  placeholder: "Polarity, antenna, reflections suspected..."
                })
              ),
              // Add button
              React.createElement("button", {
                style: { ...styles.button, width: "100%", background: "linear-gradient(135deg, #ed8936, #dd6b20)" },
                onClick: addObservation
              }, "\u2795 ADD OBSERVATION")
            )
          )
        ),

        // Observations List
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, 
            " Observations (", eltObservations.length, ")",
            eltObservations.length > 0 && React.createElement("button", {
              style: { ...styles.button, ...styles.buttonSmall, marginLeft: "auto", background: "#e53e3e" },
              onClick: () => { if (confirm("Clear all observations?")) { setEltObservations([]); setEltResult(null); } }
            }, "CLEAR ALL")
          ),
          React.createElement("div", { style: styles.sectionBody },
            eltObservations.length === 0 
              ? React.createElement("div", { style: { textAlign: "center", color: "#718096", padding: "20px" }}, "No observations yet")
              : eltObservations.map((obs, idx) => 
                  React.createElement("div", { 
                    key: obs.id,
                    style: {
                      background: obs.useInCalc ? "rgba(56,161,105,0.1)" : "rgba(0,0,0,0.2)",
                      padding: "12px",
                      borderRadius: "8px",
                      marginBottom: "8px",
                      border: obs.useInCalc ? "1px solid rgba(104,211,145,0.3)" : "1px solid rgba(255,255,255,0.1)",
                      opacity: obs.useInCalc ? 1 : 0.6
                    }
                  },
                    React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "8px" }},
                      React.createElement("span", { style: { fontWeight: "700", color: "#fbd38d" }}, "#", obs.obsNum, " - ", obs.timeZ, "Z"),
                      React.createElement("div", { style: { display: "flex", gap: "6px" }},
                        React.createElement("button", {
                          style: { ...styles.button, ...styles.buttonSmall, fontSize: "10px", padding: "6px 10px" },
                          onClick: () => logObservationToEvents(obs)
                        }, "LOG"),
                        React.createElement("button", {
                          style: { ...styles.button, ...styles.buttonSmall, fontSize: "10px", padding: "6px 10px", background: obs.useInCalc ? "#38a169" : "#718096" },
                          onClick: () => toggleObsUse(obs.id)
                        }, obs.useInCalc ? "\u2714 USE" : "SKIP"),
                        React.createElement("button", {
                          style: { ...styles.button, ...styles.buttonSmall, ...styles.buttonDanger, fontSize: "10px", padding: "6px 10px" },
                          onClick: () => removeObservation(obs.id)
                        }, "")
                      )
                    ),
                    React.createElement("div", { style: { fontSize: "11px", color: "#e2e8f0" }},
                      `N ${obs.latDeg} ${obs.latMin}' W ${obs.lonDeg} ${obs.lonMin}' | `,
                      obs.directRange ? `Range: ${obs.directRange} NM${obs.rangeAccuracy ? ` ${obs.rangeAccuracy}` : ''} | ` : `Str: ${obs.strength}/10 | `,
                      obs.dfBearing && `DF: ${obs.dfBearing} ${obs.bearingRef} | `,
                      `Src: ${obs.source}`,
                      obs.notes && React.createElement("div", { style: { color: "#a0aec0", marginTop: "4px" }}, obs.notes)
                    )
                  )
                )
          )
        ),

        // Compute Section
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, " Compute Probable Area"),
          React.createElement("div", { style: styles.sectionBody },
            // Confidence Mode Selector
            React.createElement("div", { style: { 
              marginBottom: "16px",
              padding: "12px",
              background: "rgba(99,179,237,0.1)",
              borderRadius: "8px",
              border: "1px solid rgba(99,179,237,0.2)"
            }},
              React.createElement("div", { style: { fontSize: "11px", color: "#63b3ed", marginBottom: "8px", fontWeight: "600" }}, 
                " CONFIDENCE MODE"
              ),
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: "6px", marginBottom: "10px" }},
                ["auto", "conservative", "moderate", "aggressive"].map(mode => 
                  React.createElement("button", {
                    key: mode,
                    style: {
                      ...styles.button,
                      ...styles.buttonSmall,
                      fontSize: "9px",
                      padding: "8px 4px",
                      background: eltSettings.confidenceMode === mode 
                        ? "linear-gradient(135deg, #3182ce, #2b6cb0)" 
                        : "rgba(0,0,0,0.3)",
                      border: eltSettings.confidenceMode === mode 
                        ? "2px solid #63b3ed" 
                        : "1px solid rgba(255,255,255,0.1)"
                    },
                    onClick: () => setEltSettings({ ...eltSettings, confidenceMode: mode })
                  }, mode.toUpperCase())
                )
              ),
              React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0", lineHeight: "1.4" }},
                eltSettings.confidenceMode === 'auto' && " AUTO: Adjusts based on data quality - more data/DF = tighter area",
                eltSettings.confidenceMode === 'conservative' && " CONSERVATIVE: Wide search area (100% uncertainty) - safest option",
                eltSettings.confidenceMode === 'moderate' && "\u2696 MODERATE: Balanced search area (50% uncertainty)",
                eltSettings.confidenceMode === 'aggressive' && " AGGRESSIVE: Tight search area (25% uncertainty) - use with good data only"
              )
            ),
            // Calculate button
            React.createElement("button", {
              style: { 
                ...styles.button, 
                width: "100%", 
                padding: "16px",
                fontSize: "16px",
                background: eltObservations.filter(o => o.useInCalc).length >= 2 
                  ? "linear-gradient(135deg, #e53e3e, #c53030)" 
                  : "rgba(0,0,0,0.3)",
                opacity: eltObservations.filter(o => o.useInCalc).length >= 2 ? 1 : 0.5
              },
              onClick: computeProbableArea,
              disabled: eltObservations.filter(o => o.useInCalc).length < 2
            }, " CALCULATE ELT LOCATION"),
            
            // Results
            eltResult && React.createElement("div", { style: { marginTop: "16px" }},
              // G1000 SAR Programming Guide - TOP OF RESULTS
              React.createElement("div", { 
                style: { 
                  marginBottom: "16px",
                  padding: "16px",
                  background: "linear-gradient(135deg, #744210, #5c3d0e)",
                  borderRadius: "12px",
                  border: "3px solid #d69e2e",
                  textAlign: "center",
                  boxShadow: "0 4px 20px rgba(214,158,46,0.5)"
                }
              },
                React.createElement("div", { style: { fontSize: "11px", color: "#fbd38d", marginBottom: "8px", textTransform: "uppercase", letterSpacing: "1px" }}, 
                  "Program this solution into your aircraft"
                ),
                React.createElement("button", {
                  style: { 
                    background: "linear-gradient(135deg, #d69e2e, #b7791f)",
                    border: "2px solid #ecc94b",
                    borderRadius: "8px",
                    padding: "14px 32px",
                    color: "#fff",
                    fontSize: "16px",
                    fontWeight: "700",
                    cursor: "pointer",
                    boxShadow: "0 4px 12px rgba(0,0,0,0.3)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    gap: "8px",
                    margin: "0 auto"
                  },
                  onClick: () => setShowG1000Instructions(true)
                }, " G1000 SAR Programming Guide")
              ),
              // Quality Assessment
              React.createElement("div", { style: { 
                display: "flex", 
                justifyContent: "space-between", 
                alignItems: "center",
                padding: "10px 12px",
                background: "rgba(0,0,0,0.2)",
                borderRadius: "8px",
                marginBottom: "12px"
              }},
                React.createElement("div", null,
                  React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0" }}, "DATA QUALITY"),
                  React.createElement("div", { style: { 
                    fontSize: "12px", 
                    fontWeight: "700", 
                    color: eltResult.qualityScore >= 70 ? "#68d391" : 
                           eltResult.qualityScore >= 50 ? "#f6e05e" : 
                           eltResult.qualityScore >= 30 ? "#ed8936" : "#fc8181"
                  }}, eltResult.qualityScore, "/100 - ", eltResult.qualityLabel)
                ),
                React.createElement("div", { style: { textAlign: "right" }},
                  React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0" }}, "SOLUTION #", eltResult.solutionNum),
                  React.createElement("div", { style: { fontSize: "11px", color: "#e2e8f0" }}, 
                    eltResult.obsCount, " obs", eltResult.dfCount > 0 && ` (${eltResult.dfCount} DF)`
                  )
                )
              ),
              // Map/SVG Toggle and Visualization
              React.createElement("div", { style: { marginBottom: "16px" }},
                React.createElement("div", { style: { display: "flex", gap: "8px", marginBottom: "12px", justifyContent: "center" }},
                  React.createElement("button", {
                    style: {
                      ...styles.button,
                      ...styles.buttonSmall,
                      background: !eltShowMap ? "linear-gradient(135deg, #805ad5, #6b46c1)" : "rgba(0,0,0,0.3)",
                      border: !eltShowMap ? "2px solid #805ad5" : "1px solid rgba(255,255,255,0.2)"
                    },
                    onClick: () => setEltShowMap(false)
                  }, " Diagram"),
                  React.createElement("button", {
                    style: {
                      ...styles.button,
                      ...styles.buttonSmall,
                      background: eltShowMap ? "linear-gradient(135deg, #38a169, #2f855a)" : "rgba(0,0,0,0.3)",
                      border: eltShowMap ? "2px solid #38a169" : "1px solid rgba(255,255,255,0.2)"
                    },
                    onClick: () => {
                      setEltShowMap(true);
                      // Initialize map after state update
                      setTimeout(() => {
                        if (eltMapRef.current) {
                          eltMapRef.current.remove();
                          eltMapRef.current = null;
                        }
                        const el = document.getElementById('eltMapDiv');
                        if (!el || !eltResult) return;
                        try {
                          const map = L.map('eltMapDiv').setView([eltResult.centroid.lat, eltResult.centroid.lon], 12);
                          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: ' OpenStreetMap'
                          }).addTo(map);
                          
                          // Standard Map Colors for high visibility on OSM:
                          // 90% area: gray with low opacity
                          // 50% area: darker gray 
                          // Observations: dark blue
                          // Bearing lines: black
                          // Centroid: dark red
                          
                          // Add 90% confidence area (gray, outer)
                          if (eltResult.area90 && eltResult.area90.length > 0) {
                            eltResult.area90.forEach(g => {
                              L.circleMarker([g.lat, g.lon], {
                                radius: 4,
                                fillColor: '#666666',
                                color: '#666666',
                                weight: 1,
                                fillOpacity: 0.3
                              }).addTo(map);
                            });
                          }
                          
                          // Add 50% confidence area (darker, inner)
                          if (eltResult.area50 && eltResult.area50.length > 0) {
                            eltResult.area50.forEach(g => {
                              L.circleMarker([g.lat, g.lon], {
                                radius: 5,
                                fillColor: '#333333',
                                color: '#333333',
                                weight: 1,
                                fillOpacity: 0.5
                              }).addTo(map);
                            });
                          }
                          
                          // Add observation points (dark blue with white fill)
                          eltResult.observations.forEach((obs, i) => {
                            L.circleMarker([obs.lat, obs.lon], {
                              radius: 8,
                              fillColor: '#ffffff',
                              color: '#0066cc',
                              weight: 3,
                              fillOpacity: 1.0
                            }).addTo(map).bindPopup('Obs #' + (i+1) + '<br>Strength: ' + (obs.strength || 'N/A'));
                            
                            // Add bearing lines if present (black, thick)
                            if (obs.bearing !== null && obs.bearing !== undefined) {
                              const len = 0.05; // degrees
                              const rad = (90 - obs.bearing) * Math.PI / 180;
                              const endLat = obs.lat + Math.sin(rad) * len;
                              const endLon = obs.lon + Math.cos(rad) * len;
                              L.polyline([[obs.lat, obs.lon], [endLat, endLon]], {
                                color: '#000000',
                                weight: 3,
                                dashArray: '8,6',
                                opacity: 1.0
                              }).addTo(map);
                            }
                          });
                          
                          // Add centroid marker (dark red) - most important, high visibility
                          L.circleMarker([eltResult.centroid.lat, eltResult.centroid.lon], {
                            radius: 14,
                            fillColor: '#cc0000',
                            color: '#ffffff',
                            weight: 4,
                            fillOpacity: 1.0
                          }).addTo(map).bindPopup(
                            '<strong>Estimated ELT Location</strong><br>' +
                            'N ' + eltResult.centroid.latDeg + ' ' + eltResult.centroid.latMin + "'<br>" +
                            'W ' + eltResult.centroid.lonDeg + ' ' + eltResult.centroid.lonMin + "'<br>" +
                            'Grid: ' + eltResult.capGrid
                          ).openPopup();
                          
                          // Fit bounds to show all points
                          const allPoints = [
                            [eltResult.centroid.lat, eltResult.centroid.lon],
                            ...eltResult.observations.map(o => [o.lat, o.lon])
                          ];
                          if (allPoints.length > 1) {
                            map.fitBounds(allPoints, { padding: [30, 30] });
                          }
                          
                          eltMapRef.current = map;
                        } catch (e) {
                          console.error('Map error:', e);
                          setEltShowMap(false);
                          alert('Could not load map. Check internet connection.');
                        }
                      }, 100);
                    }
                  }, " Map")
                ),
                // Zoom controls for diagram view
                !eltShowMap && React.createElement("div", { 
                  style: { 
                    display: "flex", 
                    justifyContent: "center", 
                    alignItems: "center",
                    gap: "8px", 
                    marginBottom: "8px" 
                  }
                },
                  React.createElement("button", {
                    style: {
                      background: "rgba(99,179,237,0.2)",
                      border: "1px solid rgba(99,179,237,0.5)",
                      borderRadius: "6px",
                      padding: "6px 12px",
                      color: "#63b3ed",
                      cursor: "pointer",
                      fontSize: "14px",
                      fontWeight: "bold"
                    },
                    onClick: () => setEltDiagramZoom(z => Math.max(0.5, z / 1.5))
                  }, " Zoom Out"),
                  React.createElement("span", { 
                    style: { 
                      color: "#a0aec0", 
                      fontSize: "11px",
                      minWidth: "60px",
                      textAlign: "center"
                    } 
                  }, `${(eltDiagramZoom * 100).toFixed(0)}%`),
                  React.createElement("button", {
                    style: {
                      background: "rgba(99,179,237,0.2)",
                      border: "1px solid rgba(99,179,237,0.5)",
                      borderRadius: "6px",
                      padding: "6px 12px",
                      color: "#63b3ed",
                      cursor: "pointer",
                      fontSize: "14px",
                      fontWeight: "bold"
                    },
                    onClick: () => setEltDiagramZoom(z => Math.min(20, z * 1.5))
                  }, "\u2795 Zoom In"),
                  React.createElement("button", {
                    style: {
                      background: "rgba(246,224,94,0.2)",
                      border: "1px solid rgba(246,224,94,0.5)",
                      borderRadius: "6px",
                      padding: "6px 12px",
                      color: "#f6e05e",
                      cursor: "pointer",
                      fontSize: "11px",
                      marginLeft: "8px"
                    },
                    onClick: () => setEltDiagramZoom(1.0)
                  }, "Reset")
                ),
                // Show either SVG or Map
                !eltShowMap ? renderVisualization() : 
                  React.createElement("div", {
                    id: "eltMapDiv",
                    style: {
                      width: "100%",
                      height: "300px",
                      borderRadius: "8px",
                      overflow: "hidden"
                    }
                  })
              ),
              // Legend
              React.createElement("div", { style: { display: "flex", justifyContent: "center", gap: "16px", marginBottom: "12px", fontSize: "10px" }},
                React.createElement("span", null, React.createElement("span", { style: { display: "inline-block", width: "12px", height: "12px", background: "#3182ce", borderRadius: "50%", marginRight: "4px" }}), "Observation"),
                React.createElement("span", null, React.createElement("span", { style: { display: "inline-block", width: "12px", height: "12px", background: "#fcd34d", marginRight: "4px" }}), "50% Area"),
                React.createElement("span", null, React.createElement("span", { style: { display: "inline-block", width: "12px", height: "12px", background: "#ed8936", marginRight: "4px" }}), "90% Area"),
                React.createElement("span", null, React.createElement("span", { style: { display: "inline-block", width: "12px", height: "12px", background: "#e53e3e", borderRadius: "50%", marginRight: "4px" }}), "Estimate")
              ),
              // Result details
              React.createElement("div", { style: { 
                background: "rgba(229,62,62,0.15)", 
                padding: "16px", 
                borderRadius: "10px",
                border: "2px solid #e53e3e"
              }},
                React.createElement("div", { style: { fontSize: "12px", color: "#fc8181", textTransform: "uppercase", marginBottom: "8px" }}, "Best Estimate Location"),
                React.createElement("div", { style: { fontSize: "18px", fontWeight: "700", color: "#fff", marginBottom: "8px" }},
                  `N ${eltResult.centroid.latDeg} ${eltResult.centroid.latMin}' W ${eltResult.centroid.lonDeg} ${eltResult.centroid.lonMin}'`
                ),
                React.createElement("div", { style: { fontSize: "14px", color: "#fbd38d", marginBottom: "8px" }},
                  "CAP Grid: ", eltResult.capGrid
                ),
                // Data Sources Summary
                React.createElement("div", { style: { 
                  background: "rgba(128,90,213,0.2)", 
                  padding: "8px 12px", 
                  borderRadius: "6px", 
                  marginBottom: "12px",
                  fontSize: "11px",
                  border: "1px solid rgba(128,90,213,0.4)"
                }},
                  React.createElement("span", { style: { color: "#b794f4", fontWeight: "600" }}, "Data Sources: "),
                  React.createElement("span", { style: { color: "#e2e8f0" }},
                    [
                      eltResult.adsbData && ` ADS-B (${eltResult.adsbData.aircraftId})`,
                      eltResult.sourceBreakdown?.sarsat > 0 && ` SARSAT (${eltResult.sourceBreakdown.sarsat} pings)`,
                      eltResult.sourceBreakdown?.audio > 0 && ` Audio (${eltResult.sourceBreakdown.audio})`,
                      eltResult.sourceBreakdown?.df > 0 && ` DF (${eltResult.sourceBreakdown.df})`
                    ].filter(Boolean).join("  ") || "Manual observations only"
                  )
                ),
                // ADS-B Last Known (if available)
                eltResult.adsbData && React.createElement("div", { style: { 
                  background: "rgba(66,153,225,0.15)", 
                  padding: "8px 12px", 
                  borderRadius: "6px", 
                  marginBottom: "12px",
                  fontSize: "10px",
                  border: "1px solid rgba(66,153,225,0.3)"
                }},
                  React.createElement("div", { style: { color: "#63b3ed", fontWeight: "600", marginBottom: "4px" }}, " Last ADS-B Position"),
                  React.createElement("div", { style: { color: "#a0aec0" }},
                    `${eltResult.adsbData.lastLat?.toFixed(4)}N, ${Math.abs(eltResult.adsbData.lastLon)?.toFixed(4)}W @ ${eltResult.adsbData.lastAlt?.toLocaleString()} ft`,
                    React.createElement("br", null),
                    `Hdg: ${eltResult.adsbData.lastHdg?.toFixed(0)}  GS: ${eltResult.adsbData.lastSpd} kts  Max Range: ${eltResult.adsbData.maxRangeNm?.toFixed(1)} NM`
                  )
                ),
                // SARSAT Weighted Centroid (if available)
                eltResult.sarsatCentroid && React.createElement("div", { style: { 
                  background: "rgba(237,137,54,0.15)", 
                  padding: "8px 12px", 
                  borderRadius: "6px", 
                  marginBottom: "12px",
                  fontSize: "10px",
                  border: "1px solid rgba(237,137,54,0.3)"
                }},
                  React.createElement("div", { style: { color: "#ed8936", fontWeight: "600", marginBottom: "4px" }}, " SARSAT Weighted Center"),
                  React.createElement("div", { style: { color: "#a0aec0" }},
                    `N ${eltResult.sarsatCentroid.latDeg} ${eltResult.sarsatCentroid.latMin}' W ${eltResult.sarsatCentroid.lonDeg} ${eltResult.sarsatCentroid.lonMin}'`,
                    ` (${eltResult.sarsatCentroid.obsCount} pings, min error: ${eltResult.sarsatCentroid.minError?.toFixed(1)} NM)`
                  )
                ),
                React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px", fontSize: "12px" }},
                  React.createElement("div", { style: { background: "rgba(0,0,0,0.2)", padding: "8px", borderRadius: "6px" }},
                    React.createElement("div", { style: { color: "#a0aec0" }}, "50% Confidence"),
                    React.createElement("div", { style: { color: "#fcd34d", fontWeight: "700" }}, eltResult.area50SizeNm2, " NM")
                  ),
                  React.createElement("div", { style: { background: "rgba(0,0,0,0.2)", padding: "8px", borderRadius: "6px" }},
                    React.createElement("div", { style: { color: "#a0aec0" }}, "90% Confidence"),
                    React.createElement("div", { style: { color: "#ed8936", fontWeight: "700" }}, eltResult.area90SizeNm2, " NM")
                  )
                ),
                React.createElement("div", { style: { marginTop: "12px", display: "flex", gap: "8px", flexWrap: "wrap" }},
                  React.createElement("button", {
                    style: { ...styles.button, flex: 1, minWidth: "140px" },
                    onClick: logSolutionToEvents
                  }, " LOG TO EVENTS"),
                  React.createElement("button", {
                    style: { ...styles.button, flex: 1, minWidth: "140px", background: "linear-gradient(135deg, #38a169, #2f855a)" },
                    onClick: viewEltMap
                  }, " VIEW MAP")
                ),
                // G1000 SAR Programming Guide Button
                React.createElement("div", { style: { marginTop: "8px" }},
                  React.createElement("button", {
                    style: { 
                      ...styles.button, 
                      width: "100%",
                      background: "linear-gradient(135deg, #d69e2e, #b7791f)",
                      border: "2px solid #d69e2e",
                      fontSize: "13px",
                      padding: "12px"
                    },
                    onClick: () => setShowG1000Instructions(true)
                  }, " G1000 SAR PROGRAMMING GUIDE")
                ),
                React.createElement("div", { style: { marginTop: "8px", display: "flex", gap: "8px", flexWrap: "wrap" }},
                  React.createElement("button", {
                    style: { ...styles.button, flex: 1, minWidth: "140px", background: "linear-gradient(135deg, #805ad5, #6b46c1)" },
                    onClick: () => {
                      const coordStr = eltResult.centroid.lat.toFixed(6) + ", " + eltResult.centroid.lon.toFixed(6);
                      const parsed = spParseCoordinate(coordStr);
                      setSpState(s => ({ 
                        ...s, 
                        poiInput: coordStr, 
                        poi: parsed, 
                        detectedGrid: parsed ? spDetectCapGrid(parsed.latDD, parsed.lonDD) : null,
                        patternType: 'expandingSquare'
                      }));
                      switchTab("searchPlanner");
                    }
                  }, " EXPANDING SQ"),
                  React.createElement("button", {
                    style: { ...styles.button, flex: 1, minWidth: "140px", background: "linear-gradient(135deg, #d69e2e, #b7791f)" },
                    onClick: () => {
                      const coordStr = eltResult.centroid.lat.toFixed(6) + ", " + eltResult.centroid.lon.toFixed(6);
                      const parsed = spParseCoordinate(coordStr);
                      setSpState(s => ({ 
                        ...s, 
                        poiInput: coordStr, 
                        poi: parsed, 
                        detectedGrid: parsed ? spDetectCapGrid(parsed.latDD, parsed.lonDD) : null,
                        patternType: 'poiCenteredParallel'
                      }));
                      switchTab("searchPlanner");
                    }
                  }, " POI PARALLEL")
                )
              ),
              // Warning
              React.createElement("div", { style: { 
                marginTop: "12px", 
                padding: "10px", 
                background: "rgba(214,158,46,0.1)", 
                borderRadius: "6px",
                border: "1px solid rgba(246,224,94,0.3)",
                fontSize: "10px",
                color: "#f6e05e"
              }},
                " This is a probability estimate. Reflections, terrain, and signal multipath can cause errors. ",
                "Always verify with additional observations from different angles."
              )
            )
          )
        ),

        // Solutions History Section
        eltSolutions.length > 0 && React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, 
            " Solution History (", eltSolutions.length, ")",
            React.createElement("button", {
              style: { ...styles.button, ...styles.buttonSmall, marginLeft: "auto", background: "#e53e3e", fontSize: "9px" },
              onClick: () => { if (confirm("Clear all solution history?")) setEltSolutions([]); }
            }, "CLEAR")
          ),
          React.createElement("div", { style: styles.sectionBody },
            React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", marginBottom: "12px" }},
              "Track how your estimate improves as you add more observations"
            ),
            eltSolutions.slice(0, 10).map((sol, idx) => 
              React.createElement("div", { 
                key: sol.id,
                style: {
                  background: idx === 0 ? "rgba(56,161,105,0.15)" : "rgba(0,0,0,0.2)",
                  padding: "10px 12px",
                  borderRadius: "8px",
                  marginBottom: "6px",
                  border: idx === 0 ? "1px solid rgba(104,211,145,0.3)" : "1px solid rgba(255,255,255,0.05)"
                }
              },
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start" }},
                  React.createElement("div", null,
                    React.createElement("div", { style: { fontSize: "11px", fontWeight: "700", color: idx === 0 ? "#68d391" : "#e2e8f0" }},
                      idx === 0 ? " CURRENT - " : "",
                      "Solution #", sol.solutionNum, " @ ", sol.timestamp, "Z"
                    ),
                    React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", marginTop: "2px" }},
                      `N ${sol.centroid.latDeg} ${sol.centroid.latMin}' W ${sol.centroid.lonDeg} ${sol.centroid.lonMin}'`
                    )
                  ),
                  React.createElement("div", { style: { textAlign: "right" }},
                    React.createElement("div", { style: { fontSize: "10px", color: "#fbd38d" }}, 
                      sol.area90SizeNm2, " NM"
                    ),
                    React.createElement("div", { style: { fontSize: "9px", color: "#718096" }},
                      sol.obsCount, " obs", sol.dfCount > 0 && ` / ${sol.dfCount} DF`
                    )
                  )
                )
              )
            ),
            eltSolutions.length > 10 && React.createElement("div", { style: { textAlign: "center", fontSize: "10px", color: "#718096", marginTop: "8px" }},
              `+ ${eltSolutions.length - 10} more solutions...`
            )
          )
        ),
        // Inline Map Modal
        eltShowMapModal && React.createElement("div", {
          style: {
            position: "fixed",
            top: 0, left: 0, right: 0, bottom: 0,
            background: "rgba(0,0,0,0.95)",
            zIndex: 10000,
            display: "flex",
            flexDirection: "column"
          }
        },
          // Modal header
          React.createElement("div", {
            style: {
              padding: "12px 16px",
              background: "linear-gradient(135deg, #1a202c, #2d3748)",
              borderBottom: "2px solid #ed8936",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              gap: "12px"
            }
          },
            React.createElement("div", { style: { fontSize: "16px", fontWeight: "700", color: "#f6e05e" } }, "\u{1F4E1} ELT Triangulation Map"),
            React.createElement("div", { style: { display: "flex", gap: "8px" } },
              React.createElement("button", {
                onClick: popOutEltMap,
                style: { background: "rgba(49,130,206,0.3)", border: "2px solid #63b3ed", borderRadius: "8px", padding: "8px 16px", color: "#63b3ed", fontWeight: "700", cursor: "pointer", fontSize: "14px" }
              }, "\u{1F5D7} Pop Out"),
              React.createElement("button", {
                onClick: () => setEltShowMapModal(false),
                style: { background: "rgba(229,62,62,0.3)", border: "2px solid #fc8181", borderRadius: "8px", padding: "8px 16px", color: "#fc8181", fontWeight: "700", cursor: "pointer", fontSize: "14px" }
              }, "\u2715 Close")
            )
          ),
          // Map iframe container
          React.createElement("div", { style: { flex: 1, position: "relative", minHeight: 0 } },
            React.createElement("iframe", {
              srcDoc: eltMapHtml,
              style: { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", border: "none" },
              title: "ELT Triangulation Map"
            })
          )
        )
      );
    };

    // Radio Calls Quick Reference Tab
    const renderRadioTab = () => {
      // Default call signs for examples
      const acSign = radioCallSigns.aircraft || 'CAP 2127';
      const baseSign = radioCallSigns.missionBase || 'RED CAP BASE';
      
      const radioCalls = [
        {
          id: 'engineStart',
          title: ' Engine Start',
          situation: 'Reporting engine start time to Mission Base',
          template: '[MISSION BASE], THIS IS [AIRCRAFT], ENGINE START TIME [TIME] ZULU, OVER.',
          example: `${baseSign}, THIS IS ${acSign}, ENGINE START TIME ____ ZULU, OVER.`,
          response: `Expected: "${acSign}, ${baseSign}, ROGER, OUT." or acknowledgment with instructions.`,
          tips: [
            'Use 4-digit Zulu time (24-hour format)',
            'Wait for acknowledgment before proceeding',
            'Log the time in your mission log'
          ]
        },
        {
          id: 'wheelsUp',
          title: ' Wheels Up / Airborne',
          situation: 'Reporting takeoff and departure',
          template: '[MISSION BASE], THIS IS [AIRCRAFT], WHEELS UP [TIME] ZULU, DEPARTING [LOCATION], PROCEEDING TO [DESTINATION/GRID], OVER.',
          example: `${baseSign}, THIS IS ${acSign}, WHEELS UP ____ ZULU, DEPARTING [AIRPORT], PROCEEDING TO SEARCH GRID [GRID], OVER.`,
          response: 'Expected: Acknowledgment with any updated instructions or weather.',
          tips: [
            'Report immediately after reaching safe altitude',
            'Include departure point and destination',
            'Note assigned altitude if relevant'
          ]
        },
        {
          id: 'inGrid',
          title: ' In Grid / On Station',
          situation: 'Reporting arrival at search area',
          template: '[MISSION BASE], THIS IS [AIRCRAFT], IN GRID [GRID DESIGNATOR] AT [TIME] ZULU, ALTITUDE [ALT] FEET, COMMENCING SEARCH, OVER.',
          example: `${baseSign}, THIS IS ${acSign}, IN GRID [GRID] AT ____ ZULU, ALTITUDE ____ FEET, COMMENCING SEARCH, OVER.`,
          response: 'Expected: Acknowledgment, confirm search pattern, OPS NORMAL schedule.',
          tips: [
            'Report grid designator clearly',
            'Include your search altitude',
            'Confirm OPS NORMAL reporting interval'
          ]
        },
        {
          id: 'opsNormal',
          title: '\u2714 OPS Normal',
          situation: 'Periodic status report (typically every 15-30 min)',
          template: '[MISSION BASE], THIS IS [AIRCRAFT], OPS NORMAL, [POSITION/GRID], OVER.',
          example: `${baseSign}, THIS IS ${acSign}, OPS NORMAL, GRID [GRID], OVER.`,
          response: 'Expected: "ROGER" or updated instructions.',
          tips: [
            'Report at scheduled intervals',
            'Include current position/grid',
            'Report any weather changes',
            'Missing OPS NORMAL triggers alert procedures'
          ]
        },
        {
          id: 'targetFound',
          title: ' Target Acquired',
          situation: 'Reporting sighting or target location',
          template: '[MISSION BASE], THIS IS [AIRCRAFT], TARGET ACQUIRED, PREPARE TO COPY COORDINATES, OVER.',
          example: `${baseSign}, THIS IS ${acSign}, TARGET ACQUIRED, PREPARE TO COPY COORDINATES, OVER.`,
          response: 'Expected: "READY TO COPY" - Wait for this acknowledgment before transmitting coordinates.',
          tips: [
            'Always say PREPARE TO COPY before detailed info',
            'WAIT for "READY TO COPY" acknowledgment',
            'Do NOT send coordinates until base confirms ready',
            'This ensures they have pen and paper ready',
            'Be prepared to orbit and guide ground teams'
          ]
        },
        {
          id: 'coordinates',
          title: ' Passing Coordinates',
          situation: 'Transmitting coordinates AFTER base confirms "READY TO COPY"',
          template: 'COORDINATES FOLLOW: NORTH [DEG] DEGREES [MIN] MINUTES, WEST [DEG] DEGREES [MIN] MINUTES, CAP GRID [GRID], OVER.',
          example: 'COORDINATES FOLLOW: NORTH __ DEGREES __ POINT ___ MINUTES, WEST ___ DEGREES __ POINT ___ MINUTES, CAP GRID [GRID], OVER.',
          response: 'Expected: Base will READ BACK coordinates for confirmation. Respond "CORRECT" or provide corrections.',
          tips: [
            'Only transmit AFTER receiving "READY TO COPY"',
            'Speak slowly and clearly',
            'Use "POINT" for decimal (not "decimal")',
            'Use DDM format: Degrees and decimal minutes',
            'Expect READ BACK - confirm with "CORRECT"',
            'If incorrect, say "NEGATIVE, I SAY AGAIN..." and repeat'
          ]
        },
        {
          id: 'rtb',
          title: ' RTB (Return to Base)',
          situation: 'Departing search area, returning to base',
          template: '[MISSION BASE], THIS IS [AIRCRAFT], RTB, DEPARTING [GRID/POSITION] AT [TIME] ZULU, ESTIMATE [DESTINATION] AT [ETA] ZULU, OVER.',
          example: `${baseSign}, THIS IS ${acSign}, RTB, DEPARTING GRID [GRID] AT ____ ZULU, ESTIMATE [AIRPORT] AT ____ ZULU, OVER.`,
          response: 'Expected: Acknowledgment with any final instructions.',
          tips: [
            'Report before leaving search area',
            'Include estimated arrival time',
            'Note reason if ending early (fuel, weather, etc.)'
          ]
        },
        {
          id: 'wheelsDown',
          title: ' Wheels Down / Landed',
          situation: 'Reporting landing',
          template: '[MISSION BASE], THIS IS [AIRCRAFT], WHEELS DOWN [LOCATION] AT [TIME] ZULU, OVER.',
          example: `${baseSign}, THIS IS ${acSign}, WHEELS DOWN [AIRPORT] AT ____ ZULU, OVER.`,
          response: 'Expected: Acknowledgment, possibly debrief instructions.',
          tips: [
            'Report as soon as safely possible after landing',
            'Include landing location',
            'Prepare for engine stop report'
          ]
        },
        {
          id: 'engineStop',
          title: ' Engine Stop',
          situation: 'Reporting end of flight',
          template: '[MISSION BASE], THIS IS [AIRCRAFT], ENGINE STOP [TIME] ZULU, [TACH/HOBBS IF REQUESTED], OVER.',
          example: `${baseSign}, THIS IS ${acSign}, ENGINE STOP ____ ZULU, TACH _.___, OVER.`,
          response: 'Expected: Acknowledgment, debrief instructions.',
          tips: [
            'Have Tach and Hobbs times ready if required',
            'Note total flight time',
            'Await debrief instructions'
          ]
        }
      ];

      const prowords = [
        { word: 'OVER', meaning: 'End of my transmission, response expected' },
        { word: 'OUT', meaning: 'End of transmission, no response expected' },
        { word: 'ROGER', meaning: 'Message received and understood' },
        { word: 'WILCO', meaning: 'Will comply (includes ROGER)' },
        { word: 'SAY AGAIN', meaning: 'Repeat your last transmission' },
        { word: 'I SAY AGAIN', meaning: 'I am repeating my transmission' },
        { word: 'CORRECTION', meaning: 'Error made, correct version follows' },
        { word: 'WAIT', meaning: 'Pause for a few seconds' },
        { word: 'WAIT OUT', meaning: 'Pause for longer, I will call back' },
        { word: 'BREAK', meaning: 'Separates header from message text' },
        { word: 'NOTHING HEARD', meaning: 'No reply received from called station' },
        { word: 'RADIO CHECK', meaning: 'Request signal strength/readability report' }
      ];

      return React.createElement("div", null,
        // Call Sign Configuration Section
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, " Your Call Signs"),
          React.createElement("div", { style: styles.sectionBody },
            React.createElement("div", { style: { 
              background: "rgba(99,179,237,0.1)", 
              padding: "12px", 
              borderRadius: "8px",
              marginBottom: "12px",
              border: "1px solid rgba(99,179,237,0.2)"
            }},
              React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", marginBottom: "8px" }},
                "Enter your call signs below to customize all examples"
              ),
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px" }},
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#63b3ed", fontWeight: "600" }}, "AIRCRAFT CALL SIGN"),
                  React.createElement("input", {
                    style: { ...styles.input, marginTop: "4px", fontSize: "14px", fontWeight: "600" },
                    value: radioCallSigns.aircraft,
                    onChange: (e) => setRadioCallSigns({ ...radioCallSigns, aircraft: e.target.value.toUpperCase() }),
                    placeholder: "e.g., CAP 594"
                  })
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { fontSize: "10px", color: "#63b3ed", fontWeight: "600" }}, "MISSION BASE"),
                  React.createElement("input", {
                    style: { ...styles.input, marginTop: "4px", fontSize: "14px", fontWeight: "600" },
                    value: radioCallSigns.missionBase,
                    onChange: (e) => setRadioCallSigns({ ...radioCallSigns, missionBase: e.target.value.toUpperCase() }),
                    placeholder: "e.g., BLUE MESA 92"
                  })
                )
              )
            ),
            // Show current call signs if set
            (radioCallSigns.aircraft || radioCallSigns.missionBase) && React.createElement("div", { style: {
              background: "rgba(56,161,105,0.15)",
              padding: "10px 12px",
              borderRadius: "6px",
              border: "1px solid rgba(104,211,145,0.3)",
              fontSize: "11px"
            }},
              React.createElement("span", { style: { color: "#68d391", fontWeight: "600" }}, "\u2714 Examples below will use: "),
              React.createElement("span", { style: { color: "#fff" }}, 
                radioCallSigns.missionBase || "[MISSION BASE]", 
                ", THIS IS ", 
                radioCallSigns.aircraft || "[AIRCRAFT]"
              )
            )
          )
        ),
        // Quick Calls Section
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, " Radio Call Templates"),
          React.createElement("div", { style: styles.sectionBody },
            React.createElement("div", { style: {
              background: "rgba(99,179,237,0.1)",
              padding: "12px",
              borderRadius: "8px",
              marginBottom: "16px",
              border: "1px solid rgba(99,179,237,0.2)"
            }},
              React.createElement("p", { style: { margin: 0, fontSize: "12px", color: "#a0aec0", lineHeight: "1.5" }},
                React.createElement("strong", { style: { color: "#63b3ed" }}, "Format: "),
                "[CALLED STATION] THIS IS [YOUR CALL SIGN] [MESSAGE] OVER"
              )
            ),
            // Radio call cards
            radioCalls.map(call => {
              const isExpanded = expandedRadioCall === call.id;
              return React.createElement("div", { 
                key: call.id,
                style: {
                  background: isExpanded ? "rgba(49,130,206,0.15)" : "rgba(0,0,0,0.2)",
                  borderRadius: "10px",
                  marginBottom: "10px",
                  border: isExpanded ? "2px solid #3182ce" : "1px solid rgba(255,255,255,0.1)",
                  overflow: "hidden"
                }
              },
                // Header
                React.createElement("div", {
                  style: {
                    padding: "14px 16px",
                    cursor: "pointer",
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    background: isExpanded ? "rgba(49,130,206,0.2)" : "transparent"
                  },
                  onClick: () => setExpandedRadioCall(isExpanded ? null : call.id)
                },
                  React.createElement("span", { style: { fontSize: "15px", fontWeight: "700", color: isExpanded ? "#63b3ed" : "#e2e8f0" }}, call.title),
                  React.createElement("span", { style: { color: "#a0aec0", fontSize: "18px" }}, isExpanded ? "" : "")
                ),
                // Expanded content
                isExpanded && React.createElement("div", { style: { padding: "0 16px 16px 16px" }},
                  // Situation
                  React.createElement("div", { style: { marginBottom: "12px" }},
                    React.createElement("div", { style: { fontSize: ts("10"), color: "#a0aec0", textTransform: "uppercase", marginBottom: "4px" }}, "Situation"),
                    React.createElement("div", { style: { fontSize: ts("13"), color: "#e2e8f0" }}, call.situation)
                  ),
                  // Template with Enlarge button
                  React.createElement("div", { style: { 
                    background: "rgba(0,0,0,0.3)", 
                    padding: "12px", 
                    borderRadius: "8px", 
                    marginBottom: "12px",
                    border: "1px solid rgba(99,179,237,0.3)"
                  }},
                    React.createElement("div", { style: { fontSize: ts("10"), color: "#63b3ed", textTransform: "uppercase", marginBottom: "6px", display: "flex", justifyContent: "space-between", alignItems: "center" }}, 
                      React.createElement("span", null, " Template"),
                      React.createElement(EnlargeButton, { title: call.title + " - Template", content: call.template })
                    ),
                    React.createElement("div", { style: { fontSize: ts("13"), color: "#f6e05e", fontFamily: "monospace", lineHeight: "1.5" }}, call.template)
                  ),
                  // Example with Enlarge button
                  React.createElement("div", { style: { 
                    background: "rgba(56,161,105,0.1)", 
                    padding: "12px", 
                    borderRadius: "8px", 
                    marginBottom: "12px",
                    border: "1px solid rgba(104,211,145,0.3)"
                  }},
                    React.createElement("div", { style: { fontSize: ts("10"), color: "#68d391", textTransform: "uppercase", marginBottom: "6px", display: "flex", justifyContent: "space-between", alignItems: "center" }}, 
                      React.createElement("span", null, " Example"),
                      React.createElement(EnlargeButton, { title: call.title + " - Example", content: call.example })
                    ),
                    React.createElement("div", { style: { fontSize: ts("12"), color: "#68d391", fontStyle: "italic", lineHeight: "1.5" }}, call.example)
                  ),
                  // Expected Response
                  React.createElement("div", { style: { marginBottom: "12px" }},
                    React.createElement("div", { style: { fontSize: ts("10"), color: "#a0aec0", textTransform: "uppercase", marginBottom: "4px" }}, "Expected Response"),
                    React.createElement("div", { style: { fontSize: ts("12"), color: "#e2e8f0" }}, call.response)
                  ),
                  // Tips with Enlarge button
                  React.createElement("div", { style: { 
                    background: "rgba(214,158,46,0.1)", 
                    padding: "12px", 
                    borderRadius: "8px",
                    border: "1px solid rgba(246,224,94,0.2)"
                  }},
                    React.createElement("div", { style: { fontSize: ts("10"), color: "#f6e05e", textTransform: "uppercase", marginBottom: "8px", display: "flex", justifyContent: "space-between", alignItems: "center" }}, 
                      React.createElement("span", null, " Tips"),
                      React.createElement(EnlargeButton, { title: call.title + " - Tips", content: call.tips.join("\n ") })
                    ),
                    call.tips.map((tip, i) => 
                      React.createElement("div", { key: i, style: { fontSize: ts("11"), color: "#e2e8f0", marginBottom: "4px", paddingLeft: "12px", position: "relative" }},
                        React.createElement("span", { style: { position: "absolute", left: 0, color: "#f6e05e" }}, ""),
                        tip
                      )
                    )
                  )
                )
              );
            })
          )
        ),
        // Prowords Section
        React.createElement("div", { style: styles.section },
          React.createElement("div", { style: styles.sectionHeader }, " Common Prowords"),
          React.createElement("div", { style: styles.sectionBody },
            React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "8px" }},
              prowords.map(pw => 
                React.createElement("div", { 
                  key: pw.word, 
                  style: { 
                    background: "rgba(0,0,0,0.2)", 
                    padding: "10px 12px", 
                    borderRadius: "8px",
                    border: "1px solid rgba(255,255,255,0.05)"
                  }
                },
                  React.createElement("div", { style: { fontSize: "12px", fontWeight: "700", color: "#63b3ed", marginBottom: "2px" }}, pw.word),
                  React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", lineHeight: "1.3" }}, pw.meaning)
                )
              )
            )
          )
        ),
        // Reference note
        React.createElement("div", { style: { 
          textAlign: "center", 
          padding: "16px", 
          fontSize: "10px", 
          color: "#718096" 
        }}, "Reference: CAPR 100-3 Radiotelephone Operations")
      );
    };

    // Parse KML/KMZ file content (defined early for demo loading)
    const parseKML = (kmlText) => {
      const parser = new DOMParser();
      const doc = parser.parseFromString(kmlText, "text/xml");
      
      // Get callsign from track name
      const trackPlacemark = Array.from(doc.getElementsByTagName('Placemark')).find(p => {
        return p.getElementsByTagName('gx:Track').length > 0;
      });
      
      let callsign = 'Unknown';
      if (trackPlacemark) {
        const nameEl = trackPlacemark.getElementsByTagName('n')[0] || trackPlacemark.getElementsByTagName('name')[0];
        if (nameEl) callsign = nameEl.textContent;
      }
      
      // Get coordinates
      const coords = [];
      const gxCoords = doc.getElementsByTagNameNS('http://www.google.com/kml/ext/2.2', 'coord');
      const whenElements = doc.getElementsByTagName('when');
      
      for (let i = 0; i < gxCoords.length; i++) {
        const parts = gxCoords[i].textContent.trim().split(/\s+/);
        if (parts.length >= 2) {
          coords.push({
            lon: parseFloat(parts[0]),
            lat: parseFloat(parts[1]),
            alt: parts[2] ? parseFloat(parts[2]) : 0,
            time: whenElements[i] ? whenElements[i].textContent : null
          });
        }
      }
      
      return { callsign, coordinates: coords };
    };
    
    // Clear all application data (called before loading demo)
    const clearAllDataForDemo = () => {
      // Clear Event Log
      setEvents([]);
      eventSeqRef.current = 0;
      
      // Clear Mission Info
      setMissionInfo({ missionNumber: "", dateZ: getZuluDate(), sortieNumber: "", aircraftTailN: "", logPageNumber: "1", totalPages: "1", observerName: "" });
      setTimes({ tachStart: "", tachShutdown: "", hobbsStart: "", hobbsShutdown: "", takeoffTime: "", landingTime: "", enteredSearchArea: "", departedSearchArea: "" });
      setFuelOil({ fuelGallons: "", fuelCost: "", oilQt: "" });
      setNotes("");
      
      // Clear Command Tools / Coverage Analysis
      setCmdState(prev => ({
        ...prev,
        searchAreaMode: 'grid',
        gridInput: '',
        selectedGrids: [],
        pointInput: '',
        routePoints: [],
        flights: [],
        coverageGrid: null,
        showMap: false,
        analysisGrids: [],
        flightsOutsideArea: false,
        someFlightsOutside: false,
        pointsInsideArea: 0,
        pointsOutsideArea: 0,
        detectedFlightGrid: null,
        missionRecommendation: null,
        showMissionModal: false
      }));
      
      // Clear Crosshair Target Locate
      setCrosshairPoints([]);
      setCrosshairResult(null);
      setCrosshairAnalysis(null);
      setCrosshairShowMap(false);
      setCrosshairMapHtml('');
      targetSeqRef.current = 0;
      
      // Clear ELT Assist
      setEltObservations([]);
      setEltResult(null);
      setEltShowMap(false);
      setEltShowMapModal(false);
      setEltMapHtml('');
      setEltSolutions([]);
      eltSolutionSeqRef.current = 0;
      eltObsSeqRef.current = 0;
      
      // Clear Search Probability Model
      setAdsbTrack(null);
      setSarsatPings([]);
      setSearchProbModel(null);
      setShowProbModel(false);
      
      // Clear Search Planning
      setSpState(prev => ({
        ...prev,
        poiInput: '',
        poi: null,
        detectedGrid: null,
        lastPlan: null,
        showMap: false
      }));
      
      console.log('All application data cleared for demo');
    };

    // Demo Tab - Load example data for various modules
    const loadDemo = async (demoId) => {
      const demo = demoConfigs.find(d => d.id === demoId);
      if (!demo) return;
      
      // Close confirmation dialog
      setDemoConfirmation(null);
      
      setDemoLoading(true);
      setDemoLoadStatus('Clearing existing data...');
      await new Promise(r => setTimeout(r, 200));
      
      // Clear ALL data before loading demo
      clearAllDataForDemo();
      
      setDemoLoadStatus('Initializing demo...');
      await new Promise(r => setTimeout(r, 100));
      
      try {
        if (demo.module === 'commandTools') {
          // Command tools data already cleared above
          
          // Load grids
          setDemoLoadStatus('Loading search grids...');
          await new Promise(r => setTimeout(r, 100)); // Allow UI to update
          
          for (const gridStr of demo.grids) {
            // Parse grid string like "ICT 142"
            const gridMatch = gridStr.match(/^([A-Z]{3})\s*(\d+)$/i);
            if (gridMatch) {
              const sectionalId = gridMatch[1].toUpperCase();
              const gridNum = parseInt(gridMatch[2]);
              
              // Calculate a center point for this grid to use with spDetectCapGrid
              const sectionals = [
                { id: "ICT", north: 40, south: 36, west: 104, east: 97 },
                { id: "DEN", north: 40, south: 35.75, west: 111, east: 104 }
              ];
              
              const sectional = sectionals.find(s => s.id === sectionalId);
              if (sectional) {
                const gridsPerRow = Math.round((sectional.west - sectional.east) / 0.25);
                const row = Math.floor((gridNum - 1) / gridsPerRow);
                const col = (gridNum - 1) % gridsPerRow;
                const gridNorth = sectional.north - row * 0.25;
                const gridWest = sectional.west - col * 0.25;
                const centerLat = gridNorth - 0.125;
                const centerLon = -(gridWest - 0.125);
                
                const gridInfo = spDetectCapGrid(centerLat, centerLon);
                if (gridInfo) {
                  const baseGrid = gridInfo.gridId.replace(/[ABCD]$/, '').trim();
                  const qc = gridInfo.corners;
                  const quad = gridInfo.quarterGrid;
                  
                  // Calculate full 15-minute grid corners from the quarter grid corners
                  // Quadrant layout: A=NW, B=NE, C=SW, D=SE
                  // We need to expand the quarter grid to the full grid
                  let fullNorth, fullSouth, fullWest, fullEast;
                  
                  if (quad === 'A') {
                    // A is NW: our quarter is top-left, expand south and east
                    fullNorth = qc.nw.lat;
                    fullSouth = qc.sw.lat - 0.125;  // Extend south by one quarter
                    fullWest = qc.nw.lon;
                    fullEast = qc.ne.lon + 0.125;   // Extend east by one quarter
                  } else if (quad === 'B') {
                    // B is NE: our quarter is top-right, expand south and west
                    fullNorth = qc.nw.lat;
                    fullSouth = qc.sw.lat - 0.125;
                    fullWest = qc.nw.lon - 0.125;   // Extend west by one quarter
                    fullEast = qc.ne.lon;
                  } else if (quad === 'C') {
                    // C is SW: our quarter is bottom-left, expand north and east
                    fullNorth = qc.nw.lat + 0.125;  // Extend north by one quarter
                    fullSouth = qc.sw.lat;
                    fullWest = qc.nw.lon;
                    fullEast = qc.ne.lon + 0.125;
                  } else {
                    // D is SE: our quarter is bottom-right, expand north and west
                    fullNorth = qc.nw.lat + 0.125;
                    fullSouth = qc.sw.lat;
                    fullWest = qc.nw.lon - 0.125;
                    fullEast = qc.ne.lon;
                  }
                  
                  const fullGridCorners = {
                    nw: { lat: fullNorth, lon: fullWest },
                    ne: { lat: fullNorth, lon: fullEast },
                    sw: { lat: fullSouth, lon: fullWest },
                    se: { lat: fullSouth, lon: fullEast }
                  };
                  
                  setCmdState(prev => ({
                    ...prev,
                    selectedGrids: [...prev.selectedGrids, {
                      grid: baseGrid,
                      subgrids: ['A', 'B', 'C', 'D'],
                      corners: fullGridCorners,
                      quadrantCorners: qc,
                      detectedQuadrant: quad,
                      gridInfo: gridInfo,
                      coverage: { total: 0, A: 0, B: 0, C: 0, D: 0 }
                    }]
                  }));
                }
              }
            }
          }
          
          // Load KMZ files
          setDemoLoadStatus('Loading flight tracks (0/' + demo.dataFiles.length + ')...');
          await new Promise(r => setTimeout(r, 100));
          
          let loadedCount = 0;
          let failedFiles = [];
          
          // Check if embedded demo data is available
          const embeddedData = window.DEMO_DATA && window.DEMO_DATA[demo.id] ? window.DEMO_DATA[demo.id].files : null;
          console.log('Embedded demo data available:', !!embeddedData);
          
          for (let i = 0; i < demo.dataFiles.length; i++) {
            const filename = demo.dataFiles[i];
            const baseFilename = filename.split('/').pop();
            setDemoLoadStatus('Loading: ' + baseFilename + ' (' + (i + 1) + '/' + demo.dataFiles.length + ')');
            
            try {
              let arrayBuffer;
              
              // Try embedded data first (works with file:// protocol)
              if (embeddedData && embeddedData[baseFilename]) {
                console.log('Using embedded data for:', baseFilename);
                const base64 = embeddedData[baseFilename];
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let j = 0; j < binaryString.length; j++) {
                  bytes[j] = binaryString.charCodeAt(j);
                }
                arrayBuffer = bytes.buffer;
                console.log('Decoded from base64, size:', arrayBuffer.byteLength);
              } else {
                // Fall back to fetch (requires web server)
                console.log('Fetching demo file:', filename);
                const response = await fetch(filename);
                console.log('Fetch response:', response.status, response.statusText);
                
                if (!response.ok) {
                  console.warn('Could not load demo file:', filename, response.status);
                  failedFiles.push(baseFilename);
                  continue;
                }
                
                arrayBuffer = await response.arrayBuffer();
                console.log('Got arrayBuffer from fetch, size:', arrayBuffer.byteLength);
              }
              
              let kmlText;
              
              if (filename.toLowerCase().endsWith('.kmz')) {
                // Extract KML from KMZ
                if (typeof JSZip !== 'undefined') {
                  console.log('Using JSZip to extract KML');
                  const zip = await JSZip.loadAsync(arrayBuffer);
                  const kmlFile = Object.keys(zip.files).find(name => name.toLowerCase().endsWith('.kml'));
                  console.log('Found KML file in zip:', kmlFile);
                  if (kmlFile) {
                    kmlText = await zip.files[kmlFile].async('string');
                    console.log('Extracted KML text, length:', kmlText.length);
                  }
                } else {
                  console.log('JSZip not available, using fallback');
                  // Fallback extraction
                  const bytes = new Uint8Array(arrayBuffer);
                  const decoder = new TextDecoder('utf-8', { fatal: false });
                  const fullText = decoder.decode(bytes);
                  const xmlIdx = fullText.indexOf('<?xml');
                  const kmlIdx = fullText.indexOf('<kml');
                  const startIdx = Math.min(xmlIdx >= 0 ? xmlIdx : Infinity, kmlIdx >= 0 ? kmlIdx : Infinity);
                  if (startIdx < Infinity) {
                    const endIdx = fullText.indexOf('</kml>', startIdx);
                    if (endIdx > startIdx) {
                      kmlText = fullText.substring(startIdx, endIdx + 6);
                    }
                  }
                }
              } else {
                kmlText = new TextDecoder().decode(arrayBuffer);
              }
              
              if (kmlText) {
                const parsed = parseKML(kmlText);
                console.log('Parsed KML, coordinates:', parsed.coordinates.length, 'callsign:', parsed.callsign);
                if (parsed.coordinates.length > 0) {
                  loadedCount++;
                  setCmdState(prev => ({
                    ...prev,
                    flights: [...prev.flights, {
                      id: Date.now() + i,
                      callsign: parsed.callsign,
                      filename: baseFilename,
                      coordinates: parsed.coordinates,
                      color: cmdFlightColors[prev.flights.length % cmdFlightColors.length],
                      pointCount: parsed.coordinates.length
                    }]
                  }));
                } else {
                  console.warn('No coordinates found in:', filename);
                  failedFiles.push(baseFilename + ' (no coords)');
                }
              } else {
                console.warn('Could not extract KML from:', filename);
                failedFiles.push(baseFilename + ' (extract failed)');
              }
            } catch (err) {
              console.error('Error loading demo file:', filename, err);
              failedFiles.push(baseFilename + ' (' + err.message + ')');
            }
            
            await new Promise(r => setTimeout(r, 50)); // Small delay between files
          }
          
          if (failedFiles.length > 0) {
            setDemoLoadStatus('Loaded ' + loadedCount + '/' + demo.dataFiles.length + ' files. Failed: ' + failedFiles.join(', '));
            await new Promise(r => setTimeout(r, 2000));
          } else {
            setDemoLoadStatus('Demo loaded! Switching to Command Tools...');
            await new Promise(r => setTimeout(r, 500));
          }
          
          // Switch to Command Tools tab
          switchTab('commandTools');
        }
        
        // ELT Assist demo
        if (demo.module === 'eltAssist') {
          // Data already cleared by clearAllDataForDemo()
          
          setDemoLoadStatus('Loading ELT data...');
          await new Promise(r => setTimeout(r, 100));
          
          // Check if embedded demo data is available
          const embeddedData = window.DEMO_DATA && window.DEMO_DATA[demo.id] ? window.DEMO_DATA[demo.id].files : null;
          console.log('Embedded ELT demo data available:', !!embeddedData);
          
          let loadedCount = 0;
          let failedFiles = [];
          const importedObservations = [];
          let lastKnownTrack = null;
          
          for (let i = 0; i < demo.dataFiles.length; i++) {
            const filename = demo.dataFiles[i];
            const baseFilename = filename.split('/').pop();
            setDemoLoadStatus('Loading: ' + baseFilename + ' (' + (i + 1) + '/' + demo.dataFiles.length + ')');
            
            try {
              let arrayBuffer;
              
              // Try embedded data first
              if (embeddedData && embeddedData[baseFilename]) {
                console.log('Using embedded data for:', baseFilename);
                const base64 = embeddedData[baseFilename];
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let j = 0; j < binaryString.length; j++) {
                  bytes[j] = binaryString.charCodeAt(j);
                }
                arrayBuffer = bytes.buffer;
              } else {
                // Fall back to fetch
                const response = await fetch(filename);
                if (!response.ok) {
                  failedFiles.push(baseFilename);
                  continue;
                }
                arrayBuffer = await response.arrayBuffer();
              }
              
              let kmlText;
              
              if (baseFilename.toLowerCase().endsWith('.kmz')) {
                if (typeof JSZip !== 'undefined') {
                  const zip = await JSZip.loadAsync(arrayBuffer);
                  const kmlFile = Object.keys(zip.files).find(name => name.toLowerCase().endsWith('.kml'));
                  if (kmlFile) {
                    kmlText = await zip.files[kmlFile].async('string');
                  }
                }
              } else {
                kmlText = new TextDecoder().decode(arrayBuffer);
              }
              
              if (!kmlText) {
                failedFiles.push(baseFilename + ' (extract failed)');
                continue;
              }
              
              const parser = new DOMParser();
              const kml = parser.parseFromString(kmlText, 'text/xml');
              
              // Check if this is a transponder pings file (has D_Sol style)
              const styleUrls = kml.querySelectorAll('styleUrl');
              const hasDetectionPoints = Array.from(styleUrls).some(s => 
                s.textContent.includes('D_Sol') || s.textContent.includes('Sol0')
              );
              
              if (hasDetectionPoints) {
                // Parse SARSAT detection points
                const placemarks = kml.querySelectorAll('Placemark');
                let obsNum = 0;
                
                placemarks.forEach((pm) => {
                  const styleUrl = pm.querySelector('styleUrl');
                  if (!styleUrl) return;
                  
                  const style = styleUrl.textContent;
                  if (!style.includes('D_Sol') && !style.includes('Sol0')) return;
                  if (style.includes('R_RINGS')) return;
                  
                  const point = pm.querySelector('Point coordinates');
                  if (!point) return;
                  
                  const coords = point.textContent.trim().split(',');
                  if (coords.length < 2) return;
                  
                  const lon = parseFloat(coords[0]);
                  const lat = parseFloat(coords[1]);
                  
                  let detectTime = '';
                  let errorNm = '';
                  let msgNum = '';
                  
                  const dataElements = pm.querySelectorAll('ExtendedData Data');
                  dataElements.forEach(d => {
                    const name = d.getAttribute('name');
                    const value = d.querySelector('value');
                    if (!value) return;
                    
                    if (name === 'DETECT TIME') {
                      detectTime = value.textContent.trim().replace('Z', '');
                    } else if (name === 'ERROR') {
                      const match = value.textContent.match(/(\d+)/);
                      if (match) errorNm = match[1];
                    } else if (name === 'USMCC MESSAGE NUMBER') {
                      msgNum = value.textContent.trim();
                    }
                  });
                  
                  const timestamp = pm.querySelector('TimeStamp when');
                  if (timestamp && !detectTime) {
                    const ts = timestamp.textContent;
                    const match = ts.match(/T(\d{2}):(\d{2})/);
                    if (match) {
                      detectTime = match[1] + match[2];
                    }
                  }
                  
                  // Convert to DDM
                  const latDeg = Math.floor(Math.abs(lat));
                  const latMin = (Math.abs(lat) - latDeg) * 60;
                  const lonDeg = Math.floor(Math.abs(lon));
                  const lonMin = (Math.abs(lon) - lonDeg) * 60;
                  
                  obsNum++;
                  importedObservations.push({
                    id: Date.now() + Math.random() + obsNum,
                    obsNum: obsNum,
                    timeZ: detectTime || '',
                    source: 'sarsat',
                    latDeg: latDeg.toString(),
                    latMin: latMin.toFixed(3),
                    lonDeg: lonDeg.toString(),
                    lonMin: lonMin.toFixed(3),
                    altMSL: '',
                    altAGL: '30000',
                    strength: 5,
                    directRange: errorNm || '',
                    rangeAccuracy: errorNm ? (parseFloat(errorNm) * 0.3).toFixed(1) : '',
                    dfBearing: '',
                    bearingRef: 'TRUE',
                    bearingAccuracy: '20',
                    notes: 'SARSAT Demo' + (msgNum ? ' - MSG#' + msgNum : ''),
                    useInCalc: true
                  });
                });
                
                console.log('Imported', importedObservations.length, 'SARSAT detections');
                loadedCount++;
              } else {
                // Check if it's a flight track (gx:Track)
                const track = kml.querySelector('Track') || kml.getElementsByTagName('gx:Track')[0];
                if (track) {
                  const coordElements = track.querySelectorAll('coord') || track.getElementsByTagName('gx:coord');
                  const whenElements = track.querySelectorAll('when') || track.getElementsByTagName('when');
                  
                  lastKnownTrack = {
                    callsign: 'N434MA',
                    coordinates: Array.from(coordElements).map((c, idx) => {
                      const parts = c.textContent.trim().split(/\s+/);
                      return {
                        lon: parseFloat(parts[0]),
                        lat: parseFloat(parts[1]),
                        alt: parts[2] ? parseFloat(parts[2]) : 0,
                        time: whenElements[idx] ? whenElements[idx].textContent : null
                      };
                    })
                  };
                  console.log('Loaded flight track with', lastKnownTrack.coordinates.length, 'points');
                  loadedCount++;
                }
              }
              
            } catch (err) {
              console.error('Error loading ELT demo file:', filename, err);
              failedFiles.push(baseFilename + ' (' + err.message + ')');
            }
            
            await new Promise(r => setTimeout(r, 50));
          }
          
          // Set the observations
          if (importedObservations.length > 0) {
            setEltObservations(importedObservations);
          }
          
          // Store last known track in a way the ELT tab can use (via notes or separate state)
          // For now we'll add the last known position as an observation
          if (lastKnownTrack && lastKnownTrack.coordinates.length > 0) {
            const lastPos = lastKnownTrack.coordinates[lastKnownTrack.coordinates.length - 1];
            const latDeg = Math.floor(Math.abs(lastPos.lat));
            const latMin = (Math.abs(lastPos.lat) - latDeg) * 60;
            const lonDeg = Math.floor(Math.abs(lastPos.lon));
            const lonMin = (Math.abs(lastPos.lon) - lonDeg) * 60;
            
            // Add last known position as first observation
            setEltObservations(prev => [{
              id: Date.now() + 999,
              obsNum: 0,
              timeZ: '2323',
              source: 'adsb',
              latDeg: latDeg.toString(),
              latMin: latMin.toFixed(3),
              lonDeg: lonDeg.toString(),
              lonMin: lonMin.toFixed(3),
              altMSL: Math.round(lastPos.alt * 3.28084).toString(),
              altAGL: '',
              strength: 5,
              directRange: '',
              rangeAccuracy: '',
              dfBearing: '',
              bearingRef: 'TRUE',
              bearingAccuracy: '',
              notes: 'Last ADS-B position - ' + lastKnownTrack.callsign,
              useInCalc: false
            }, ...prev]);
          }
          
          if (failedFiles.length > 0) {
            setDemoLoadStatus('Loaded ' + loadedCount + '/' + demo.dataFiles.length + ' files. Failed: ' + failedFiles.join(', '));
            await new Promise(r => setTimeout(r, 2000));
          } else {
            setDemoLoadStatus('Demo loaded! Switching to ELT Assist...');
            await new Promise(r => setTimeout(r, 500));
          }
          
          // Switch to ELT Assist tab
          switchTab('eltAssist');
        }
        
        // ELT Assist Native Demo (pre-formatted JS data - no parsing needed)
        if (demo.module === 'eltAssistNative') {
          // Data already cleared by clearAllDataForDemo()
          
          setDemoLoadStatus('Loading training data...');
          await new Promise(r => setTimeout(r, 200));
          
          // Get the native demo data
          const demoData = window.DEMO_DATA && window.DEMO_DATA[demo.id];
          if (!demoData || !demoData.observations) {
            setDemoLoadStatus('Error: Demo data not found');
            await new Promise(r => setTimeout(r, 2000));
            setDemoLoading(false);
            return;
          }
          
          const observations = demoData.observations;
          const importedObservations = [];
          const importedEvents = [];
          
          // Process each observation
          for (let i = 0; i < observations.length; i++) {
            const obs = observations[i];
            setDemoLoadStatus('Loading observation ' + (i + 1) + '/' + observations.length + '...');
            
            // Convert decimal degrees to DDM
            const latDeg = Math.floor(Math.abs(obs.lat));
            const latMin = (Math.abs(obs.lat) - latDeg) * 60;
            const lonDeg = Math.floor(Math.abs(obs.lon));
            const lonMin = (Math.abs(obs.lon) - lonDeg) * 60;
            
            // Create observation record
            const obsRecord = {
              id: Date.now() + Math.random() + i,
              obsNum: obs.obsNum,
              timeZ: obs.timeZ,
              source: obs.source || 'df',
              latDeg: latDeg.toString(),
              latMin: latMin.toFixed(3),
              lonDeg: lonDeg.toString(),
              lonMin: lonMin.toFixed(3),
              altMSL: obs.altMSL ? obs.altMSL.toString() : '',
              altAGL: obs.altAGL ? obs.altAGL.toString() : '',
              strength: obs.strength,
              directRange: '',
              rangeAccuracy: '',
              dfBearing: obs.dfBearing ? obs.dfBearing.toString() : '',
              bearingRef: 'MAG',
              bearingAccuracy: obs.bearingAcc ? obs.bearingAcc.toString() : '20',
              notes: '',
              useInCalc: true
            };
            importedObservations.push(obsRecord);
            
            // Create corresponding event log entry
            eventSeqRef.current++;
            const eventRecord = {
              id: Date.now() + Math.random() + i + 1000,
              eventNum: eventSeqRef.current,
              eventType: 'ELT Signal',
              timeZ: obs.timeZ,
              latDeg: latDeg.toString(),
              latMin: latMin.toFixed(3),
              longDeg: lonDeg.toString(),
              longMin: lonMin.toFixed(3),
              altMSL: obs.altMSL ? obs.altMSL.toString() : '',
              altAGL: obs.altAGL ? obs.altAGL.toString() : '',
              heading: obs.dfBearing ? obs.dfBearing.toString() : '',
              airspeed: '',
              groundSpeed: '',
              capGrid: '',
              notes: 'ELT OBS #' + obs.obsNum + ' | Strength: ' + obs.strength + '/10 | DF: ' + obs.dfBearing + ' MAG ' + obs.bearingAcc + ' | AGL: ' + obs.altAGL + ' ft'
            };
            importedEvents.push(eventRecord);
            
            await new Promise(r => setTimeout(r, 30));
          }
          
          // Set all observations at once
          setEltObservations(importedObservations);
          setEvents(importedEvents);
          
          setDemoLoadStatus('Loaded ' + observations.length + ' observations! Switching to ELT Assist...');
          await new Promise(r => setTimeout(r, 800));
          
          // Switch to ELT Assist tab
          switchTab('eltAssist');
        }
        
        // Crosshair Target Locate Demo
        if (demo.module === 'crosshair') {
          // Data already cleared by clearAllDataForDemo()
          
          setDemoLoadStatus('Loading flight data...');
          await new Promise(r => setTimeout(r, 200));
          
          // Get the demo data
          const demoData = window.DEMO_DATA && window.DEMO_DATA[demo.id];
          if (!demoData || !demoData.flights) {
            setDemoLoadStatus('Error: Demo data not found. Make sure demo-data.js is loaded.');
            await new Promise(r => setTimeout(r, 2000));
            setDemoLoading(false);
            return;
          }
          
          // Get selected flight (from state or default)
          const flightKey = crosshairDemoFlight || demo.defaultFlight;
          const flightData = demoData.flights[flightKey];
          
          if (!flightData || !flightData.segments || flightData.segments.length < 2) {
            setDemoLoadStatus('Error: Invalid flight data for ' + flightKey);
            await new Promise(r => setTimeout(r, 2000));
            setDemoLoading(false);
            return;
          }
          
          setDemoLoadStatus('Processing ' + flightData.name + '...');
          await new Promise(r => setTimeout(r, 300));
          
          // Convert the flight segments to crosshair points
          const points = [];
          let pointNum = 0;
          
          // Process each segment
          for (let segIdx = 0; segIdx < flightData.segments.length; segIdx++) {
            const segment = flightData.segments[segIdx];
            setDemoLoadStatus('Loading ' + segment.name + ' (' + segment.points.length + ' points)...');
            
            for (const pt of segment.points) {
              pointNum++;
              
              // Convert to DDM format
              const latDeg = Math.floor(Math.abs(pt.lat));
              const latMin = ((Math.abs(pt.lat) - latDeg) * 60).toFixed(3);
              const lonDeg = Math.floor(Math.abs(pt.lon));
              const lonMin = ((Math.abs(pt.lon) - lonDeg) * 60).toFixed(3);
              
              // Extract time from ISO timestamp
              let timeZ = '';
              if (pt.time) {
                const match = pt.time.match(/T(\d{2}):(\d{2}):(\d{2})/);
                if (match) {
                  timeZ = match[1] + match[2] + match[3];
                }
              }
              
              points.push({
                id: Date.now() + Math.random() + pointNum,
                pointNum: pointNum,
                timeZ: timeZ,
                latDeg: latDeg.toString(),
                latMin: latMin,
                lonDeg: lonDeg.toString(),
                lonMin: lonMin,
                dd: {
                  lat: pt.lat,
                  lon: pt.lon
                }
              });
            }
            
            await new Promise(r => setTimeout(r, 100));
          }
          
          // Set all points
          setCrosshairPoints(points);
          
          setDemoLoadStatus('Loaded ' + points.length + ' points from ' + flightData.segments.length + ' passes! Switching to Crosshair...');
          await new Promise(r => setTimeout(r, 800));
          
          // Switch to Crosshair tab
          switchTab('crosshair');
        }
        
      } catch (err) {
        console.error('Error loading demo:', err);
        setDemoLoadStatus('Error loading demo: ' + err.message);
      }
      
      setDemoLoading(false);
      setDemoLoadStatus('');
    };

    // Demo tab rendered by external module
const renderDemoTab = () => {
      if (!window.DEMO_MODULE) {
        return React.createElement("div", { style: { padding: "20px", textAlign: "center", color: "#a0aec0" } },
          "Demo module not loaded. Make sure data/demo-module.js exists."
        );
      }
      
      return window.DEMO_MODULE.renderTab(
        React,
        // State object
        { demoLoading, demoLoadStatus, demoConfirmation, crosshairDemoFlight },
        // Setters object
        { setDemoLoading, setDemoLoadStatus, setDemoConfirmation, setCrosshairDemoFlight },
        // App actions object
        {
          clearAllDataForDemo,
          switchTab,
          setCmdState,
          setCrosshairPoints,
          setEltObservations,
          setEvents,
          eventSeqRef,
          cmdFlightColors,
          spDetectCapGrid,
          parseKML
        },
        ts
      );
    };
    // Command Tools Tab - Coverage Analysis for IC/Planners
    const renderCommandToolsTab = () => {
      const cmdStyles = {
        section: { marginBottom: "16px" },
        sectionHeader: { background: "linear-gradient(135deg, rgba(99,179,237,0.3), rgba(66,153,225,0.2))", borderRadius: "12px 12px 0 0", padding: "14px 16px", fontWeight: "700", fontSize: "15px", color: "#63b3ed", display: "flex", alignItems: "center", gap: "10px", borderBottom: "2px solid rgba(99,179,237,0.4)" },
        sectionBody: { background: "rgba(0,0,0,0.3)", borderRadius: "0 0 12px 12px", padding: "16px", border: "1px solid rgba(255,255,255,0.1)", borderTop: "none" },
        modeTab: { flex: 1, padding: "12px", borderRadius: "8px", border: "2px solid", cursor: "pointer", fontWeight: "600", fontSize: "13px", fontFamily: "inherit", textAlign: "center" },
        input: { width: "100%", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(255,255,255,0.2)", borderRadius: "8px", padding: "14px", fontSize: "16px", color: "#fff", fontFamily: "inherit", marginBottom: "12px" },
        btn: { padding: "12px 20px", borderRadius: "8px", border: "none", cursor: "pointer", fontWeight: "700", fontSize: "14px", fontFamily: "inherit" },
        gridCard: { background: "rgba(0,0,0,0.2)", borderRadius: "8px", padding: "12px", marginBottom: "8px", border: "1px solid rgba(255,255,255,0.1)" },
        flightCard: { background: "rgba(0,0,0,0.2)", borderRadius: "8px", padding: "12px", marginBottom: "8px", border: "2px solid", display: "flex", justifyContent: "space-between", alignItems: "center" },
        statBox: { background: "rgba(0,0,0,0.3)", borderRadius: "8px", padding: "16px", textAlign: "center", border: "1px solid rgba(255,255,255,0.1)" },
        statValue: { fontSize: "32px", fontWeight: "700", marginBottom: "4px" },
        statLabel: { fontSize: "11px", color: "#a0aec0", textTransform: "uppercase" },
        coverageBar: { height: "24px", borderRadius: "4px", background: "rgba(0,0,0,0.4)", overflow: "hidden", marginTop: "8px" },
        coverageFill: { height: "100%", borderRadius: "4px", transition: "width 0.3s" }
      };

      // Handle KML file upload
      const handleKMLUpload = async (e) => {
        const files = e.target.files;
        if (!files || files.length === 0) return;
        
        for (let idx = 0; idx < files.length; idx++) {
          const file = files[idx];
          const isKMZ = file.name.toLowerCase().endsWith('.kmz');
          
          try {
            let kmlText;
            
            if (isKMZ) {
              // KMZ is a ZIP file containing a KML file (usually doc.kml)
              const arrayBuffer = await file.arrayBuffer();
              const blob = new Blob([arrayBuffer]);
              
              // Use JSZip if available, otherwise try native decompression
              if (typeof JSZip !== 'undefined') {
                const zip = await JSZip.loadAsync(arrayBuffer);
                // Look for .kml file in the archive
                const kmlFile = Object.keys(zip.files).find(name => name.toLowerCase().endsWith('.kml'));
                if (kmlFile) {
                  kmlText = await zip.files[kmlFile].async('string');
                } else {
                  console.error('No KML file found in KMZ archive');
                  continue;
                }
              } else {
                // Fallback: Use DecompressionStream API (modern browsers)
                try {
                  const ds = new DecompressionStream('deflate-raw');
                  // KMZ/ZIP parsing is complex without library, try basic approach
                  // ZIP files have local file headers, we'll look for the KML content
                  const bytes = new Uint8Array(arrayBuffer);
                  
                  // Simple ZIP parser - find PK signature and extract
                  let kmlStart = -1, kmlEnd = -1;
                  const xmlHeader = '<?xml';
                  const kmlHeader = '<kml';
                  
                  // Convert to string and look for KML content
                  const decoder = new TextDecoder('utf-8', { fatal: false });
                  const fullText = decoder.decode(bytes);
                  
                  // Find XML/KML content within the ZIP (it's often stored uncompressed or we can find markers)
                  const xmlIdx = fullText.indexOf('<?xml');
                  const kmlIdx = fullText.indexOf('<kml');
                  const startIdx = Math.min(
                    xmlIdx >= 0 ? xmlIdx : Infinity,
                    kmlIdx >= 0 ? kmlIdx : Infinity
                  );
                  
                  if (startIdx < Infinity) {
                    // Find the end of the KML (</kml>)
                    const endIdx = fullText.indexOf('</kml>', startIdx);
                    if (endIdx > startIdx) {
                      kmlText = fullText.substring(startIdx, endIdx + 6);
                    }
                  }
                  
                  if (!kmlText) {
                    // Try using fflate or pako if loaded
                    if (typeof pako !== 'undefined') {
                      try {
                        const inflated = pako.inflate(bytes.slice(30), { to: 'string' }); // Skip ZIP header
                        if (inflated.includes('<kml')) {
                          kmlText = inflated;
                        }
                      } catch (e) { }
                    }
                  }
                  
                  if (!kmlText) {
                    alert('Could not extract KML from KMZ file: ' + file.name + '\nTry extracting the .kml file manually from the .kmz archive.');
                    continue;
                  }
                } catch (err) {
                  alert('Error reading KMZ file: ' + file.name + '\n' + err.message);
                  continue;
                }
              }
            } else {
              // Regular KML file
              kmlText = await file.text();
            }
            
            const parsed = parseKML(kmlText);
            
            if (parsed.coordinates.length > 0) {
              const newFlight = {
                id: Date.now() + idx,
                callsign: parsed.callsign,
                filename: file.name,
                coordinates: parsed.coordinates,
                color: cmdFlightColors[cmdState.flights.length % cmdFlightColors.length],
                pointCount: parsed.coordinates.length
              };
              
              setCmdState(prev => {
                const newState = {
                  ...prev,
                  flights: [...prev.flights, newFlight]
                };
                
                // After state update, check if we should suggest grids
                // We'll do this via a setTimeout to ensure state is updated
                setTimeout(() => {
                  suggestGridsFromTracks();
                }, 100);
                
                return newState;
              });
            } else {
              console.warn('No coordinates found in file:', file.name);
            }
          } catch (err) {
            console.error('Error processing file:', file.name, err);
            alert('Error processing file: ' + file.name);
          }
        }
        
        // Trigger grid suggestion after all files processed
        setTimeout(() => {
          suggestGridsFromTracks();
        }, 200);
        
        e.target.value = '';
      };

      // Remove a flight
      const removeFlight = (id) => {
        setCmdState(prev => ({
          ...prev,
          flights: prev.flights.filter(f => f.id !== id)
        }));
      };

      // Detect search area clusters from flight tracks and suggest grids
      const detectSearchAreaClusters = (allCoordinates) => {
        if (!allCoordinates || allCoordinates.length < 10) return null;
        
        // Create a density grid to find clusters
        // Use 0.01 degree cells (~0.6 NM) for density calculation
        const cellSize = 0.01;
        const densityGrid = {};
        
        allCoordinates.forEach(coord => {
          const cellKey = Math.floor(coord.lat / cellSize) + ',' + Math.floor(coord.lon / cellSize);
          densityGrid[cellKey] = (densityGrid[cellKey] || 0) + 1;
        });
        
        // Find high-density cells (clusters indicate search patterns)
        const cells = Object.entries(densityGrid).map(([key, count]) => {
          const [latCell, lonCell] = key.split(',').map(Number);
          return {
            lat: latCell * cellSize + cellSize / 2,
            lon: lonCell * cellSize + cellSize / 2,
            count
          };
        });
        
        // Calculate threshold for "high density" - top 20% of density
        const sortedCounts = cells.map(c => c.count).sort((a, b) => b - a);
        const threshold = sortedCounts[Math.floor(sortedCounts.length * 0.2)] || 3;
        
        // Filter to high-density cells
        const clusterCells = cells.filter(c => c.count >= threshold);
        
        if (clusterCells.length === 0) return null;
        
        // Find the centroid of the cluster
        const clusterLat = clusterCells.reduce((sum, c) => sum + c.lat * c.count, 0) / 
                          clusterCells.reduce((sum, c) => sum + c.count, 0);
        const clusterLon = clusterCells.reduce((sum, c) => sum + c.lon * c.count, 0) / 
                          clusterCells.reduce((sum, c) => sum + c.count, 0);
        
        // Calculate cluster bounds
        const clusterBounds = {
          minLat: Math.min(...clusterCells.map(c => c.lat)) - cellSize,
          maxLat: Math.max(...clusterCells.map(c => c.lat)) + cellSize,
          minLon: Math.min(...clusterCells.map(c => c.lon)) - cellSize,
          maxLon: Math.max(...clusterCells.map(c => c.lon)) + cellSize
        };
        
        // Detect CAP grid(s) that cover this cluster
        const gridInfo = spDetectCapGrid(clusterLat, clusterLon);
        if (!gridInfo) return null;
        
        // Determine which quadrants have cluster activity
        const activeQuadrants = new Set();
        const activeEighths = new Set();
        
        clusterCells.forEach(cell => {
          const cellGrid = spDetectCapGrid(cell.lat, cell.lon);
          if (cellGrid) {
            activeQuadrants.add(cellGrid.quarterGrid);
            
            // Also detect 1/8 grid
            const corners = cellGrid.corners;
            const qMidLat = (corners.nw.lat + corners.sw.lat) / 2;
            const qMidLon = (corners.nw.lon + corners.ne.lon) / 2;
            const isSubNorth = cell.lat > qMidLat;
            const isSubEast = cell.lon > qMidLon;
            const subQuad = isSubNorth ? (isSubEast ? 'B' : 'A') : (isSubEast ? 'D' : 'C');
            activeEighths.add(cellGrid.quarterGrid + subQuad);
          }
        });
        
        // Extract base grid ID
        const baseGrid = gridInfo.gridId.replace(/[ABCD]$/, '').trim();
        
        return {
          centroid: { lat: clusterLat, lon: clusterLon },
          bounds: clusterBounds,
          gridId: baseGrid,
          gridInfo: gridInfo,
          activeQuadrants: Array.from(activeQuadrants).sort(),
          activeEighths: Array.from(activeEighths).sort(),
          pointsInCluster: clusterCells.reduce((sum, c) => sum + c.count, 0),
          totalPoints: allCoordinates.length,
          clusterPercentage: Math.round((clusterCells.reduce((sum, c) => sum + c.count, 0) / allCoordinates.length) * 100)
        };
      };

      // Suggest grids based on uploaded flight tracks
      const suggestGridsFromTracks = () => {
        // Use functional update to access current state
        setCmdState(prev => {
          if (prev.flights.length === 0) return prev;
          if (prev.selectedGrids.length > 0) return prev; // Don't suggest if grids already selected
          
          // Combine all flight coordinates
          const allCoords = prev.flights.flatMap(f => f.coordinates);
          
          const cluster = detectSearchAreaClusters(allCoords);
          if (!cluster) return prev;
          
          // Store suggestion in state for display
          return {
            ...prev,
            suggestedGrid: cluster
          };
        });
      };

      // Apply suggested grid
      const applySuggestedGrid = () => {
        const cluster = cmdState.suggestedGrid;
        if (!cluster || !cluster.gridInfo) return;
        
        // Calculate full grid corners from quarter grid
        const qc = cluster.gridInfo.corners;
        const quad = cluster.gridInfo.quarterGrid;
        
        let fullNorth, fullSouth, fullWest, fullEast;
        if (quad === 'A') {
          fullNorth = qc.nw.lat; fullSouth = qc.sw.lat - 0.125; fullWest = qc.nw.lon; fullEast = qc.ne.lon + 0.125;
        } else if (quad === 'B') {
          fullNorth = qc.nw.lat; fullSouth = qc.sw.lat - 0.125; fullWest = qc.nw.lon - 0.125; fullEast = qc.ne.lon;
        } else if (quad === 'C') {
          fullNorth = qc.nw.lat + 0.125; fullSouth = qc.sw.lat; fullWest = qc.nw.lon; fullEast = qc.ne.lon + 0.125;
        } else {
          fullNorth = qc.nw.lat + 0.125; fullSouth = qc.sw.lat; fullWest = qc.nw.lon - 0.125; fullEast = qc.ne.lon;
        }
        
        const fullGridCorners = {
          nw: { lat: fullNorth, lon: fullWest },
          ne: { lat: fullNorth, lon: fullEast },
          sw: { lat: fullSouth, lon: fullWest },
          se: { lat: fullSouth, lon: fullEast }
        };
        
        // Determine if we should suggest 1/8 grids
        const showEighthGrids = cluster.activeEighths.length <= 4;
        
        setCmdState(prev => ({
          ...prev,
          selectedGrids: [...prev.selectedGrids, {
            grid: cluster.gridId,
            subgrids: cluster.activeQuadrants.length > 0 ? cluster.activeQuadrants : ['A', 'B', 'C', 'D'],
            corners: fullGridCorners,
            quadrantCorners: qc,
            detectedQuadrant: quad,
            gridInfo: cluster.gridInfo,
            showEighthGrids: showEighthGrids,
            eighthGrids: showEighthGrids ? cluster.activeEighths : [],
            coverage: { total: 0, A: 0, B: 0, C: 0, D: 0 }
          }],
          suggestedGrid: null // Clear suggestion after applying
        }));
      };

      // Smart parser for search area input - handles CAP grids, coordinates, or multiple entries
      const parseSearchAreaInput = () => {
        const input = cmdState.gridInput.trim();
        if (!input) return;
        
        const results = { grids: [], errors: [] };
        
        // Split by common delimiters: newline, semicolon, or " / "
        // But be careful not to split coordinates like "39 6'24"N, 10434'24"W"
        const entries = input.split(/[\n;]|(?:\s+\/\s+)/).map(s => s.trim()).filter(s => s);
        
        entries.forEach(entry => {
          // Try to parse as CAP Grid ID first 
          // Supports: "DEN 110", "DEN110", "DEN 110B" (quarter), "DEN110CD" (eighth)
          const gridMatch = entry.match(/^([A-Z]{3})\s*(\d+)\s*([ABCD])?\s*([ABCD])?$/i);
          if (gridMatch) {
            const sectionalId = gridMatch[1].toUpperCase();
            const gridNum = parseInt(gridMatch[2]);
            const quadrant = gridMatch[3] ? gridMatch[3].toUpperCase() : null;
            const subQuadrant = gridMatch[4] ? gridMatch[4].toUpperCase() : null; // For 1/8 grids
            
            // We need to find a point in this grid to get corners
            // Use the sectional data to calculate grid center
            const sectionals = [
              { id: "SEA", north: 49, south: 44.5, west: 125, east: 117 },
              { id: "GTF", north: 49, south: 44.5, west: 117, east: 109 },
              { id: "BIL", north: 49, south: 44.5, west: 109, east: 101 },
              { id: "MSP", north: 49, south: 44.5, west: 101, east: 93 },
              { id: "GRB", north: 48.25, south: 44, west: 93, east: 85 },
              { id: "LHN", north: 48, south: 44, west: 85, east: 77 },
              { id: "MON", north: 48, south: 44, west: 77, east: 69 },
              { id: "HFX", north: 48, south: 44, west: 69, east: 61 },
              { id: "LMT", north: 44.5, south: 40, west: 125, east: 117 },
              { id: "SLC", north: 44.5, south: 40, west: 117, east: 109 },
              { id: "CYS", north: 44.5, south: 40, west: 109, east: 101 },
              { id: "OMA", north: 44.5, south: 40, west: 101, east: 93 },
              { id: "ORD", north: 44, south: 40, west: 93, east: 85 },
              { id: "DET", north: 44, south: 40, west: 85, east: 77 },
              { id: "NYC", north: 44, south: 40, west: 77, east: 69 },
              { id: "SFO", north: 40, south: 36, west: 125, east: 118 },
              { id: "LAS", north: 40, south: 35.75, west: 118, east: 111 },
              { id: "DEN", north: 40, south: 35.75, west: 111, east: 104 },
              { id: "ICT", north: 40, south: 36, west: 104, east: 97 },
              { id: "MKC", north: 40, south: 36, west: 97, east: 90 },
              { id: "STL", north: 40, south: 36, west: 91, east: 84 },
              { id: "LUK", north: 40, south: 36, west: 85, east: 78 },
              { id: "DCA", north: 40, south: 36, west: 79, east: 72 },
              { id: "LAX", north: 36, south: 32, west: 121.5, east: 115 },
              { id: "PHX", north: 35.75, south: 31.25, west: 116, east: 109 },
              { id: "ABQ", north: 36, south: 32, west: 109, east: 102 },
              { id: "DFW", north: 36, south: 32, west: 102, east: 95 },
              { id: "MEM", north: 36, south: 32, west: 95, east: 88 },
              { id: "ATL", north: 36, south: 32, west: 88, east: 81 },
              { id: "CLT", north: 36, south: 32, west: 81, east: 75 },
              { id: "ELP", north: 32, south: 28, west: 109, east: 103 },
              { id: "SAT", north: 32, south: 28, west: 103, east: 97 },
              { id: "HOU", north: 32, south: 28, west: 97, east: 91 },
              { id: "MSY", north: 32, south: 28, west: 91, east: 85 },
              { id: "JAX", north: 32, south: 28, west: 85, east: 79 },
              { id: "BRO", north: 28, south: 24, west: 103, east: 97 },
              { id: "MIA", north: 28, south: 24, west: 83, east: 77 }
            ];
            
            const sectional = sectionals.find(s => s.id === sectionalId);
            if (sectional) {
              // Calculate grid location from grid number
              const gridsPerRow = Math.round((sectional.west - sectional.east) / 0.25);
              const row = Math.floor((gridNum - 1) / gridsPerRow);
              const col = (gridNum - 1) % gridsPerRow;
              
              const gridNorth = sectional.north - row * 0.25;
              const gridWest = sectional.west - col * 0.25;
              
              // Calculate center of grid, quadrant, or sub-quadrant
              // CAP Grid quadrant layout: A=NW, B=NE, C=SW, D=SE
              let centerLat, centerLon;
              let isEighthGrid = false;
              let eighthGridId = null;
              
              if (quadrant && subQuadrant) {
                // 1/8 grid (e.g., DEN 79CD) - quadrant C, sub-quadrant D
                isEighthGrid = true;
                eighthGridId = sectionalId + ' ' + gridNum + quadrant + subQuadrant;
                const qs = 0.125; // quarter grid size
                const es = 0.0625; // eighth grid size (half of quarter in one dimension)
                
                // First get quarter grid bounds
                let qNorth, qSouth, qWest, qEast;
                if (quadrant === 'A') { qNorth = gridNorth; qSouth = gridNorth - qs; qWest = gridWest; qEast = gridWest - qs; }
                else if (quadrant === 'B') { qNorth = gridNorth; qSouth = gridNorth - qs; qWest = gridWest - qs; qEast = gridWest - 2*qs; }
                else if (quadrant === 'C') { qNorth = gridNorth - qs; qSouth = gridNorth - 2*qs; qWest = gridWest; qEast = gridWest - qs; }
                else { qNorth = gridNorth - qs; qSouth = gridNorth - 2*qs; qWest = gridWest - qs; qEast = gridWest - 2*qs; }
                
                // Then get sub-quadrant within that quarter (same A=NW, B=NE, C=SW, D=SE layout)
                // Sub-quadrants divide the quarter in half HORIZONTALLY (east-west)
                if (subQuadrant === 'A') { centerLat = qNorth - es/2; centerLon = -(qWest - es/2); }
                else if (subQuadrant === 'B') { centerLat = qNorth - es/2; centerLon = -(qWest - es - es/2); }
                else if (subQuadrant === 'C') { centerLat = qNorth - es - es/2; centerLon = -(qWest - es/2); }
                else { centerLat = qNorth - es - es/2; centerLon = -(qWest - es - es/2); }
                
              } else if (quadrant) {
                const qs = 0.125;
                if (quadrant === 'A') { centerLat = gridNorth - qs/2; centerLon = -(gridWest - qs/2); }           // NW
                else if (quadrant === 'B') { centerLat = gridNorth - qs/2; centerLon = -(gridWest - qs - qs/2); } // NE
                else if (quadrant === 'C') { centerLat = gridNorth - qs - qs/2; centerLon = -(gridWest - qs/2); } // SW
                else { centerLat = gridNorth - qs - qs/2; centerLon = -(gridWest - qs - qs/2); }                  // SE (D)
              } else {
                centerLat = gridNorth - 0.125;
                centerLon = -(gridWest - 0.125);
              }
              
              // Now use spDetectCapGrid with this center point
              const gridInfo = spDetectCapGrid(centerLat, centerLon);
              if (gridInfo) {
                // Store additional info for eighth grids
                if (isEighthGrid) {
                  gridInfo.isEighthGrid = true;
                  gridInfo.eighthGridId = eighthGridId;
                  gridInfo.parentQuadrant = quadrant;
                  gridInfo.subQuadrant = subQuadrant;
                }
                results.grids.push({ gridInfo, input: entry, isEighthGrid, quadrant, subQuadrant });
              } else {
                results.errors.push(entry + ' (grid calculation error)');
              }
            } else {
              results.errors.push(entry + ' (unknown sectional)');
            }
            return;
          }
          
          // Try to parse as coordinate
          const parsed = spParseCoordinate(entry);
          if (parsed) {
            const gridInfo = spDetectCapGrid(parsed.latDD, parsed.lonDD);
            if (gridInfo) {
              results.grids.push({ gridInfo, input: entry, coord: parsed });
            } else {
              results.errors.push(entry + ' (outside grid coverage)');
            }
            return;
          }
          
          // Could not parse
          results.errors.push(entry + ' (unrecognized format)');
        });
        
        // NEW: Interpolate grids between consecutive coordinate points
        // This finds all grids along a route/path, not just at the endpoints
        const coordResults = results.grids.filter(r => r.coord);
        if (coordResults.length >= 2) {
          // We have multiple coordinates - interpolate between consecutive pairs
          for (let i = 0; i < coordResults.length - 1; i++) {
            const p1 = coordResults[i].coord;
            const p2 = coordResults[i + 1].coord;
            
            // Calculate distance and step size (use ~0.5 NM steps for good coverage)
            const latDiff = p2.latDD - p1.latDD;
            const lonDiff = p2.lonDD - p1.lonDD;
            const distNM = Math.sqrt(Math.pow(latDiff * 60, 2) + Math.pow(lonDiff * 60 * Math.cos(p1.latDD * Math.PI / 180), 2));
            const numSteps = Math.max(Math.ceil(distNM / 0.5), 10); // At least 10 steps, or every 0.5 NM
            
            // Step along the path and detect grids
            for (let step = 1; step < numSteps; step++) {
              const t = step / numSteps;
              const interpLat = p1.latDD + t * latDiff;
              const interpLon = p1.lonDD + t * lonDiff;
              
              const interpGridInfo = spDetectCapGrid(interpLat, interpLon);
              if (interpGridInfo) {
                // Check if this grid is already in results
                const baseGrid = interpGridInfo.gridId.replace(/[ABCD]$/, '').trim();
                const alreadyExists = results.grids.some(r => {
                  const existingBase = r.gridInfo.gridId.replace(/[ABCD]$/, '').trim();
                  return existingBase === baseGrid;
                });
                
                if (!alreadyExists) {
                  results.grids.push({ 
                    gridInfo: interpGridInfo, 
                    input: `(interpolated between ${coordResults[i].input} and ${coordResults[i+1].input})`,
                    interpolated: true
                  });
                }
              }
            }
          }
        }
        
        // Process results - add unique grids
        const addedGrids = [];
        results.grids.forEach(({ gridInfo, input, isEighthGrid, quadrant, subQuadrant }) => {
          // For eighth grids, use the eighth grid ID; for regular grids, use full grid ID
          const gridId = isEighthGrid ? gridInfo.eighthGridId : gridInfo.gridId.replace(/[ABCD]$/, '').trim();
          
          // Skip if already in selected grids or already added in this batch
          if (cmdState.selectedGrids.find(g => g.grid === gridId) || addedGrids.includes(gridId)) {
            return;
          }
          
          // Calculate full grid corners from quarter grid corners
          // Quadrant layout: A=NW, B=NE, C=SW, D=SE
          const qc = gridInfo.corners;
          const quad = gridInfo.quarterGrid;
          
          let gridCorners;
          
          if (isEighthGrid) {
            // For eighth grids, calculate the specific 1/8 grid corners
            const qs = 0.125; // quarter size
            const es = 0.0625; // eighth size
            
            // First get full grid corners
            let fullNorth, fullSouth, fullWest, fullEast;
            if (quad === 'A') {
              fullNorth = qc.nw.lat; fullSouth = qc.sw.lat - qs; fullWest = qc.nw.lon; fullEast = qc.ne.lon + qs;
            } else if (quad === 'B') {
              fullNorth = qc.nw.lat; fullSouth = qc.sw.lat - qs; fullWest = qc.nw.lon - qs; fullEast = qc.ne.lon;
            } else if (quad === 'C') {
              fullNorth = qc.nw.lat + qs; fullSouth = qc.sw.lat; fullWest = qc.nw.lon; fullEast = qc.ne.lon + qs;
            } else {
              fullNorth = qc.nw.lat + qs; fullSouth = qc.sw.lat; fullWest = qc.nw.lon - qs; fullEast = qc.ne.lon;
            }
            
            // Get quarter grid bounds within full grid
            let qNorth, qSouth, qWest, qEast;
            if (quadrant === 'A') { qNorth = fullNorth; qSouth = fullNorth - qs; qWest = fullWest; qEast = fullWest + qs; }
            else if (quadrant === 'B') { qNorth = fullNorth; qSouth = fullNorth - qs; qWest = fullWest + qs; qEast = fullEast; }
            else if (quadrant === 'C') { qNorth = fullNorth - qs; qSouth = fullSouth; qWest = fullWest; qEast = fullWest + qs; }
            else { qNorth = fullNorth - qs; qSouth = fullSouth; qWest = fullWest + qs; qEast = fullEast; }
            
            // Get eighth grid bounds within quarter grid (sub-quadrant)
            let eNorth, eSouth, eWest, eEast;
            if (subQuadrant === 'A') { eNorth = qNorth; eSouth = qNorth - es; eWest = qWest; eEast = qWest + es; }
            else if (subQuadrant === 'B') { eNorth = qNorth; eSouth = qNorth - es; eWest = qWest + es; eEast = qEast; }
            else if (subQuadrant === 'C') { eNorth = qNorth - es; eSouth = qSouth; eWest = qWest; eEast = qWest + es; }
            else { eNorth = qNorth - es; eSouth = qSouth; eWest = qWest + es; eEast = qEast; }
            
            gridCorners = {
              nw: { lat: eNorth, lon: eWest },
              ne: { lat: eNorth, lon: eEast },
              sw: { lat: eSouth, lon: eWest },
              se: { lat: eSouth, lon: eEast }
            };
          } else {
            // Regular full grid - expand from quarter to full
            let fullNorth, fullSouth, fullWest, fullEast;
            if (quad === 'A') {
              fullNorth = qc.nw.lat; fullSouth = qc.sw.lat - 0.125; fullWest = qc.nw.lon; fullEast = qc.ne.lon + 0.125;
            } else if (quad === 'B') {
              fullNorth = qc.nw.lat; fullSouth = qc.sw.lat - 0.125; fullWest = qc.nw.lon - 0.125; fullEast = qc.ne.lon;
            } else if (quad === 'C') {
              fullNorth = qc.nw.lat + 0.125; fullSouth = qc.sw.lat; fullWest = qc.nw.lon; fullEast = qc.ne.lon + 0.125;
            } else {
              fullNorth = qc.nw.lat + 0.125; fullSouth = qc.sw.lat; fullWest = qc.nw.lon - 0.125; fullEast = qc.ne.lon;
            }
            
            gridCorners = {
              nw: { lat: fullNorth, lon: fullWest },
              ne: { lat: fullNorth, lon: fullEast },
              sw: { lat: fullSouth, lon: fullWest },
              se: { lat: fullSouth, lon: fullEast }
            };
          }
          
          addedGrids.push(gridId);
          
          setCmdState(prev => ({
            ...prev,
            selectedGrids: [...prev.selectedGrids, {
              grid: gridId,
              subgrids: isEighthGrid ? null : ['A', 'B', 'C', 'D'],
              corners: gridCorners,
              quadrantCorners: qc,
              detectedQuadrant: quad,
              gridInfo: gridInfo,
              isEighthGrid: isEighthGrid || false,
              parentQuadrant: quadrant,
              subQuadrant: subQuadrant,
              coverage: isEighthGrid ? { total: 0 } : { total: 0, A: 0, B: 0, C: 0, D: 0 }
            }]
          }));
        });
        
        // Clear input and show errors if any
        setCmdState(prev => ({ ...prev, gridInput: '' }));
        
        if (results.errors.length > 0) {
          alert('Could not parse:\\n' + results.errors.join('\\n'));
        } else if (addedGrids.length > 0) {
          // Success feedback could go here
        } else if (results.grids.length > 0) {
          alert('All grids already added.');
        }
      };

      // Calculate coverage for all grids
      const calculateCoverage = (showMapAfter = false) => {
        // Use setCmdState callback to access current state (avoids stale closure issues)
        setCmdState(currentState => {
          if (currentState.selectedGrids.length === 0 || currentState.flights.length === 0) {
            return currentState; // No changes if no data
          }
          
          const analysisTimestamp = new Date().toISOString();
          const analysisTimeZ = getZuluTimeOnly();
          const analysisDateZ = getZuluDate();
          
          const coverageWidth = currentState.coverageWidth;
          const nmToLat = 1 / 60;
          const buffer = coverageWidth * nmToLat * 2;
          
          // Calculate the combined bounding box of all search grids (with buffer)
          let gridMinLat = Infinity, gridMaxLat = -Infinity;
          let gridMinLon = Infinity, gridMaxLon = -Infinity;
          
          currentState.selectedGrids.forEach(gridInfo => {
            const corners = gridInfo.corners;
            gridMinLat = Math.min(gridMinLat, corners.sw.lat, corners.se.lat);
            gridMaxLat = Math.max(gridMaxLat, corners.nw.lat, corners.ne.lat);
            gridMinLon = Math.min(gridMinLon, corners.nw.lon, corners.sw.lon);
            gridMaxLon = Math.max(gridMaxLon, corners.ne.lon, corners.se.lon);
          });
          
          // Count points inside and outside the search area
          let totalFlightPoints = 0;
          let pointsInsideArea = 0;
          let pointsOutsideArea = 0;
          
          currentState.flights.forEach(flight => {
            flight.coordinates.forEach(coord => {
              totalFlightPoints++;
              const insideArea = coord.lat >= gridMinLat - buffer && coord.lat <= gridMaxLat + buffer &&
                                coord.lon >= gridMinLon - buffer && coord.lon <= gridMaxLon + buffer;
              if (insideArea) {
                pointsInsideArea++;
              } else {
                pointsOutsideArea++;
              }
            });
          });
          
          // Determine warning state
          const allPointsOutside = pointsInsideArea === 0 && totalFlightPoints > 0;
          const somePointsOutside = pointsOutsideArea > 0 && pointsInsideArea > 0;
          
          const updatedGrids = currentState.selectedGrids.map(gridInfo => {
            const corners = gridInfo.corners;
            const minLat = Math.min(corners.sw.lat, corners.se.lat);
            const maxLat = Math.max(corners.nw.lat, corners.ne.lat);
            const minLon = Math.min(corners.nw.lon, corners.sw.lon);
            const maxLon = Math.max(corners.ne.lon, corners.se.lon);
            const midLat = (minLat + maxLat) / 2;
            
            const cellSize = 0.1;
            const latStep = cellSize * nmToLat;
            const lonStep = cellSize * nmToLat / Math.cos(midLat * Math.PI / 180);
            const numLatCells = Math.ceil((maxLat - minLat) / latStep);
            const numLonCells = Math.ceil((maxLon - minLon) / lonStep);
            
            const coverageGrid = Array(numLatCells).fill(null).map(() => Array(numLonCells).fill(false));
            
            // Count how many flight points are within or near this specific grid
            let pointsNearGrid = 0;
            
            currentState.flights.forEach(flight => {
              flight.coordinates.forEach(coord => {
                // Check if this point is near this grid (within buffer)
                const nearGrid = coord.lat >= minLat - buffer && coord.lat <= maxLat + buffer &&
                                coord.lon >= minLon - buffer && coord.lon <= maxLon + buffer;
                
                // Only process points that are near the grid
                if (!nearGrid) return;
                
                pointsNearGrid++;
                
                const latIdx = Math.floor((coord.lat - minLat) / latStep);
                const lonIdx = Math.floor((coord.lon - minLon) / lonStep);
                const radiusCells = Math.ceil(coverageWidth / cellSize) + 1;
                
                for (let di = -radiusCells; di <= radiusCells; di++) {
                  for (let dj = -radiusCells; dj <= radiusCells; dj++) {
                    const i = latIdx + di;
                    const j = lonIdx + dj;
                    
                    if (i >= 0 && i < numLatCells && j >= 0 && j < numLonCells) {
                      const cellLat = minLat + (i + 0.5) * latStep;
                      const cellLon = minLon + (j + 0.5) * lonStep;
                      const dLat = (cellLat - coord.lat) / nmToLat;
                      const dLon = (cellLon - coord.lon) * Math.cos(coord.lat * Math.PI / 180) / nmToLat;
                      const dist = Math.sqrt(dLat * dLat + dLon * dLon);
                      
                      if (dist <= coverageWidth) {
                        coverageGrid[i][j] = true;
                      }
                    }
                  }
                }
              });
            });
            
            let totalCovered = 0;
            let totalCells = 0;
            const quadrantCounts = { A: { covered: 0, total: 0 }, B: { covered: 0, total: 0 }, C: { covered: 0, total: 0 }, D: { covered: 0, total: 0 } };
            
            // 1/8 grid counts - 16 sub-quadrants (AA, AB, AC, AD, BA, BB, BC, BD, CA, CB, CC, CD, DA, DB, DC, DD)
            const eighthCounts = {};
            ['A', 'B', 'C', 'D'].forEach(q => {
              ['A', 'B', 'C', 'D'].forEach(sq => {
                eighthCounts[q + sq] = { covered: 0, total: 0 };
              });
            });
            
            // Collect uncovered cells for map visualization
            const uncoveredCells = [];
            
            for (let i = 0; i < numLatCells; i++) {
              for (let j = 0; j < numLonCells; j++) {
                totalCells++;
                if (coverageGrid[i][j]) {
                  totalCovered++;
                } else {
                  // Store uncovered cell coordinates for map
                  uncoveredCells.push({
                    lat: minLat + (i + 0.5) * latStep,
                    lon: minLon + (j + 0.5) * lonStep,
                    latStep: latStep,
                    lonStep: lonStep
                  });
                }
                // Determine quarter grid (A=NW, B=NE, C=SW, D=SE)
                const isNorth = i >= numLatCells / 2;
                const isEast = j >= numLonCells / 2;
                let quad = isNorth ? (isEast ? 'B' : 'A') : (isEast ? 'D' : 'C');
                quadrantCounts[quad].total++;
                if (coverageGrid[i][j]) quadrantCounts[quad].covered++;
                
                // Determine 1/8 grid (sub-quadrant within quarter)
                const isSubNorth = (i % (numLatCells / 2)) >= (numLatCells / 4);
                const isSubEast = (j % (numLonCells / 2)) >= (numLonCells / 4);
                let subQuad = isSubNorth ? (isSubEast ? 'B' : 'A') : (isSubEast ? 'D' : 'C');
                const eighthId = quad + subQuad;
                eighthCounts[eighthId].total++;
                if (coverageGrid[i][j]) eighthCounts[eighthId].covered++;
              }
            }
            
            // Calculate 1/8 grid percentages
            const eighthCoverage = {};
            Object.keys(eighthCounts).forEach(id => {
              eighthCoverage[id] = eighthCounts[id].total > 0 
                ? Math.round((eighthCounts[id].covered / eighthCounts[id].total) * 100) 
                : 0;
            });
            
            return {
              ...gridInfo,
              coverage: {
                total: totalCells > 0 ? Math.round((totalCovered / totalCells) * 100) : 0,
                A: quadrantCounts.A.total > 0 ? Math.round((quadrantCounts.A.covered / quadrantCounts.A.total) * 100) : 0,
                B: quadrantCounts.B.total > 0 ? Math.round((quadrantCounts.B.covered / quadrantCounts.B.total) * 100) : 0,
                C: quadrantCounts.C.total > 0 ? Math.round((quadrantCounts.C.covered / quadrantCounts.C.total) * 100) : 0,
                D: quadrantCounts.D.total > 0 ? Math.round((quadrantCounts.D.covered / quadrantCounts.D.total) * 100) : 0,
                eighth: eighthCoverage
              },
              uncoveredCells: uncoveredCells,
              gridBounds: { minLat, maxLat, minLon, maxLon },
              pointsNearGrid: pointsNearGrid
            };
          });
          
          // Detect the grid where most flight data is (for helpful message when all points outside)
          let detectedFlightGrid = null;
          if (allPointsOutside && totalFlightPoints > 0) {
            // Find center of all flight tracks
            let sumLat = 0, sumLon = 0, count = 0;
            currentState.flights.forEach(flight => {
              flight.coordinates.forEach(coord => {
                sumLat += coord.lat;
                sumLon += coord.lon;
                count++;
              });
            });
            if (count > 0) {
              detectedFlightGrid = spDetectCapGrid(sumLat / count, sumLon / count);
            }
          }
          
          // Log coverage analysis as an event
          const gridNames = updatedGrids.map(g => g.grid).join(', ');
          const avgCoverage = updatedGrids.length > 0 
            ? Math.round(updatedGrids.reduce((sum, g) => sum + (g.coverage?.total || 0), 0) / updatedGrids.length)
            : 0;
          const eventNum = events.length > 0 ? Math.max(...events.map(e => e.eventNum || 0)) + 1 : 1;
          const newEvent = {
            id: Date.now(),
            eventNum,
            type: 'Coverage Analysis',
            dateZ: analysisDateZ,
            timeZ: analysisTimeZ,
            notes: `Coverage analysis: ${gridNames}. ${currentState.flights.length} aircraft, ${totalFlightPoints} track points. Average coverage: ${avgCoverage}%. Coverage width: ${coverageWidth} NM. ${updatedGrids.map(g => g.grid + ': ' + (g.coverage?.total || 0) + '%').join(', ')}.`
          };
          setEvents(prev => [newEvent, ...prev]);
          
          return { 
            ...currentState, 
            selectedGrids: updatedGrids,
            flightsOutsideArea: allPointsOutside,
            someFlightsOutside: somePointsOutside,
            pointsInsideArea: pointsInsideArea,
            pointsOutsideArea: pointsOutsideArea,
            detectedFlightGrid: detectedFlightGrid ? detectedFlightGrid.gridId.replace(/[ABCD]$/, '').trim() : null,
            analysisTimestamp,
            analysisTimeZ,
            analysisDateZ,
            totalFlightPoints,
            ...(showMapAfter ? { showMap: true, mapKey: currentState.mapKey + 1 } : {})
          };
        });
      };

      // Pop out coverage map to new window
      const popOutCoverageMap = () => {
        // Calculate bounds from GRIDS ONLY (not flight paths)
        let gridLats = [], gridLons = [];
        cmdState.selectedGrids.forEach(g => {
          if (g.gridBounds) {
            gridLats.push(g.gridBounds.minLat, g.gridBounds.maxLat);
            gridLons.push(g.gridBounds.minLon, g.gridBounds.maxLon);
          } else if (g.corners) {
            gridLats.push(g.corners.nw.lat, g.corners.sw.lat);
            gridLons.push(g.corners.nw.lon, g.corners.ne.lon);
          }
        });
        
        const centerLat = gridLats.length > 0 ? (Math.min(...gridLats) + Math.max(...gridLats)) / 2 : 39;
        const centerLon = gridLons.length > 0 ? (Math.min(...gridLons) + Math.max(...gridLons)) / 2 : -105;
        const padding = 0.02;
        const bounds = gridLats.length > 0 ? [[Math.min(...gridLats) - padding, Math.min(...gridLons) - padding], [Math.max(...gridLats) + padding, Math.max(...gridLons) + padding]] : null;
        
        // Build grid data for the map
        const gridsJson = JSON.stringify(cmdState.selectedGrids.map(g => ({
          grid: g.grid,
          coverage: g.coverage?.total || 0,
          bounds: g.gridBounds || (g.corners ? { minLat: g.corners.sw.lat, maxLat: g.corners.nw.lat, minLon: g.corners.nw.lon, maxLon: g.corners.ne.lon } : null),
          uncoveredCells: (g.uncoveredCells || []).slice(0, 500), // Limit for performance
          showEighthGrids: g.showEighthGrids || false
        })));
        
        // Build flight tracks data
        const flightsJson = JSON.stringify(cmdState.flights.map(f => ({
          callsign: f.callsign,
          coordinates: f.coordinates
        })));
        
        const avgCoverage = cmdState.selectedGrids.length > 0 
          ? Math.round(cmdState.selectedGrids.reduce((sum, g) => sum + (g.coverage?.total || 0), 0) / cmdState.selectedGrids.length)
          : 0;
        
        const mapHtml = [
          '<!DOCTYPE html>',
          '<html style="height:100%;margin:0"><head>',
          '<title>Coverage Analysis Map - ' + avgCoverage + '% Average</title>',
          '<meta name="viewport" content="width=device-width, initial-scale=1.0">',
          '<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>',
          '<scr' + 'ipt src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></scr' + 'ipt>',
          '<style>',
          'html,body{height:100%;margin:0;padding:0}',
          'body{font-family:-apple-system,BlinkMacSystemFont,sans-serif}',
          '#map{height:100%;width:100%}',
          '.info-panel{position:absolute;top:10px;right:10px;background:rgba(26,32,44,0.95);color:#fff;padding:16px;border-radius:12px;z-index:1000;min-width:200px;border:2px solid #4a5568}',
          '.legend{margin-top:12px;font-size:12px}',
          '.legend-item{display:flex;align-items:center;gap:8px;margin:6px 0}',
          '.legend-color{width:20px;height:12px;border-radius:2px}',
          '</style>',
          '</head><body>',
          '<div id="map"></div>',
          '<div class="info-panel">',
          '<div style="font-size:18px;font-weight:700;color:#f6e05e;margin-bottom:8px">Coverage Analysis</div>',
          '<div style="font-size:24px;font-weight:700;color:' + (avgCoverage >= 80 ? '#68d391' : avgCoverage >= 50 ? '#f6e05e' : '#fc8181') + '">' + avgCoverage + '% Average</div>',
          '<div style="font-size:12px;color:#a0aec0;margin-top:4px">' + cmdState.flights.length + ' aircraft, ' + cmdState.selectedGrids.length + ' grids</div>',
          '<div class="legend">',
          '<div class="legend-item"><div class="legend-color" style="background:#ff00ff"></div> Grid Boundary</div>',
          '<div class="legend-item"><div class="legend-color" style="background:#000;border:1px solid #fff"></div> Flight Tracks</div>',
          '<div class="legend-item"><div class="legend-color" style="background:rgba(229,62,62,0.6)"></div> Missing Coverage</div>',
          '</div>',
          '</div>',
          '<scr' + 'ipt>',
          'var map=L.map("map").setView([' + centerLat + ',' + centerLon + '],11);',
          'L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{attribution:"OpenStreetMap"}).addTo(map);',
          'var grids=' + gridsJson + ';',
          'var flights=' + flightsJson + ';',
          'grids.forEach(function(g){',
          '  if(g.bounds){',
          '    L.rectangle([[g.bounds.minLat,g.bounds.minLon],[g.bounds.maxLat,g.bounds.maxLon]],{color:"#ff00ff",weight:5,fillOpacity:0.05,dashArray:"10,5"}).addTo(map).bindPopup(g.grid+" - "+g.coverage+"% covered");',
          '    var midLat=(g.bounds.maxLat+g.bounds.minLat)/2;',
          '    var midLon=(g.bounds.maxLon+g.bounds.minLon)/2;',
          '    L.polyline([[g.bounds.maxLat,midLon],[g.bounds.minLat,midLon]],{color:"#ff00ff",weight:2,dashArray:"6,4",opacity:0.7}).addTo(map);',
          '    L.polyline([[midLat,g.bounds.minLon],[midLat,g.bounds.maxLon]],{color:"#ff00ff",weight:2,dashArray:"6,4",opacity:0.7}).addTo(map);',
          '    if(g.showEighthGrids){',
          '      var q1Lat=(g.bounds.maxLat+midLat)/2;var q3Lat=(midLat+g.bounds.minLat)/2;',
          '      var q1Lon=(g.bounds.minLon+midLon)/2;var q3Lon=(midLon+g.bounds.maxLon)/2;',
          '      L.polyline([[q1Lat,g.bounds.minLon],[q1Lat,g.bounds.maxLon]],{color:"#ff00ff",weight:1,dashArray:"3,3",opacity:0.5}).addTo(map);',
          '      L.polyline([[q3Lat,g.bounds.minLon],[q3Lat,g.bounds.maxLon]],{color:"#ff00ff",weight:1,dashArray:"3,3",opacity:0.5}).addTo(map);',
          '      L.polyline([[g.bounds.maxLat,q1Lon],[g.bounds.minLat,q1Lon]],{color:"#ff00ff",weight:1,dashArray:"3,3",opacity:0.5}).addTo(map);',
          '      L.polyline([[g.bounds.maxLat,q3Lon],[g.bounds.minLat,q3Lon]],{color:"#ff00ff",weight:1,dashArray:"3,3",opacity:0.5}).addTo(map);',
          '    }',
          '    g.uncoveredCells.forEach(function(c){',
          '      var h=c.latStep/2,w=c.lonStep/2;',
          '      L.rectangle([[c.lat-h,c.lon-w],[c.lat+h,c.lon+w]],{color:"#e53e3e",weight:0,fillColor:"#e53e3e",fillOpacity:0.5}).addTo(map);',
          '    });',
          '  }',
          '});',
          'flights.forEach(function(f){',
          '  var coords=f.coordinates.map(function(c){return[c.lat,c.lon];});',
          '  if(coords.length>0){L.polyline(coords,{color:"#000",weight:3,opacity:1}).addTo(map).bindPopup(f.callsign);}',
          '});',
          bounds ? 'map.fitBounds(' + JSON.stringify(bounds) + ');' : '',
          '</scr' + 'ipt>',
          '</body></html>'
        ].join('\\n');
        
        const mapWindow = window.open('', '_blank');
        if (mapWindow) {
          mapWindow.document.write(mapHtml);
          mapWindow.document.close();
        } else {
          alert('Please allow popups to view the map.');
        }
      };

      // Generate mission recommendation for uncovered areas
      const generateMissionRecommendation = () => {
        // Collect all quarter-grids with their coverage data
        const gapOptions = [];
        
        cmdState.selectedGrids.forEach(g => {
          if (!g.coverage) return;
          
          // Get the base grid bounds
          const gridCorners = g.corners;
          if (!gridCorners) return;
          
          // Process each quarter-grid (A, B, C, D)
          ['A', 'B', 'C', 'D'].forEach(quad => {
            const coverage = g.coverage[quad] || 0;
            if (coverage >= 100) return; // Skip fully covered areas
            
            // Only include if this quadrant is in the selected subgrids
            if (g.subgrids && !g.subgrids.includes(quad)) return;
            
            // Calculate quarter-grid corners
            // A=NW, B=NE, C=SW, D=SE
            const midLat = (gridCorners.nw.lat + gridCorners.sw.lat) / 2;
            const midLon = (gridCorners.nw.lon + gridCorners.ne.lon) / 2;
            
            let qCorners;
            switch(quad) {
              case 'A': // NW
                qCorners = {
                  nw: gridCorners.nw,
                  ne: { lat: gridCorners.nw.lat, lon: midLon },
                  sw: { lat: midLat, lon: gridCorners.nw.lon },
                  se: { lat: midLat, lon: midLon }
                };
                break;
              case 'B': // NE
                qCorners = {
                  nw: { lat: gridCorners.ne.lat, lon: midLon },
                  ne: gridCorners.ne,
                  sw: { lat: midLat, lon: midLon },
                  se: { lat: midLat, lon: gridCorners.ne.lon }
                };
                break;
              case 'C': // SW
                qCorners = {
                  nw: { lat: midLat, lon: gridCorners.sw.lon },
                  ne: { lat: midLat, lon: midLon },
                  sw: gridCorners.sw,
                  se: { lat: gridCorners.sw.lat, lon: midLon }
                };
                break;
              case 'D': // SE
                qCorners = {
                  nw: { lat: midLat, lon: midLon },
                  ne: { lat: midLat, lon: gridCorners.se.lon },
                  sw: { lat: gridCorners.se.lat, lon: midLon },
                  se: gridCorners.se
                };
                break;
            }
            
            // Filter uncovered cells for this quarter-grid
            const quadUncovered = (g.uncoveredCells || []).filter(cell => {
              return cell.lat >= qCorners.sw.lat && cell.lat <= qCorners.nw.lat &&
                     cell.lon >= qCorners.nw.lon && cell.lon <= qCorners.ne.lon;
            });
            
            gapOptions.push({
              gridId: g.grid + quad,
              baseGrid: g.grid,
              quadrant: quad,
              coverage: coverage,
              gapPercent: 100 - coverage,
              uncoveredCells: quadUncovered,
              corners: qCorners,
              isRecommended: false
            });
          });
        });
        
        if (gapOptions.length === 0) {
          alert('No uncovered areas to search - coverage is 100%!');
          return;
        }
        
        // Sort by coverage (lowest first = highest priority)
        gapOptions.sort((a, b) => a.coverage - b.coverage);
        
        // Mark the first one (lowest coverage) as recommended
        gapOptions[0].isRecommended = true;
        
        // Show the gap selector modal
        setCmdState(prev => ({ 
          ...prev, 
          showGapSelector: true, 
          gapOptions: gapOptions,
          selectedGap: null
        }));
      };
      
      // Generate mission for a specific selected gap
      const generateMissionForGap = (gap) => {
        const corners = gap.corners;
        
        // Calculate center point (POI)
        const centerLat = (corners.nw.lat + corners.sw.lat) / 2;
        const centerLon = (corners.nw.lon + corners.ne.lon) / 2;
        
        // Calculate dimensions in NM
        const nmToLat = 1 / 60;
        const latSpanNM = (corners.nw.lat - corners.sw.lat) / nmToLat;
        const lonSpanNM = Math.abs(corners.ne.lon - corners.nw.lon) * Math.cos(centerLat * Math.PI / 180) / nmToLat;
        
        // Quarter grid is ~7.5 x 7.5 NM, so use appropriate values
        const isNorthSouth = latSpanNM > lonSpanNM;
        const legLength = Math.max(isNorthSouth ? latSpanNM : lonSpanNM, 2);
        const searchWidth = isNorthSouth ? lonSpanNM : latSpanNM;
        
        // Calculate track spacing based on visibility conditions
        const trackSpacing = 0.5;
        const numLegs = Math.ceil(searchWidth / trackSpacing) + 1;
        
        // Calculate estimated search time (assuming 90 knots ground speed)
        const groundSpeed = 90;
        const totalTrackNM = legLength * numLegs;
        const searchTimeMinutes = Math.round((totalTrackNM / groundSpeed) * 60);
        
        // Format coordinates
        const formatCoord = (lat, lon) => {
          const latDir = lat >= 0 ? 'N' : 'S';
          const lonDir = lon >= 0 ? 'E' : 'W';
          const latDeg = Math.floor(Math.abs(lat));
          const latMin = ((Math.abs(lat) - latDeg) * 60).toFixed(2);
          const lonDeg = Math.floor(Math.abs(lon));
          const lonMin = ((Math.abs(lon) - lonDeg) * 60).toFixed(2);
          return latDeg + '\u00B0 ' + latMin + "' " + latDir + ', ' + lonDeg + '\u00B0 ' + lonMin + "' " + lonDir;
        };
        
        // Build recommendation object
        const recommendation = {
          searchType: 'Parallel Track',
          poi: { lat: centerLat, lon: centerLon, formatted: formatCoord(centerLat, centerLon) },
          gridId: gap.gridId,
          orientation: isNorthSouth ? 'North-South legs' : 'East-West legs',
          initialTrack: isNorthSouth ? '360\u00B0/180\u00B0' : '090\u00B0/270\u00B0',
          legLength: legLength.toFixed(1),
          trackSpacing: trackSpacing.toFixed(1),
          numLegs: numLegs,
          searchAreaNM: (legLength * searchWidth).toFixed(1),
          estimatedTime: searchTimeMinutes,
          corners: corners,
          turnDirection: 'Alternate (standard parallel)',
          altitude: 'AGL per mission brief',
          notes: [
            'Targeting ' + gap.gridId + ' (' + gap.coverage + '% current coverage)',
            'Track spacing assumes ' + (trackSpacing * 2).toFixed(1) + ' NM total sweep width',
            'Adjust track spacing based on actual visibility and target size',
            'Consider wind direction when selecting initial track'
          ]
        };
        
        setCmdState(prev => ({ 
          ...prev, 
          missionRecommendation: recommendation, 
          showMissionModal: true,
          showGapSelector: false
        }));
      };

      const getCoverageColor = (pct) => {
        if (pct >= 90) return '#38a169';
        if (pct >= 70) return '#68d391';
        if (pct >= 50) return '#d69e2e';
        if (pct >= 30) return '#dd6b20';
        return '#e53e3e';
      };

      const totalFlightPoints = cmdState.flights.reduce((sum, f) => sum + f.coordinates.length, 0);
      const avgCoverage = cmdState.selectedGrids.length > 0 
        ? Math.round(cmdState.selectedGrids.reduce((sum, g) => sum + (g.coverage?.total || 0), 0) / cmdState.selectedGrids.length)
        : 0;

      return React.createElement("div", null,
        React.createElement("div", { style: { ...cmdStyles.section } },
          React.createElement("div", { style: { ...cmdStyles.sectionHeader, borderRadius: "12px", borderBottom: "none" } },
            React.createElement("span", null, "\u{1F4CA}"), "Command Tools - Coverage Analysis"
          )
        ),
        React.createElement("div", { style: cmdStyles.section },
          React.createElement("div", { style: cmdStyles.sectionHeader }, React.createElement("span", null, "\u{1F3AF}"), "Define Search Area"),
          React.createElement("div", { style: cmdStyles.sectionBody },
            // Single smart input
            React.createElement("div", { style: { marginBottom: "12px" } },
              React.createElement("textarea", { 
                placeholder: "Enter CAP grids or coordinates (one per line):\n DEN 110  (full grid)\n DEN 110B  (quarter grid)\n DEN 79CD  (1/8 grid)\n 39.1234, -104.5678\n 39 6'24\"N, 10434'24\"W\n\nMultiple entries: separate by newline or semicolon",
                value: cmdState.gridInput, 
                onChange: (e) => setCmdState(prev => ({ ...prev, gridInput: e.target.value })), 
                style: { 
                  width: "100%", 
                  minHeight: "100px",
                  background: "rgba(0,0,0,0.4)", 
                  border: "2px solid rgba(255,255,255,0.2)", 
                  borderRadius: "8px", 
                  padding: "14px", 
                  fontSize: "14px", 
                  color: "#fff", 
                  fontFamily: "inherit",
                  resize: "vertical"
                } 
              }),
              React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginTop: "8px" } },
                React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0" } }, 
                  "Accepts: CAP Grid IDs (DEN 110, DEN110B)  Decimal (39.12, -104.56)  DMS (39 6'24\"N, 10434'24\"W)"
                ),
                React.createElement("button", { 
                  onClick: parseSearchAreaInput, 
                  disabled: !cmdState.gridInput.trim(),
                  style: { 
                    ...cmdStyles.btn, 
                    background: cmdState.gridInput.trim() ? "linear-gradient(135deg, #38a169, #2f855a)" : "rgba(100,100,100,0.3)", 
                    color: cmdState.gridInput.trim() ? "#fff" : "#a0aec0",
                    cursor: cmdState.gridInput.trim() ? "pointer" : "not-allowed"
                  } 
                }, "+ Add Grids")
              )
            ),
            // Active grids display with expandable 1/8 grids
            cmdState.selectedGrids.length > 0 && React.createElement("div", { style: { marginTop: "16px" } },
              React.createElement("div", { style: { fontSize: "12px", fontWeight: "700", color: "#fc8181", marginBottom: "8px" } }, "Active Search Grids (" + cmdState.selectedGrids.length + "):"),
              cmdState.selectedGrids.map((g, i) => React.createElement("div", { key: i, style: cmdStyles.gridCard },
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "8px" } },
                  React.createElement("span", { style: { fontSize: "16px", fontWeight: "700", color: "#f6e05e" } }, g.grid),
                  React.createElement("button", { onClick: () => setCmdState(prev => ({ ...prev, selectedGrids: prev.selectedGrids.filter((_, idx) => idx !== i) })), style: { background: "rgba(229,62,62,0.3)", border: "none", color: "#fc8181", padding: "6px 10px", borderRadius: "4px", cursor: "pointer", fontSize: "12px" } }, "Remove")
                ),
                // Quarter grid buttons
                React.createElement("div", { style: { display: "flex", gap: "6px", marginBottom: "8px" } },
                  ['A', 'B', 'C', 'D'].map(sub => React.createElement("button", { 
                    key: sub, 
                    style: { 
                      flex: 1, 
                      padding: "8px", 
                      borderRadius: "6px", 
                      border: g.subgrids?.includes(sub) ? "2px solid #68d391" : "1px solid rgba(255,255,255,0.2)", 
                      background: g.subgrids?.includes(sub) ? "rgba(104,211,145,0.2)" : "rgba(0,0,0,0.2)", 
                      color: g.subgrids?.includes(sub) ? "#68d391" : "#a0aec0", 
                      cursor: "pointer", 
                      fontWeight: "600", 
                      fontSize: "13px" 
                    }, 
                    onClick: () => { 
                      setCmdState(prev => ({ 
                        ...prev, 
                        selectedGrids: prev.selectedGrids.map((grid, idx) => { 
                          if (idx !== i) return grid; 
                          const newSubs = grid.subgrids?.includes(sub) ? grid.subgrids.filter(s => s !== sub) : [...(grid.subgrids || []), sub]; 
                          return { ...grid, subgrids: newSubs }; 
                        }) 
                      })); 
                    } 
                  }, g.grid + sub))
                ),
                // 1/8 grid toggle and buttons
                React.createElement("div", { style: { borderTop: "1px solid rgba(255,255,255,0.1)", paddingTop: "8px" } },
                  React.createElement("label", { style: { display: "flex", alignItems: "center", gap: "8px", cursor: "pointer", marginBottom: g.showEighthGrids ? "8px" : "0" } },
                    React.createElement("input", { 
                      type: "checkbox", 
                      checked: g.showEighthGrids || false, 
                      onChange: (e) => setCmdState(prev => ({ 
                        ...prev, 
                        selectedGrids: prev.selectedGrids.map((grid, idx) => idx !== i ? grid : { ...grid, showEighthGrids: e.target.checked, eighthGrids: e.target.checked ? (grid.eighthGrids || []) : [] })
                      })),
                      style: { width: "14px", height: "14px", accentColor: "#b794f4" }
                    }),
                    React.createElement("span", { style: { fontSize: "11px", color: "#b794f4", fontWeight: "600" } }, "Enable 1/8 Grid Selection")
                  ),
                  // 1/8 grid buttons - show when enabled, arranged geographically
                  // Layout: A=NW, B=NE, C=SW, D=SE for both quarter and eighth grids
                  // Row 1: AA AB | BA BB (top row - north halves of A and B quadrants)
                  // Row 2: AC AD | BC BD (second row - south halves of A and B quadrants)
                  // Row 3: CA CB | DA DB (third row - north halves of C and D quadrants)
                  // Row 4: CC CD | DC DD (bottom row - south halves of C and D quadrants)
                  g.showEighthGrids && React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: "4px" } },
                    // Geographic order: top-left to bottom-right
                    ['AA', 'AB', 'BA', 'BB', 'AC', 'AD', 'BC', 'BD', 'CA', 'CB', 'DA', 'DB', 'CC', 'CD', 'DC', 'DD'].map(eighthId => {
                        const quad = eighthId[0]; // Parent quadrant (A, B, C, D)
                        const isActive = g.eighthGrids?.includes(eighthId);
                        const parentActive = g.subgrids?.includes(quad);
                        return React.createElement("button", { 
                          key: eighthId, 
                          disabled: !parentActive,
                          style: { 
                            padding: "4px 2px", 
                            borderRadius: "4px", 
                            border: isActive ? "2px solid #b794f4" : "1px solid rgba(255,255,255,0.15)", 
                            background: isActive ? "rgba(183,148,244,0.25)" : parentActive ? "rgba(0,0,0,0.2)" : "rgba(0,0,0,0.4)", 
                            color: isActive ? "#b794f4" : parentActive ? "#a0aec0" : "#4a5568", 
                            cursor: parentActive ? "pointer" : "not-allowed", 
                            fontWeight: "500", 
                            fontSize: "10px",
                            opacity: parentActive ? 1 : 0.4
                          }, 
                          onClick: () => { 
                            if (!parentActive) return;
                            setCmdState(prev => ({ 
                              ...prev, 
                              selectedGrids: prev.selectedGrids.map((grid, idx) => { 
                                if (idx !== i) return grid; 
                                const newEighths = grid.eighthGrids?.includes(eighthId) 
                                  ? grid.eighthGrids.filter(e => e !== eighthId) 
                                  : [...(grid.eighthGrids || []), eighthId]; 
                                return { ...grid, eighthGrids: newEighths }; 
                              }) 
                            })); 
                          } 
                        }, g.grid + eighthId);
                      })
                  )
                )
              ))
            )
          )
        ),
        React.createElement("div", { style: cmdStyles.section },
          React.createElement("div", { style: cmdStyles.sectionHeader }, React.createElement("span", null, "\u2708\uFE0F"), "Flight Tracks"),
          React.createElement("div", { style: cmdStyles.sectionBody },
            React.createElement("label", { style: { display: "block", padding: "20px", background: "linear-gradient(135deg, rgba(99,179,237,0.2), rgba(49,130,206,0.1))", border: "2px dashed rgba(99,179,237,0.5)", borderRadius: "12px", textAlign: "center", cursor: "pointer", marginBottom: "16px" } },
              React.createElement("input", { type: "file", accept: ".kml,.kmz", multiple: true, onChange: handleKMLUpload, style: { display: "none" } }),
              React.createElement("div", { style: { fontSize: "24px", marginBottom: "8px" } }, "\u{1F4C1}"),
              React.createElement("div", { style: { fontSize: "14px", fontWeight: "600", color: "#63b3ed" } }, "Upload KML/KMZ Flight Track(s)"),
              React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginTop: "4px" } }, "Click to select or drag & drop multiple files")
            ),
            cmdState.flights.length > 0 && React.createElement("div", null,
              React.createElement("div", { style: { fontSize: "12px", fontWeight: "700", color: "#63b3ed", marginBottom: "8px" } }, "Loaded Flights (" + cmdState.flights.length + "):"),
              cmdState.flights.map((flight) => React.createElement("div", { key: flight.id, style: { ...cmdStyles.flightCard, borderColor: flight.color } },
                React.createElement("div", null,
                  React.createElement("div", { style: { fontSize: "14px", fontWeight: "700", color: flight.color } }, flight.callsign),
                  React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0" } }, flight.pointCount + " track points \u2022 " + flight.filename)
                ),
                React.createElement("button", { onClick: () => removeFlight(flight.id), style: { background: "rgba(229,62,62,0.3)", border: "none", color: "#fc8181", padding: "8px 12px", borderRadius: "6px", cursor: "pointer", fontSize: "12px" } }, "\u2715 Remove")
              ))
            ),
            // Suggested Grid from track analysis
            cmdState.suggestedGrid && cmdState.selectedGrids.length === 0 && React.createElement("div", {
              style: {
                marginTop: "16px",
                padding: "14px",
                background: "linear-gradient(135deg, rgba(128,90,213,0.2), rgba(107,70,193,0.15))",
                border: "2px solid #805ad5",
                borderRadius: "10px"
              }
            },
              React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "10px", marginBottom: "10px" } },
                React.createElement("span", { style: { fontSize: "20px" } }, "\u{1F50D}"),
                React.createElement("span", { style: { fontSize: "14px", fontWeight: "700", color: "#b794f4" } }, "Search Area Detected")
              ),
              React.createElement("div", { style: { fontSize: "12px", color: "#e2e8f0", marginBottom: "12px", lineHeight: "1.5" } },
                "Based on flight track density analysis, the aircraft appears to have conducted search operations in:"
              ),
              React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "12px", marginBottom: "12px" } },
                React.createElement("div", { style: { fontSize: "24px", fontWeight: "700", color: "#f6e05e" } }, cmdState.suggestedGrid.gridId),
                React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0" } },
                  React.createElement("div", null, "Quadrants: " + (cmdState.suggestedGrid.activeQuadrants.join(", ") || "All")),
                  cmdState.suggestedGrid.activeEighths.length > 0 && cmdState.suggestedGrid.activeEighths.length <= 6 && 
                    React.createElement("div", null, "1/8 Grids: " + cmdState.suggestedGrid.activeEighths.join(", ")),
                  React.createElement("div", null, cmdState.suggestedGrid.clusterPercentage + "% of track points in search pattern")
                )
              ),
              React.createElement("div", { style: { display: "flex", gap: "8px" } },
                React.createElement("button", {
                  onClick: applySuggestedGrid,
                  style: {
                    flex: 1,
                    padding: "10px 16px",
                    borderRadius: "6px",
                    border: "none",
                    background: "linear-gradient(135deg, #805ad5, #6b46c1)",
                    color: "#fff",
                    fontWeight: "700",
                    fontSize: "13px",
                    cursor: "pointer"
                  }
                }, "\u2713 Use " + cmdState.suggestedGrid.gridId),
                React.createElement("button", {
                  onClick: () => setCmdState(prev => ({ ...prev, suggestedGrid: null })),
                  style: {
                    padding: "10px 16px",
                    borderRadius: "6px",
                    border: "1px solid rgba(255,255,255,0.2)",
                    background: "rgba(0,0,0,0.3)",
                    color: "#a0aec0",
                    fontWeight: "600",
                    fontSize: "13px",
                    cursor: "pointer"
                  }
                }, "Dismiss")
              )
            ),
            React.createElement("div", { style: { marginTop: "16px", padding: "12px", background: "rgba(0,0,0,0.2)", borderRadius: "8px" } },
              React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "8px" } },
                React.createElement("span", { style: { fontSize: "12px", fontWeight: "600", color: "#f6e05e" } }, "Coverage Width (each side):"),
                React.createElement("span", { style: { fontSize: "14px", fontWeight: "700", color: "#68d391" } }, cmdState.coverageWidth + " NM")
              ),
              React.createElement("input", { type: "range", min: "0.1", max: "2.0", step: "0.1", value: cmdState.coverageWidth, onChange: (e) => setCmdState(prev => ({ ...prev, coverageWidth: parseFloat(e.target.value) })), style: { width: "100%", accentColor: "#68d391" } }),
              React.createElement("div", { style: { display: "flex", justifyContent: "space-between", fontSize: "10px", color: "#a0aec0" } }, React.createElement("span", null, "0.1 NM"), React.createElement("span", null, "2.0 NM"))
            ),
            React.createElement("button", { onClick: () => calculateCoverage(true), disabled: cmdState.selectedGrids.length === 0 || cmdState.flights.length === 0, style: { ...cmdStyles.btn, width: "100%", marginTop: "16px", padding: "16px", fontSize: "16px", background: cmdState.selectedGrids.length > 0 && cmdState.flights.length > 0 ? "linear-gradient(135deg, #38a169, #2f855a)" : "rgba(100,100,100,0.3)", color: cmdState.selectedGrids.length > 0 && cmdState.flights.length > 0 ? "#fff" : "#a0aec0", cursor: cmdState.selectedGrids.length > 0 && cmdState.flights.length > 0 ? "pointer" : "not-allowed" } }, "\u{1F4CA} Analyze Coverage")
          )
        ),
        cmdState.selectedGrids.some(g => g.coverage !== undefined) && React.createElement("div", { style: cmdStyles.section },
          React.createElement("div", { style: { ...cmdStyles.sectionHeader, background: "linear-gradient(135deg, rgba(56,161,105,0.3), rgba(47,133,90,0.2))", borderColor: "rgba(104,211,145,0.4)" } }, React.createElement("span", null, "\u{1F4C8}"), "Coverage Analysis Results"),
          React.createElement("div", { style: cmdStyles.sectionBody },
            // Warning if ALL flights are outside search area
            cmdState.flightsOutsideArea && React.createElement("div", { 
              style: { 
                marginBottom: "16px", 
                padding: "14px", 
                background: "linear-gradient(135deg, rgba(214,158,46,0.2), rgba(221,107,32,0.15))", 
                border: "2px solid #d69e2e", 
                borderRadius: "8px" 
              } 
            },
              React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "10px", marginBottom: "8px" } },
                React.createElement("span", { style: { fontSize: "20px" } }, "\u26A0\uFE0F"),
                React.createElement("span", { style: { fontSize: "14px", fontWeight: "700", color: "#f6e05e" } }, "Flight Data Outside Search Area")
              ),
              React.createElement("div", { style: { fontSize: "12px", color: "#e2e8f0", lineHeight: "1.5" } }, 
                "The uploaded flight tracks do not overlap with the defined search grids. Coverage is 0% because the aircraft flew in a different area."
              ),
              cmdState.detectedFlightGrid && React.createElement("div", { style: { marginTop: "10px", padding: "10px", background: "rgba(0,0,0,0.2)", borderRadius: "6px" } },
                React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "4px" } }, "Flight tracks appear to be in:"),
                React.createElement("div", { style: { fontSize: "16px", fontWeight: "700", color: "#68d391" } }, cmdState.detectedFlightGrid),
                React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginTop: "6px" } }, 
                  "Consider adding this grid to your search area, or verify the correct KML files were uploaded."
                )
              )
            ),
            // Info if SOME flights are outside search area (but some are inside)
            cmdState.someFlightsOutside && React.createElement("div", { 
              style: { 
                marginBottom: "16px", 
                padding: "12px", 
                background: "linear-gradient(135deg, rgba(99,179,237,0.15), rgba(49,130,206,0.1))", 
                border: "1px solid rgba(99,179,237,0.4)", 
                borderRadius: "8px" 
              } 
            },
              React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "6px" } },
                React.createElement("span", { style: { fontSize: "16px" } }, "\u2139\uFE0F"),
                React.createElement("span", { style: { fontSize: "13px", fontWeight: "600", color: "#63b3ed" } }, "Partial Flight Data in Search Area")
              ),
              React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", lineHeight: "1.4" } }, 
                cmdState.pointsInsideArea.toLocaleString() + " of " + totalFlightPoints.toLocaleString() + " track points (" + Math.round(cmdState.pointsInsideArea / totalFlightPoints * 100) + "%) are within the search area. Points outside the grid are excluded from coverage calculation."
              )
            ),
            React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "12px", marginBottom: "20px" } },
              React.createElement("div", { style: cmdStyles.statBox }, React.createElement("div", { style: { ...cmdStyles.statValue, color: "#63b3ed" } }, cmdState.flights.length), React.createElement("div", { style: cmdStyles.statLabel }, "Aircraft")),
              React.createElement("div", { style: cmdStyles.statBox }, React.createElement("div", { style: { ...cmdStyles.statValue, color: "#f6e05e" } }, (cmdState.pointsInsideArea || totalFlightPoints).toLocaleString()), React.createElement("div", { style: cmdStyles.statLabel }, cmdState.someFlightsOutside ? "Points in Area" : "Track Points")),
              React.createElement("div", { style: cmdStyles.statBox }, React.createElement("div", { style: { ...cmdStyles.statValue, color: getCoverageColor(avgCoverage) } }, avgCoverage + "%"), React.createElement("div", { style: cmdStyles.statLabel }, "Avg Coverage"))
            ),
            // View on Map button
            React.createElement("button", { 
              onClick: () => setCmdState(prev => ({ ...prev, showMap: true, mapKey: prev.mapKey + 1 })),
              style: { ...cmdStyles.btn, width: "100%", marginBottom: "8px", padding: "14px", fontSize: "15px", background: "linear-gradient(135deg, #3182ce, #2b6cb0)", color: "#fff" }
            }, "\u{1F5FA}\uFE0F View Coverage Map"),
            // Recommend Mission button (only show if coverage < 100%)
            avgCoverage < 100 && !cmdState.flightsOutsideArea && React.createElement("button", { 
              onClick: generateMissionRecommendation,
              style: { ...cmdStyles.btn, width: "100%", marginBottom: "16px", padding: "14px", fontSize: "15px", background: "linear-gradient(135deg, #805ad5, #6b46c1)", color: "#fff" }
            }, "\u{1F9ED} Recommend Mission for Gaps"),
            cmdState.selectedGrids.map((g, i) => React.createElement("div", { key: i, style: { ...cmdStyles.gridCard, marginBottom: "16px" } },
              // Full grid coverage header
              React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "12px" } },
                React.createElement("span", { style: { fontSize: "18px", fontWeight: "700", color: "#f6e05e" } }, g.grid),
                React.createElement("span", { style: { fontSize: "24px", fontWeight: "700", color: getCoverageColor(g.coverage?.total || 0) } }, (g.coverage?.total || 0) + "%")
              ),
              React.createElement("div", { style: cmdStyles.coverageBar }, React.createElement("div", { style: { ...cmdStyles.coverageFill, width: (g.coverage?.total || 0) + "%", background: getCoverageColor(g.coverage?.total || 0) } })),
              // Quarter grid coverage
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: "8px", marginTop: "12px" } },
                ['A', 'B', 'C', 'D'].map(sub => { 
                  const pct = g.coverage?.[sub] || 0; 
                  const isActive = g.subgrids?.includes(sub); 
                  return React.createElement("div", { key: sub, style: { textAlign: "center", opacity: isActive ? 1 : 0.4 } }, 
                    React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "4px" } }, g.grid + sub), 
                    React.createElement("div", { style: { fontSize: "18px", fontWeight: "700", color: getCoverageColor(pct) } }, pct + "%"), 
                    React.createElement("div", { style: { ...cmdStyles.coverageBar, height: "8px" } }, 
                      React.createElement("div", { style: { ...cmdStyles.coverageFill, height: "100%", width: pct + "%", background: getCoverageColor(pct) } })
                    )
                  ); 
                })
              ),
              // 1/8 grid coverage (only if enabled and has data)
              g.showEighthGrids && g.coverage?.eighth && React.createElement("div", { style: { marginTop: "12px", paddingTop: "12px", borderTop: "1px solid rgba(183,148,244,0.3)" } },
                React.createElement("div", { style: { fontSize: "11px", fontWeight: "600", color: "#b794f4", marginBottom: "8px" } }, "1/8 Grid Coverage:"),
                React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: "4px" } },
                  // Geographic order: top-left to bottom-right
                  ['AA', 'AB', 'BA', 'BB', 'AC', 'AD', 'BC', 'BD', 'CA', 'CB', 'DA', 'DB', 'CC', 'CD', 'DC', 'DD'].map(eighthId => {
                      const quad = eighthId[0];
                      const pct = g.coverage?.eighth?.[eighthId] || 0;
                      const isActive = g.eighthGrids?.includes(eighthId);
                      const parentActive = g.subgrids?.includes(quad);
                      return React.createElement("div", { 
                        key: eighthId, 
                        style: { 
                          textAlign: "center", 
                          padding: "4px 2px",
                          background: isActive ? "rgba(183,148,244,0.15)" : "transparent",
                          borderRadius: "4px",
                          border: isActive ? "1px solid rgba(183,148,244,0.4)" : "1px solid transparent",
                          opacity: parentActive ? 1 : 0.3
                        } 
                      }, 
                        React.createElement("div", { style: { fontSize: "9px", color: "#a0aec0" } }, g.grid.split(' ')[1] + eighthId),
                        React.createElement("div", { style: { fontSize: "12px", fontWeight: "600", color: isActive ? getCoverageColor(pct) : "#718096" } }, pct + "%")
                      );
                    })
                )
              ),
              (g.coverage?.total || 0) < 100 && !cmdState.flightsOutsideArea && React.createElement("div", { style: { marginTop: "12px", padding: "10px", background: "rgba(229,62,62,0.15)", border: "1px solid rgba(229,62,62,0.3)", borderRadius: "6px" } },
                React.createElement("div", { style: { fontSize: "12px", fontWeight: "600", color: "#fc8181" } }, "\u26A0\uFE0F " + (100 - (g.coverage?.total || 0)) + "% of " + g.grid + " has NOT been visually covered"),
                React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginTop: "4px" } }, "Areas without flyover have zero probability of detection")
              )
            )),
            React.createElement("button", { onClick: () => setCmdState(prev => ({ ...prev, selectedGrids: prev.selectedGrids.map(g => ({ ...g, coverage: undefined, uncoveredCells: [] })), flights: [], routePoints: [], flightsOutsideArea: false, someFlightsOutside: false, pointsInsideArea: 0, pointsOutsideArea: 0, detectedFlightGrid: null })), style: { ...cmdStyles.btn, width: "100%", marginTop: "12px", background: "rgba(229,62,62,0.3)", color: "#fc8181" } }, "\u{1F5D1}\uFE0F Clear All & Reset")
          )
        ),
        // Coverage Map Modal
        cmdState.showMap && React.createElement("div", {
          style: {
            position: "fixed",
            top: 0, left: 0, right: 0, bottom: 0,
            background: "rgba(0,0,0,0.9)",
            zIndex: 10000,
            display: "flex",
            flexDirection: "column"
          }
        },
          // Modal header
          React.createElement("div", {
            style: {
              padding: "12px 16px",
              background: "linear-gradient(135deg, #1a202c, #2d3748)",
              borderBottom: "2px solid #4a5568",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center"
            }
          },
            React.createElement("div", { style: { fontSize: "16px", fontWeight: "700", color: "#f6e05e" } }, "\u{1F5FA}\uFE0F Coverage Analysis Map"),
            React.createElement("div", { style: { display: "flex", gap: "8px" } },
              React.createElement("button", {
                onClick: popOutCoverageMap,
                style: { background: "rgba(49,130,206,0.3)", border: "2px solid #63b3ed", borderRadius: "8px", padding: "8px 16px", color: "#63b3ed", fontWeight: "700", cursor: "pointer", fontSize: "14px" }
              }, "\u{1F5D7} Pop Out"),
              React.createElement("button", {
                onClick: () => setCmdState(prev => ({ ...prev, showMap: false })),
                style: { background: "rgba(229,62,62,0.3)", border: "2px solid #fc8181", borderRadius: "8px", padding: "8px 16px", color: "#fc8181", fontWeight: "700", cursor: "pointer", fontSize: "14px" }
              }, "\u2715 Close")
            )
          ),
          // Legend
          React.createElement("div", {
            style: {
              padding: "8px 16px",
              background: "rgba(0,0,0,0.5)",
              display: "flex",
              gap: "20px",
              flexWrap: "wrap",
              fontSize: "12px",
              borderBottom: "1px solid #4a5568"
            }
          },
            React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "6px" } },
              React.createElement("div", { style: { width: "20px", height: "6px", background: "#ff00ff", borderRadius: "2px" } }),
              React.createElement("span", { style: { color: "#e2e8f0" } }, "Search Grid Boundary")
            ),
            React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "6px" } },
              React.createElement("div", { style: { width: "20px", height: "4px", background: "#000000", borderRadius: "2px", border: "1px solid #fff" } }),
              React.createElement("span", { style: { color: "#e2e8f0" } }, "Flight Tracks (" + cmdState.flights.length + ")")
            ),
            React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "6px" } },
              React.createElement("div", { style: { width: "16px", height: "16px", background: "rgba(229,62,62,0.6)", borderRadius: "2px" } }),
              React.createElement("span", { style: { color: "#e2e8f0" } }, "Missing Coverage (0% POD)")
            )
          ),
          // Map container
          React.createElement("div", {
            id: "cmd-coverage-map-" + cmdState.mapKey,
            key: "map-" + cmdState.mapKey,
            style: { flex: 1 },
            ref: (el) => {
              if (el && !el._mapInit) {
                el._mapInit = true;
                
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                  // Calculate bounds from GRIDS ONLY (not flight paths)
                  let gridLats = [], gridLons = [];
                  cmdState.selectedGrids.forEach(g => {
                    if (g.gridBounds) {
                      gridLats.push(g.gridBounds.minLat, g.gridBounds.maxLat);
                      gridLons.push(g.gridBounds.minLon, g.gridBounds.maxLon);
                    } else if (g.corners) {
                      gridLats.push(g.corners.nw.lat, g.corners.sw.lat);
                      gridLons.push(g.corners.nw.lon, g.corners.ne.lon);
                    }
                  });
                  
                  const centerLat = gridLats.length > 0 ? (Math.min(...gridLats) + Math.max(...gridLats)) / 2 : 39;
                  const centerLon = gridLons.length > 0 ? (Math.min(...gridLons) + Math.max(...gridLons)) / 2 : -105;
                  
                  const map = L.map(el).setView([centerLat, centerLon], 11);
                  el._leafletMap = map; // Store reference for cleanup
                  
                  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: ' OpenStreetMap'
                  }).addTo(map);
                  
                  // Draw grid boundaries
                  cmdState.selectedGrids.forEach(g => {
                    // Get grid corners - either from gridBounds or corners property
                    let c = g.corners;
                    if (g.gridBounds && !c) {
                      c = {
                        nw: { lat: g.gridBounds.maxLat, lon: g.gridBounds.minLon },
                        ne: { lat: g.gridBounds.maxLat, lon: g.gridBounds.maxLon },
                        sw: { lat: g.gridBounds.minLat, lon: g.gridBounds.minLon },
                        se: { lat: g.gridBounds.minLat, lon: g.gridBounds.maxLon }
                      };
                    }
                    
                    if (c) {
                      const bounds = [[c.sw.lat, c.nw.lon], [c.nw.lat, c.ne.lon]];
                      L.rectangle(bounds, { color: '#ff00ff', weight: 5, fillOpacity: 0.05, dashArray: '10, 5' }).addTo(map).bindPopup(g.grid + ' - ' + (g.coverage?.total || 0) + '% covered');
                      
                      // Draw 1/4 grid lines (always show for full grids)
                      const midLat = (c.nw.lat + c.sw.lat) / 2;
                      const midLon = (c.nw.lon + c.ne.lon) / 2;
                      // Vertical line (separates A/C from B/D)
                      L.polyline([[c.nw.lat, midLon], [c.sw.lat, midLon]], { color: '#ff00ff', weight: 2, dashArray: '6, 4', opacity: 0.7 }).addTo(map);
                      // Horizontal line (separates A/B from C/D)
                      L.polyline([[midLat, c.nw.lon], [midLat, c.ne.lon]], { color: '#ff00ff', weight: 2, dashArray: '6, 4', opacity: 0.7 }).addTo(map);
                      
                      // Draw 1/8 grid lines if enabled
                      if (g.showEighthGrids) {
                        const q1Lat = (c.nw.lat + midLat) / 2;
                        const q3Lat = (midLat + c.sw.lat) / 2;
                        const q1Lon = (c.nw.lon + midLon) / 2;
                        const q3Lon = (midLon + c.ne.lon) / 2;
                        // Horizontal 1/8 lines
                        L.polyline([[q1Lat, c.nw.lon], [q1Lat, c.ne.lon]], { color: '#ff00ff', weight: 1, dashArray: '3, 3', opacity: 0.5 }).addTo(map);
                        L.polyline([[q3Lat, c.nw.lon], [q3Lat, c.ne.lon]], { color: '#ff00ff', weight: 1, dashArray: '3, 3', opacity: 0.5 }).addTo(map);
                        // Vertical 1/8 lines
                        L.polyline([[c.nw.lat, q1Lon], [c.sw.lat, q1Lon]], { color: '#ff00ff', weight: 1, dashArray: '3, 3', opacity: 0.5 }).addTo(map);
                        L.polyline([[c.nw.lat, q3Lon], [c.sw.lat, q3Lon]], { color: '#ff00ff', weight: 1, dashArray: '3, 3', opacity: 0.5 }).addTo(map);
                      }
                    }
                    
                    // Draw uncovered cells as red overlay
                    if (g.uncoveredCells && g.uncoveredCells.length > 0) {
                      // Group cells into clusters for performance
                      const cellsToShow = g.uncoveredCells.length > 500 
                        ? g.uncoveredCells.filter((_, i) => i % Math.ceil(g.uncoveredCells.length / 500) === 0)
                        : g.uncoveredCells;
                      
                      cellsToShow.forEach(cell => {
                        const halfLat = cell.latStep / 2;
                        const halfLon = cell.lonStep / 2;
                        L.rectangle(
                          [[cell.lat - halfLat, cell.lon - halfLon], [cell.lat + halfLat, cell.lon + halfLon]],
                          { color: '#e53e3e', weight: 0, fillColor: '#e53e3e', fillOpacity: 0.5 }
                        ).addTo(map);
                      });
                    }
                  });
                  
                  // Draw flight tracks
                  cmdState.flights.forEach(flight => {
                    const latLngs = flight.coordinates.map(c => [c.lat, c.lon]);
                    if (latLngs.length > 0) {
                      L.polyline(latLngs, { color: '#000000', weight: 3, opacity: 1.0 }).addTo(map).bindPopup(flight.callsign + ' - ' + flight.pointCount + ' points');
                    }
                  });
                  
                  // Fit bounds to GRIDS ONLY (user can zoom out to see full flight paths)
                  if (gridLats.length > 0 && gridLons.length > 0) {
                    const padding = 0.02;
                    map.fitBounds([
                      [Math.min(...gridLats) - padding, Math.min(...gridLons) - padding],
                      [Math.max(...gridLats) + padding, Math.max(...gridLons) + padding]
                    ]);
                  }
                }, 100);
              }
            }
          })
        ),
        // Mission Recommendation Modal
        cmdState.showMissionModal && cmdState.missionRecommendation && React.createElement("div", {
          style: {
            position: "fixed",
            top: 0, left: 0, right: 0, bottom: 0,
            background: "rgba(0,0,0,0.9)",
            zIndex: 10000,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            padding: "20px"
          }
        },
          React.createElement("div", {
            style: {
              background: "linear-gradient(135deg, #1a202c, #2d3748)",
              borderRadius: "16px",
              border: "2px solid #4a5568",
              maxWidth: "600px",
              width: "100%",
              maxHeight: "90vh",
              overflow: "auto"
            }
          },
            // Modal Header
            React.createElement("div", {
              style: {
                padding: "16px 20px",
                borderBottom: "2px solid #4a5568",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center"
              }
            },
              React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "10px" } },
                React.createElement("span", { style: { fontSize: "24px" } }, "\u{1F9ED}"),
                React.createElement("span", { style: { fontSize: "18px", fontWeight: "700", color: "#f6e05e" } }, "Recommended Search Mission")
              ),
              React.createElement("button", {
                onClick: () => setCmdState(prev => ({ ...prev, showMissionModal: false })),
                style: { background: "rgba(255,255,255,0.1)", border: "none", color: "#fff", fontSize: "20px", cursor: "pointer", padding: "8px 12px", borderRadius: "8px" }
              }, "\u2715")
            ),
            // Modal Body
            React.createElement("div", { style: { padding: "20px" } },
              // Search Type Badge
              React.createElement("div", { style: { display: "inline-block", padding: "6px 14px", background: "linear-gradient(135deg, #805ad5, #6b46c1)", borderRadius: "20px", fontSize: "13px", fontWeight: "600", color: "#fff", marginBottom: "16px" } },
                cmdState.missionRecommendation.searchType + " Search"
              ),
              // POI Section
              React.createElement("div", { style: { background: "rgba(0,0,0,0.3)", borderRadius: "12px", padding: "16px", marginBottom: "16px" } },
                React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginBottom: "6px", textTransform: "uppercase", letterSpacing: "1px" } }, "Point of Interest (POI)"),
                React.createElement("div", { style: { fontSize: "18px", fontWeight: "700", color: "#68d391", marginBottom: "4px" } }, cmdState.missionRecommendation.poi.formatted),
                React.createElement("div", { style: { fontSize: "13px", color: "#63b3ed" } }, "Grid: " + cmdState.missionRecommendation.gridId)
              ),
              // Search Parameters Grid
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "12px", marginBottom: "16px" } },
                React.createElement("div", { style: { background: "rgba(0,0,0,0.2)", borderRadius: "10px", padding: "14px" } },
                  React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "4px" } }, "TRACK SPACING"),
                  React.createElement("div", { style: { fontSize: "22px", fontWeight: "700", color: "#f6e05e" } }, cmdState.missionRecommendation.trackSpacing + " NM")
                ),
                React.createElement("div", { style: { background: "rgba(0,0,0,0.2)", borderRadius: "10px", padding: "14px" } },
                  React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "4px" } }, "LEG LENGTH"),
                  React.createElement("div", { style: { fontSize: "22px", fontWeight: "700", color: "#f6e05e" } }, cmdState.missionRecommendation.legLength + " NM")
                ),
                React.createElement("div", { style: { background: "rgba(0,0,0,0.2)", borderRadius: "10px", padding: "14px" } },
                  React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "4px" } }, "NUMBER OF LEGS"),
                  React.createElement("div", { style: { fontSize: "22px", fontWeight: "700", color: "#63b3ed" } }, cmdState.missionRecommendation.numLegs)
                ),
                React.createElement("div", { style: { background: "rgba(0,0,0,0.2)", borderRadius: "10px", padding: "14px" } },
                  React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "4px" } }, "EST. SEARCH TIME"),
                  React.createElement("div", { style: { fontSize: "22px", fontWeight: "700", color: "#fc8181" } }, cmdState.missionRecommendation.estimatedTime + " min")
                )
              ),
              // Orientation & Track
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "12px", marginBottom: "16px" } },
                React.createElement("div", { style: { background: "rgba(99,179,237,0.15)", border: "1px solid rgba(99,179,237,0.3)", borderRadius: "10px", padding: "14px" } },
                  React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "4px" } }, "ORIENTATION"),
                  React.createElement("div", { style: { fontSize: "15px", fontWeight: "600", color: "#63b3ed" } }, cmdState.missionRecommendation.orientation)
                ),
                React.createElement("div", { style: { background: "rgba(99,179,237,0.15)", border: "1px solid rgba(99,179,237,0.3)", borderRadius: "10px", padding: "14px" } },
                  React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "4px" } }, "INITIAL TRACK"),
                  React.createElement("div", { style: { fontSize: "15px", fontWeight: "600", color: "#63b3ed" } }, cmdState.missionRecommendation.initialTrack)
                )
              ),
              // Search Box Corners
              React.createElement("div", { style: { background: "rgba(0,0,0,0.3)", borderRadius: "12px", padding: "16px", marginBottom: "16px" } },
                React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginBottom: "10px", textTransform: "uppercase", letterSpacing: "1px" } }, "Search Box Corners"),
                React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "8px", fontSize: "12px" } },
                  React.createElement("div", null,
                    React.createElement("span", { style: { color: "#a0aec0" } }, "NW: "),
                    React.createElement("span", { style: { color: "#e2e8f0" } }, cmdState.missionRecommendation.corners.nw.lat.toFixed(4) + ", " + cmdState.missionRecommendation.corners.nw.lon.toFixed(4))
                  ),
                  React.createElement("div", null,
                    React.createElement("span", { style: { color: "#a0aec0" } }, "NE: "),
                    React.createElement("span", { style: { color: "#e2e8f0" } }, cmdState.missionRecommendation.corners.ne.lat.toFixed(4) + ", " + cmdState.missionRecommendation.corners.ne.lon.toFixed(4))
                  ),
                  React.createElement("div", null,
                    React.createElement("span", { style: { color: "#a0aec0" } }, "SW: "),
                    React.createElement("span", { style: { color: "#e2e8f0" } }, cmdState.missionRecommendation.corners.sw.lat.toFixed(4) + ", " + cmdState.missionRecommendation.corners.sw.lon.toFixed(4))
                  ),
                  React.createElement("div", null,
                    React.createElement("span", { style: { color: "#a0aec0" } }, "SE: "),
                    React.createElement("span", { style: { color: "#e2e8f0" } }, cmdState.missionRecommendation.corners.se.lat.toFixed(4) + ", " + cmdState.missionRecommendation.corners.se.lon.toFixed(4))
                  )
                )
              ),
              // Notes
              React.createElement("div", { style: { background: "rgba(246,224,94,0.1)", border: "1px solid rgba(246,224,94,0.3)", borderRadius: "10px", padding: "14px" } },
                React.createElement("div", { style: { fontSize: "12px", color: "#f6e05e", fontWeight: "600", marginBottom: "8px" } }, "\u{1F4DD} Planning Notes"),
                React.createElement("ul", { style: { margin: 0, paddingLeft: "18px", fontSize: "12px", color: "#e2e8f0", lineHeight: "1.6" } },
                  cmdState.missionRecommendation.notes.map((note, i) => React.createElement("li", { key: i }, note))
                )
              ),
              // Action Buttons
              React.createElement("div", { style: { display: "flex", gap: "12px", marginTop: "20px" } },
                React.createElement("button", {
                  onClick: () => {
                    // Copy to clipboard
                    const rec = cmdState.missionRecommendation;
                    const text = "SEARCH MISSION PARAMETERS\\n" +
                      "========================\\n" +
                      "Type: " + rec.searchType + "\\n" +
                      "POI: " + rec.poi.formatted + "\\n" +
                      "Grid: " + rec.gridId + "\\n" +
                      "Track Spacing: " + rec.trackSpacing + " NM\\n" +
                      "Leg Length: " + rec.legLength + " NM\\n" +
                      "Number of Legs: " + rec.numLegs + "\\n" +
                      "Initial Track: " + rec.initialTrack + "\\n" +
                      "Est. Time: " + rec.estimatedTime + " min\\n" +
                      "\\nCorners:\\n" +
                      "NW: " + rec.corners.nw.lat.toFixed(4) + ", " + rec.corners.nw.lon.toFixed(4) + "\\n" +
                      "NE: " + rec.corners.ne.lat.toFixed(4) + ", " + rec.corners.ne.lon.toFixed(4) + "\\n" +
                      "SW: " + rec.corners.sw.lat.toFixed(4) + ", " + rec.corners.sw.lon.toFixed(4) + "\\n" +
                      "SE: " + rec.corners.se.lat.toFixed(4) + ", " + rec.corners.se.lon.toFixed(4);
                    navigator.clipboard.writeText(text).then(() => alert('Mission parameters copied to clipboard!'));
                  },
                  style: { ...cmdStyles.btn, flex: 1, padding: "14px", background: "linear-gradient(135deg, #38a169, #2f855a)", color: "#fff" }
                }, "\u{1F4CB} Copy to Clipboard"),
                React.createElement("button", {
                  onClick: () => {
                    // Switch to Search Tools tab and populate with recommendation
                    const rec = cmdState.missionRecommendation;
                    const poiStr = rec.poi.lat.toFixed(6) + ", " + rec.poi.lon.toFixed(6);
                    const poiParsed = { latDD: rec.poi.lat, lonDD: rec.poi.lon };
                    const grid = spDetectCapGrid(rec.poi.lat, rec.poi.lon);
                    switchTab("searchPlanner");
                    setSpState(prev => ({
                      ...prev,
                      poiInput: poiStr,
                      poi: poiParsed,
                      detectedGrid: grid,
                      spacing: rec.trackSpacing,
                      gpLegLength: rec.legLength,
                      gpNumTracks: rec.numLegs,
                      gpUseDefaults: false,
                      patternType: 'gridParallelTrack'
                    }));
                    setCmdState(prev => ({ ...prev, showMissionModal: false }));
                  },
                  style: { ...cmdStyles.btn, flex: 1, padding: "14px", background: "linear-gradient(135deg, #805ad5, #6b46c1)", color: "#fff" }
                }, "\u{1F9ED} Open in Search Tools")
              )
            )
          )
        ),
        // Gap Selector Modal
        cmdState.showGapSelector && cmdState.gapOptions.length > 0 && React.createElement("div", {
          style: {
            position: "fixed",
            top: 0, left: 0, right: 0, bottom: 0,
            background: "rgba(0,0,0,0.9)",
            zIndex: 10000,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            padding: "20px"
          }
        },
          React.createElement("div", {
            style: {
              background: "linear-gradient(135deg, #1a202c, #2d3748)",
              borderRadius: "16px",
              border: "2px solid #4a5568",
              maxWidth: "700px",
              width: "100%",
              maxHeight: "90vh",
              overflow: "auto"
            }
          },
            // Modal Header
            React.createElement("div", {
              style: {
                padding: "16px 20px",
                borderBottom: "2px solid #4a5568",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center"
              }
            },
              React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "10px" } },
                React.createElement("span", { style: { fontSize: "24px" } }, "\u{1F3AF}"),
                React.createElement("span", { style: { fontSize: "18px", fontWeight: "700", color: "#f6e05e" } }, "Select Gap Area to Search")
              ),
              React.createElement("button", {
                onClick: () => setCmdState(prev => ({ ...prev, showGapSelector: false })),
                style: { background: "rgba(255,255,255,0.1)", border: "none", color: "#fff", fontSize: "20px", cursor: "pointer", padding: "8px 12px", borderRadius: "8px" }
              }, "\u2715")
            ),
            // Modal Body
            React.createElement("div", { style: { padding: "20px" } },
              // Instructions
              React.createElement("div", { style: { background: "rgba(99,179,237,0.1)", border: "1px solid rgba(99,179,237,0.3)", borderRadius: "10px", padding: "14px", marginBottom: "20px" } },
                React.createElement("div", { style: { fontSize: "13px", color: "#63b3ed", lineHeight: "1.5" } },
                  "Select a quarter-grid to generate a search pattern. Areas are sorted by priority (lowest coverage first). ",
                  React.createElement("span", { style: { color: "#f6e05e", fontWeight: "600" } }, "\u2B50 Recommended"),
                  " indicates the highest priority gap."
                )
              ),
              // Embedded Coverage Map
              React.createElement("div", { style: { marginBottom: "20px", borderRadius: "12px", overflow: "hidden", border: "2px solid #4a5568" } },
                React.createElement("div", { style: { padding: "8px 12px", background: "rgba(0,0,0,0.5)", display: "flex", justifyContent: "space-between", alignItems: "center" } },
                  React.createElement("span", { style: { fontSize: "12px", fontWeight: "600", color: "#f6e05e" } }, "\u{1F5FA}\uFE0F Coverage Map - Red = Gaps"),
                  React.createElement("div", { style: { display: "flex", gap: "12px", fontSize: "10px" } },
                    React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "4px" } },
                      React.createElement("div", { style: { width: "12px", height: "3px", background: "#ff00ff" } }),
                      React.createElement("span", { style: { color: "#a0aec0" } }, "Grid")
                    ),
                    React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "4px" } },
                      React.createElement("div", { style: { width: "12px", height: "12px", background: "rgba(229,62,62,0.6)", borderRadius: "2px" } }),
                      React.createElement("span", { style: { color: "#a0aec0" } }, "Uncovered")
                    )
                  )
                ),
                React.createElement("div", {
                  id: "gap-selector-map-" + cmdState.mapKey,
                  style: { height: "250px", width: "100%" },
                  ref: (el) => {
                    if (el && !el._mapInit && typeof L !== 'undefined') {
                      el._mapInit = true;
                      setTimeout(() => {
                        // Calculate bounds from selected grids
                        let gridLats = [], gridLons = [];
                        cmdState.selectedGrids.forEach(g => {
                          if (g.gridBounds) {
                            gridLats.push(g.gridBounds.minLat, g.gridBounds.maxLat);
                            gridLons.push(g.gridBounds.minLon, g.gridBounds.maxLon);
                          } else if (g.corners) {
                            gridLats.push(g.corners.nw.lat, g.corners.sw.lat);
                            gridLons.push(g.corners.nw.lon, g.corners.ne.lon);
                          }
                        });
                        
                        const centerLat = gridLats.length > 0 ? (Math.min(...gridLats) + Math.max(...gridLats)) / 2 : 39;
                        const centerLon = gridLons.length > 0 ? (Math.min(...gridLons) + Math.max(...gridLons)) / 2 : -105;
                        
                        const map = L.map(el).setView([centerLat, centerLon], 10);
                        el._leafletMap = map;
                        
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                          attribution: '\u00A9 OpenStreetMap'
                        }).addTo(map);
                        
                        // Draw grid boundaries and quarter-grid lines
                        cmdState.selectedGrids.forEach(g => {
                          let c = g.corners;
                          if (g.gridBounds && !c) {
                            c = {
                              nw: { lat: g.gridBounds.maxLat, lon: g.gridBounds.minLon },
                              ne: { lat: g.gridBounds.maxLat, lon: g.gridBounds.maxLon },
                              sw: { lat: g.gridBounds.minLat, lon: g.gridBounds.minLon },
                              se: { lat: g.gridBounds.minLat, lon: g.gridBounds.maxLon }
                            };
                          }
                          if (c) {
                            // Main grid boundary
                            const bounds = [[c.sw.lat, c.nw.lon], [c.nw.lat, c.ne.lon]];
                            L.rectangle(bounds, { color: '#ff00ff', weight: 3, fillOpacity: 0.02 }).addTo(map);
                            
                            // Quarter grid lines
                            const midLat = (c.nw.lat + c.sw.lat) / 2;
                            const midLon = (c.nw.lon + c.ne.lon) / 2;
                            L.polyline([[c.nw.lat, midLon], [c.sw.lat, midLon]], { color: '#ff00ff', weight: 2, dashArray: '5, 5', opacity: 0.6 }).addTo(map);
                            L.polyline([[midLat, c.nw.lon], [midLat, c.ne.lon]], { color: '#ff00ff', weight: 2, dashArray: '5, 5', opacity: 0.6 }).addTo(map);
                            
                            // Add quarter grid labels
                            const labelStyle = { className: 'grid-label', iconSize: [40, 16] };
                            ['A', 'B', 'C', 'D'].forEach(quad => {
                              let labelLat, labelLon;
                              switch(quad) {
                                case 'A': labelLat = (c.nw.lat + midLat) / 2; labelLon = (c.nw.lon + midLon) / 2; break;
                                case 'B': labelLat = (c.ne.lat + midLat) / 2; labelLon = (midLon + c.ne.lon) / 2; break;
                                case 'C': labelLat = (midLat + c.sw.lat) / 2; labelLon = (c.sw.lon + midLon) / 2; break;
                                case 'D': labelLat = (midLat + c.se.lat) / 2; labelLon = (midLon + c.se.lon) / 2; break;
                              }
                              const gapInfo = cmdState.gapOptions.find(gap => gap.baseGrid === g.grid && gap.quadrant === quad);
                              const coverage = gapInfo ? gapInfo.coverage : (g.coverage && g.coverage[quad]) || 0;
                              const isRecommended = gapInfo && gapInfo.isRecommended;
                              L.marker([labelLat, labelLon], {
                                icon: L.divIcon({
                                  className: '',
                                  html: '<div style="background:' + (isRecommended ? '#f6e05e' : 'rgba(0,0,0,0.7)') + ';color:' + (isRecommended ? '#1a202c' : '#fff') + ';padding:2px 6px;border-radius:4px;font-size:11px;font-weight:700;white-space:nowrap;border:' + (isRecommended ? '2px solid #d69e2e' : '1px solid #666') + ';">' + g.grid + quad + ' ' + coverage + '%</div>',
                                  iconSize: [60, 20],
                                  iconAnchor: [30, 10]
                                })
                              }).addTo(map);
                            });
                          }
                        });
                        
                        // Draw flight tracks
                        cmdState.flights.forEach((flight, fi) => {
                          if (flight.coordinates && flight.coordinates.length > 1) {
                            const coords = flight.coordinates.map(c => [c.lat, c.lon]);
                            L.polyline(coords, { color: '#000', weight: 2, opacity: 0.8 }).addTo(map);
                          }
                        });
                        
                        // Draw uncovered cells (gaps) - sample for performance
                        cmdState.selectedGrids.forEach(g => {
                          if (g.uncoveredCells && g.uncoveredCells.length > 0) {
                            const maxDots = 300;
                            const step = Math.max(1, Math.floor(g.uncoveredCells.length / maxDots));
                            for (let i = 0; i < g.uncoveredCells.length; i += step) {
                              const cell = g.uncoveredCells[i];
                              L.circleMarker([cell.lat, cell.lon], {
                                radius: 4,
                                color: 'rgba(229,62,62,0.8)',
                                fillColor: 'rgba(229,62,62,0.5)',
                                fillOpacity: 0.5,
                                weight: 1
                              }).addTo(map);
                            }
                          }
                        });
                        
                        // Fit map to grid bounds
                        if (gridLats.length > 0) {
                          map.fitBounds([[Math.min(...gridLats), Math.min(...gridLons)], [Math.max(...gridLats), Math.max(...gridLons)]], { padding: [20, 20] });
                        }
                      }, 100);
                    }
                  }
                })
              ),
              // Gap Options Grid
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(200px, 1fr))", gap: "12px" } },
                cmdState.gapOptions.map((gap, idx) => 
                  React.createElement("div", {
                    key: gap.gridId,
                    onClick: () => generateMissionForGap(gap),
                    style: {
                      background: gap.isRecommended ? "rgba(246,224,94,0.15)" : "rgba(0,0,0,0.3)",
                      border: gap.isRecommended ? "2px solid #f6e05e" : "1px solid #4a5568",
                      borderRadius: "12px",
                      padding: "16px",
                      cursor: "pointer",
                      transition: "all 0.2s ease"
                    }
                  },
                    // Recommended badge
                    gap.isRecommended && React.createElement("div", { 
                      style: { 
                        display: "inline-block",
                        background: "linear-gradient(135deg, #f6e05e, #d69e2e)",
                        color: "#1a202c",
                        fontSize: "10px",
                        fontWeight: "700",
                        padding: "3px 8px",
                        borderRadius: "10px",
                        marginBottom: "10px"
                      } 
                    }, "\u2B50 RECOMMENDED"),
                    // Grid ID
                    React.createElement("div", { style: { fontSize: "18px", fontWeight: "700", color: gap.isRecommended ? "#f6e05e" : "#e2e8f0", marginBottom: "8px" } }, gap.gridId),
                    // Coverage stats
                    React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "8px" } },
                      React.createElement("span", { style: { fontSize: "12px", color: "#a0aec0" } }, "Current Coverage"),
                      React.createElement("span", { style: { fontSize: "16px", fontWeight: "700", color: getCoverageColor(gap.coverage) } }, gap.coverage + "%")
                    ),
                    // Coverage bar
                    React.createElement("div", { style: { background: "rgba(255,255,255,0.1)", borderRadius: "4px", height: "8px", overflow: "hidden", marginBottom: "10px" } },
                      React.createElement("div", { style: { height: "100%", width: gap.coverage + "%", background: getCoverageColor(gap.coverage), borderRadius: "4px" } })
                    ),
                    // Gap percentage
                    React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center" } },
                      React.createElement("span", { style: { fontSize: "12px", color: "#fc8181" } }, "Gap to Fill"),
                      React.createElement("span", { style: { fontSize: "14px", fontWeight: "600", color: "#fc8181" } }, gap.gapPercent + "%")
                    ),
                    // Click hint
                    React.createElement("div", { style: { marginTop: "12px", fontSize: "11px", color: "#718096", textAlign: "center" } }, "Click to generate mission")
                  )
                )
              ),
              // Visual Grid Preview (simplified)
              React.createElement("div", { style: { marginTop: "24px", padding: "16px", background: "rgba(0,0,0,0.3)", borderRadius: "12px" } },
                React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginBottom: "12px", textTransform: "uppercase", letterSpacing: "1px" } }, "Coverage Overview"),
                // Group by base grid
                [...new Set(cmdState.gapOptions.map(g => g.baseGrid))].map(baseGrid => {
                  const gridGaps = cmdState.gapOptions.filter(g => g.baseGrid === baseGrid);
                  return React.createElement("div", { key: baseGrid, style: { marginBottom: "16px" } },
                    React.createElement("div", { style: { fontSize: "14px", fontWeight: "600", color: "#e2e8f0", marginBottom: "8px" } }, baseGrid),
                    React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "4px", maxWidth: "200px" } },
                      // Show A, B, C, D in correct positions (A=NW, B=NE, C=SW, D=SE)
                      ['A', 'B', 'C', 'D'].map(quad => {
                        const gap = gridGaps.find(g => g.quadrant === quad);
                        const coverage = gap ? gap.coverage : 100;
                        const isSelected = gap && gap.isRecommended;
                        return React.createElement("div", {
                          key: quad,
                          onClick: () => gap && generateMissionForGap(gap),
                          style: {
                            background: getCoverageColor(coverage),
                            opacity: gap ? 1 : 0.3,
                            padding: "8px",
                            borderRadius: "4px",
                            textAlign: "center",
                            cursor: gap ? "pointer" : "default",
                            border: isSelected ? "2px solid #f6e05e" : "2px solid transparent"
                          }
                        },
                          React.createElement("div", { style: { fontSize: "11px", fontWeight: "600", color: "#1a202c" } }, baseGrid + quad),
                          React.createElement("div", { style: { fontSize: "14px", fontWeight: "700", color: "#1a202c" } }, coverage + "%")
                        );
                      })
                    )
                  );
                })
              )
            )
          )
        )
      );
    };

    // PROFICIENCY PROFILE TAB
    const renderProficiencyTab = () => {
      const profile = proficiencyState.selectedProfile ? proficiencyProfiles.find(p => p.id === proficiencyState.selectedProfile) : null;
      
      const toggleItem = (itemId) => {
        setProficiencyState(prev => {
          const newCompleted = { ...prev.completedItems };
          if (newCompleted[itemId]) {
            delete newCompleted[itemId];
          } else {
            newCompleted[itemId] = new Date().toISOString();
          }
          return { ...prev, completedItems: newCompleted };
        });
      };
      
      const resetProfile = () => {
        setProficiencyState({ selectedProfile: null, completedItems: {}, notes: '', startTime: null });
      };
      
      const startProfile = (profileId) => {
        setProficiencyState({ selectedProfile: profileId, completedItems: {}, notes: '', startTime: new Date().toISOString() });
      };
      
      // Calculate completion based on MINIMUM requirements
      // For pickOne groups: only 1 item needed to satisfy requirement
      // For pickPath groups: ALL items in ONE path needed (choose one complete path)
      // For regular groups: all items needed
      const getCompletionStats = () => {
        if (!profile) return { required: 0, total: 0, routine: 0, routineTotal: 0 };
        let minRequirements = 0;
        let minRequirementsMet = 0;
        let routItems = [], routCompleted = 0;
        
        (profile.sections || []).forEach(section => {
          if (section.type === 'routine') {
            (section.groups || []).forEach(group => {
              (group.items || []).forEach(item => {
                routItems.push(item);
                if (proficiencyState.completedItems[item.id]) routCompleted++;
              });
            });
          } else if (section.type === 'required' || section.type === 'block') {
            // Collect pickPath groups by pathId
            const pathGroups = {};
            const regularGroups = [];
            
            (section.groups || []).forEach(group => {
              if (group.separator) return; // Skip separator groups
              if (group.pickPath && group.pathId) {
                pathGroups[group.pathId] = group;
              } else {
                regularGroups.push(group);
              }
            });
            
            // Handle pickPath groups - need ALL items in ONE path
            const pathIds = Object.keys(pathGroups);
            if (pathIds.length > 0) {
              minRequirements++; // One requirement: complete any one path
              const anyPathComplete = pathIds.some(pathId => {
                const group = pathGroups[pathId];
                return (group.items || []).every(item => proficiencyState.completedItems[item.id]);
              });
              if (anyPathComplete) minRequirementsMet++;
            }
            
            // Handle regular groups
            regularGroups.forEach(group => {
              if (group.pickOne) {
                // For pickOne with subChecklists: need parent checked + all sub-items complete
                minRequirements++;
                const anyFullyComplete = (group.items || []).some(item => {
                  if (!proficiencyState.completedItems[item.id]) return false;
                  // If has subChecklist, all sub-items must also be complete
                  if (item.subChecklist && item.subChecklist.items) {
                    return item.subChecklist.items.every(si => proficiencyState.completedItems[si.id]);
                  }
                  return true;
                });
                if (anyFullyComplete) minRequirementsMet++;
              } else {
                (group.items || []).forEach(item => {
                  minRequirements++;
                  if (proficiencyState.completedItems[item.id]) minRequirementsMet++;
                  // SubChecklist items in non-pickOne groups each count as requirements
                  if (item.subChecklist && item.subChecklist.items && proficiencyState.completedItems[item.id]) {
                    item.subChecklist.items.forEach(si => {
                      minRequirements++;
                      if (proficiencyState.completedItems[si.id]) minRequirementsMet++;
                    });
                  }
                });
              }
            });
          }
        });
        
        return { 
          required: minRequirementsMet, 
          total: minRequirements, 
          routine: routCompleted, 
          routineTotal: routItems.length 
        };
      };
      
      const stats = getCompletionStats();
      
      const profStyles = {
        card: { background: "rgba(45,55,72,0.6)", borderRadius: "12px", padding: "16px", marginBottom: "12px", border: "1px solid rgba(255,255,255,0.1)" },
        profileBtn: { width: "100%", padding: "16px", marginBottom: "8px", background: "rgba(0,0,0,0.3)", border: "2px solid rgba(99,179,237,0.3)", borderRadius: "10px", color: "#fff", fontSize: "15px", fontWeight: "600", cursor: "pointer", textAlign: "left", display: "flex", justifyContent: "space-between", alignItems: "center" },
        checkItem: { display: "flex", alignItems: "flex-start", padding: "12px", marginBottom: "4px", background: "rgba(0,0,0,0.2)", borderRadius: "8px", cursor: "pointer", border: "2px solid transparent", transition: "all 0.2s" },
        checkBox: { width: "26px", height: "26px", borderRadius: "6px", border: "2px solid", display: "flex", alignItems: "center", justifyContent: "center", marginRight: "10px", fontSize: "14px", flexShrink: 0, marginTop: "2px" },
        sectionHeader: { fontSize: "15px", fontWeight: "700", marginBottom: "12px", marginTop: "20px", padding: "10px 12px", borderRadius: "8px" },
        instruction: { fontSize: "13px", color: "#cbd5e0", marginBottom: "10px", padding: "10px 12px", background: "rgba(0,0,0,0.2)", borderRadius: "6px", lineHeight: "1.5", borderLeft: "3px solid" },
        pickOneLabel: { fontSize: "11px", fontWeight: "600", color: "#f6e05e", marginBottom: "6px", display: "flex", alignItems: "center", gap: "6px" },
        note: { fontSize: "11px", color: "#a0aec0", fontStyle: "italic", marginBottom: "8px", padding: "8px", background: "rgba(246,224,94,0.1)", borderRadius: "4px" }
      };
      
      const getSectionColors = (type) => {
        switch(type) {
          case 'required': return { bg: "rgba(56,161,105,0.15)", border: "#38a169", text: "#68d391", icon: "\u{1F7E2}" };
          case 'block': return { bg: "rgba(49,130,206,0.15)", border: "#3182ce", text: "#63b3ed", icon: "\u{1F4D8}" };
          case 'routine': return { bg: "rgba(246,224,94,0.1)", border: "#d69e2e", text: "#f6e05e", icon: "\u{1F7E1}" };
          default: return { bg: "rgba(160,174,192,0.1)", border: "#718096", text: "#a0aec0", icon: "\u2610" };
        }
      };
      
      // Profile selection view
      if (!profile) {
        return React.createElement("div", null,
          React.createElement("div", { style: { ...profStyles.card, background: "linear-gradient(135deg, rgba(56,161,105,0.2), rgba(49,130,206,0.2))", borderColor: "rgba(104,211,145,0.4)" } },
            React.createElement("div", { style: { fontSize: "18px", fontWeight: "700", color: "#68d391", marginBottom: "8px" } }, "\u2705 Flight Proficiency Profiles"),
            React.createElement("div", { style: { fontSize: "13px", color: "#a0aec0" } }, "CAPS 71-4 (16 May 2024) AFAM-approved profiles. Select a profile to track task completion during your flight.")
          ),
          (missionInfo.missionNumber || missionInfo.aircraftTailN) && React.createElement("div", { style: { ...profStyles.card, background: "rgba(99,179,237,0.1)", borderColor: "rgba(99,179,237,0.3)" } },
            React.createElement("div", { style: { fontSize: "12px", color: "#63b3ed", fontWeight: "600", marginBottom: "4px" } }, "Current Mission"),
            React.createElement("div", { style: { fontSize: "14px", color: "#e2e8f0" } }, 
              missionInfo.missionNumber && React.createElement("span", null, "Mission: ", missionInfo.missionNumber, " "),
              missionInfo.aircraftTailN && React.createElement("span", null, "| Aircraft: N", missionInfo.aircraftTailN)
            )
          ),
          React.createElement("div", { style: { fontSize: "13px", fontWeight: "600", color: "#a0aec0", marginBottom: "12px", marginTop: "16px" } }, "SELECT PROFILE:"),
          proficiencyProfiles.map(p => 
            React.createElement("button", { key: p.id, onClick: () => startProfile(p.id), style: profStyles.profileBtn },
              React.createElement("div", null,
                React.createElement("div", { style: { color: "#68d391" } }, "P", p.id, " - ", p.name),
                React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", fontWeight: "400", marginTop: "2px" } }, p.prereq, " | Max: ", p.maxDuration)
              ),
              React.createElement("span", { style: { fontSize: "20px" } }, "\u25B6")
            )
          )
        );
      }
      
      // Render a single check item (with optional subChecklist support)
      const renderCheckItem = (item, colors, isPickOne) => {
        const isComplete = !!proficiencyState.completedItems[item.id];
        const hasSubChecklist = item.subChecklist && item.subChecklist.items && item.subChecklist.items.length > 0;
        const subItems = hasSubChecklist ? item.subChecklist.items : [];
        const subCompleted = subItems.filter(si => proficiencyState.completedItems[si.id]).length;
        const allSubComplete = hasSubChecklist && subCompleted === subItems.length;
        
        return React.createElement("div", { key: item.id },
          React.createElement("div", {
            onClick: () => toggleItem(item.id),
            style: { ...profStyles.checkItem, borderColor: isComplete ? colors.border + "80" : "transparent", background: isComplete ? colors.bg : "rgba(0,0,0,0.15)", marginLeft: isPickOne ? "12px" : "0" }
          },
            React.createElement("div", { style: { ...profStyles.checkBox, borderColor: isComplete ? colors.text : "#4a5568", background: isComplete ? colors.text : "transparent", color: "#1a202c" } },
              isComplete ? "\u2713" : ""
            ),
            React.createElement("div", { style: { flex: 1 } },
              React.createElement("div", { style: { fontSize: "14px", color: isComplete ? colors.text : "#e2e8f0", fontWeight: "500", lineHeight: "1.4" } }, 
                item.text,
                hasSubChecklist && React.createElement("span", { style: { fontSize: "11px", color: "#a0aec0", marginLeft: "8px" } }, 
                  isComplete ? (allSubComplete ? "\u2705 " + subCompleted + "/" + subItems.length : "\u{1F4CB} " + subCompleted + "/" + subItems.length) : "(tap to expand)"
                )
              ),
              isComplete && !hasSubChecklist && React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", marginTop: "3px" } },
                "\u2713 ", new Date(proficiencyState.completedItems[item.id]).toLocaleTimeString()
              )
            )
          ),
          // Render expanded subChecklist when parent is selected
          hasSubChecklist && isComplete && React.createElement("div", { 
            style: { 
              marginLeft: "24px", 
              marginTop: "8px", 
              marginBottom: "12px", 
              padding: "12px", 
              background: "rgba(99,179,237,0.1)", 
              borderRadius: "8px", 
              borderLeft: "3px solid #63b3ed" 
            } 
          },
            item.subChecklist.instruction && React.createElement("div", { style: { fontSize: "12px", color: "#63b3ed", marginBottom: "8px", fontWeight: "500" } }, item.subChecklist.instruction),
            item.subChecklist.note && React.createElement("div", { style: { fontSize: "11px", color: "#f6e05e", marginBottom: "8px", fontStyle: "italic", background: "rgba(246,224,94,0.1)", padding: "6px 8px", borderRadius: "4px" } }, "\u{1F4DD} ", item.subChecklist.note),
            subItems.map(subItem => {
              const subComplete = !!proficiencyState.completedItems[subItem.id];
              return React.createElement("div", {
                key: subItem.id,
                onClick: (e) => { e.stopPropagation(); toggleItem(subItem.id); },
                style: { 
                  display: "flex", 
                  alignItems: "flex-start", 
                  padding: "8px", 
                  marginBottom: "4px", 
                  background: subComplete ? "rgba(104,211,145,0.15)" : "rgba(0,0,0,0.2)", 
                  borderRadius: "6px", 
                  cursor: "pointer",
                  border: subComplete ? "1px solid rgba(104,211,145,0.4)" : "1px solid transparent"
                }
              },
                React.createElement("div", { 
                  style: { 
                    width: "22px", 
                    height: "22px", 
                    borderRadius: "4px", 
                    border: "2px solid " + (subComplete ? "#68d391" : "#4a5568"), 
                    background: subComplete ? "#68d391" : "transparent", 
                    display: "flex", 
                    alignItems: "center", 
                    justifyContent: "center", 
                    marginRight: "8px", 
                    fontSize: "12px", 
                    color: "#1a202c",
                    flexShrink: 0
                  } 
                }, subComplete ? "\u2713" : ""),
                React.createElement("div", { style: { flex: 1, fontSize: "13px", color: subComplete ? "#68d391" : "#e2e8f0", lineHeight: "1.4" } }, 
                  subItem.text,
                  subComplete && React.createElement("span", { style: { fontSize: "10px", color: "#a0aec0", marginLeft: "8px" } }, 
                    new Date(proficiencyState.completedItems[subItem.id]).toLocaleTimeString()
                  )
                )
              );
            })
          )
        );
      };
      
      // Active profile tracking view
      return React.createElement("div", null,
        // Header
        React.createElement("div", { style: { ...profStyles.card, background: "linear-gradient(135deg, rgba(56,161,105,0.3), rgba(49,130,206,0.2))", borderColor: "rgba(104,211,145,0.5)" } },
          React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start" } },
            React.createElement("div", null,
              React.createElement("div", { style: { fontSize: "11px", color: "#68d391", fontWeight: "600" } }, "PROFILE P", profile.id),
              React.createElement("div", { style: { fontSize: "18px", fontWeight: "700", color: "#fff", marginBottom: "4px" } }, profile.name),
              React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0" } }, profile.prereq),
              React.createElement("div", { style: { fontSize: "11px", color: "#718096", marginTop: "2px" } }, "Max Duration: ", profile.maxDuration)
            ),
            React.createElement("button", { onClick: resetProfile, style: { padding: "8px 12px", background: "rgba(252,129,129,0.2)", border: "1px solid rgba(252,129,129,0.4)", borderRadius: "6px", color: "#fc8181", fontSize: "12px", fontWeight: "600", cursor: "pointer" } }, "\u2715 Close")
          ),
          profile.note && React.createElement("div", { style: { marginTop: "10px", fontSize: "11px", color: "#f6e05e", background: "rgba(246,224,94,0.1)", padding: "8px", borderRadius: "4px" } }, "\u26A0\uFE0F ", profile.note),
          React.createElement("div", { style: { marginTop: "12px" } },
            React.createElement("div", { style: { display: "flex", justifyContent: "space-between", fontSize: "11px", color: "#a0aec0", marginBottom: "4px" } },
              React.createElement("span", null, "Required: ", stats.required, "/", stats.total),
              stats.routineTotal > 0 && React.createElement("span", null, "Routine: ", stats.routine, "/", stats.routineTotal)
            ),
            React.createElement("div", { style: { height: "8px", background: "rgba(0,0,0,0.3)", borderRadius: "4px", overflow: "hidden" } },
              React.createElement("div", { style: { height: "100%", width: (stats.total > 0 ? (stats.required / stats.total) * 100 : 0) + "%", background: stats.required === stats.total && stats.total > 0 ? "linear-gradient(90deg, #38a169, #68d391)" : "linear-gradient(90deg, #3182ce, #63b3ed)", transition: "width 0.3s" } })
            )
          ),
          proficiencyState.startTime && React.createElement("div", { style: { marginTop: "8px", fontSize: "11px", color: "#a0aec0" } }, "Started: ", new Date(proficiencyState.startTime).toLocaleTimeString())
        ),
        
        // Render sections
        (profile.sections || []).map((section, sIdx) => {
          const colors = getSectionColors(section.type);
          return React.createElement("div", { key: sIdx },
            React.createElement("div", { style: { ...profStyles.sectionHeader, background: colors.bg, color: colors.text, borderLeft: "4px solid " + colors.border } },
              colors.icon, " ", section.title,
              section.type === 'routine' && React.createElement("span", { style: { fontSize: "11px", fontWeight: "400", marginLeft: "8px" } }, "(as time permits)")
            ),
            section.instruction && React.createElement("div", { style: { ...profStyles.instruction, borderLeftColor: colors.border } }, section.instruction),
            section.note && React.createElement("div", { style: profStyles.note }, "\u{1F4DD} ", section.note),
            (section.groups || []).map((group, gIdx) => {
              // Handle separator groups
              if (group.separator) {
                return React.createElement("div", { key: gIdx, style: { textAlign: "center", padding: "8px 0", fontSize: "13px", fontWeight: "700", color: "#f6e05e" } }, group.instruction || " OR ");
              }
              
              // Check if this is a pickPath group and if ALL items in this path are complete
              const isPathComplete = group.pickPath && (group.items || []).every(item => proficiencyState.completedItems[item.id]);
              const pathBorderColor = group.pickPath ? (isPathComplete ? "#68d391" : "#805ad5") : (group.pickOne ? "#f6e05e" : colors.border);
              const pathBgColor = group.pickPath ? (isPathComplete ? "rgba(104,211,145,0.15)" : "rgba(128,90,213,0.1)") : (group.pickOne ? "rgba(246,224,94,0.1)" : "rgba(0,0,0,0.2)");
              
              return React.createElement("div", { key: gIdx, style: { marginBottom: "12px" } },
                group.instruction && React.createElement("div", { style: { ...profStyles.instruction, borderLeftColor: pathBorderColor, background: pathBgColor } },
                  group.pickPath && React.createElement("div", { style: { ...profStyles.pickOneLabel, color: isPathComplete ? "#68d391" : "#b794f4" } }, 
                    isPathComplete ? "\u2705 PATH COMPLETE" : "\u{1F536} COMPLETE ALL IN THIS PATH:"
                  ),
                  group.pickOne && React.createElement("div", { style: profStyles.pickOneLabel }, "\u2B50 SELECT ONE OR MORE:"),
                  group.instruction
                ),
                group.conditional && React.createElement("div", { style: { fontSize: "11px", color: "#f6e05e", marginBottom: "6px", fontStyle: "italic" } }, 
                  group.conditional === "instrument" ? "\u2708\uFE0F If instrument qualified:" : 
                  group.conditional === "ipcOnly" ? "\u{1F4CB} For IPC only:" : ""
                ),
                !group.instruction && group.pickOne && React.createElement("div", { style: { ...profStyles.pickOneLabel, marginBottom: "8px", marginLeft: "4px" } }, "\u2B50 SELECT ONE OR MORE:"),
                !group.instruction && group.pickPath && React.createElement("div", { style: { ...profStyles.pickOneLabel, marginBottom: "8px", marginLeft: "4px", color: isPathComplete ? "#68d391" : "#b794f4" } }, 
                  isPathComplete ? "\u2705 PATH COMPLETE" : "\u{1F536} COMPLETE ALL IN THIS PATH:"
                ),
                (group.items || []).map(item => renderCheckItem(item, group.pickPath ? { ...colors, border: pathBorderColor, text: isPathComplete ? "#68d391" : colors.text, bg: pathBgColor } : colors, group.pickOne || group.pickPath))
              );
            })
          );
        }),
        
        // Notes
        React.createElement("div", { style: { marginTop: "20px" } },
          React.createElement("div", { style: { ...profStyles.sectionHeader, background: "rgba(160,174,192,0.1)", color: "#a0aec0", borderLeft: "4px solid #718096" } }, "\u{1F4DD} NOTES / JUSTIFICATIONS"),
          React.createElement("textarea", {
            value: proficiencyState.notes,
            onChange: (e) => setProficiencyState(prev => ({ ...prev, notes: e.target.value })),
            placeholder: "Document any omissions, weather factors, equipment issues, or other notes for CAPF 104...",
            style: { width: "100%", minHeight: "100px", padding: "12px", background: "rgba(0,0,0,0.3)", border: "1px solid rgba(255,255,255,0.2)", borderRadius: "8px", color: "#fff", fontSize: "14px", resize: "vertical" }
          })
        ),
        
        // Summary
        React.createElement("div", { style: { ...profStyles.card, marginTop: "16px", background: "rgba(99,179,237,0.1)", borderColor: "rgba(99,179,237,0.3)" } },
          React.createElement("div", { style: { fontSize: "12px", color: "#63b3ed", fontWeight: "600", marginBottom: "8px" } }, "CAPF 104 SUMMARY"),
          React.createElement("div", { style: { fontSize: "12px", color: "#e2e8f0", fontFamily: "monospace", background: "rgba(0,0,0,0.3)", padding: "10px", borderRadius: "6px", whiteSpace: "pre-wrap" } },
            "Profile P", profile.id, " - ", profile.name, "\n",
            "Required: ", stats.required, "/", stats.total, " completed\n",
            stats.routineTotal > 0 ? "Routine: " + stats.routine + "/" + stats.routineTotal + " completed\n" : "",
            proficiencyState.notes ? "Notes: " + proficiencyState.notes : ""
          )
        )
      );
    };

    const renderReferenceTab = () => {
      const refSections = [
        { id: "radioFrequencies", label: "Frequencies" },
        { id: "radioReports", label: "Reports" },
        { id: "callSigns", label: "Call Signs" },
        { id: "searchPatterns", label: "Patterns" },
        { id: "trackSpacing", label: "Spacing" },
        { id: "altitudes", label: "Altitudes" },
        { id: "vfrMinimums", label: "VFR Mins" },
        { id: "phonetic", label: "Phonetic" },
        { id: "eltSearch", label: "ELT Search" },
        { id: "observerDuties", label: "Duties" },
        { id: "sterileCockpit", label: "Sterile" },
        { id: "emergencies", label: "Emergency" },
        { id: "gridSystem", label: "Grid System" },
        { id: "timeConversion", label: "Time Zones" },
        { id: "distressSignals", label: "Signals" },
        { id: "calcPressureAlt", label: "\u{1F4CA} Pressure Alt", isCalc: true },
        { id: "calcDensityAlt", label: "\u{1F321}\uFE0F Density Alt", isCalc: true },
        { id: "calcTAS", label: "\u2708\uFE0F TAS", isCalc: true },
        { id: "calcGroundSpeed", label: "\u{1F680} Ground Speed", isCalc: true },
        { id: "calcETE", label: "\u23F1\uFE0F Time Enroute", isCalc: true },
        { id: "calcDistance", label: "\u{1F4CF} Distance", isCalc: true },
        { id: "calcFuelBurn", label: "\u26FD Fuel Burn", isCalc: true },
        { id: "calcHeadwind", label: "\u{1F32C}\uFE0F Headwind", isCalc: true },
        { id: "calcCrosswind", label: "\u2194\uFE0F Crosswind", isCalc: true },
        { id: "calcWindCorrection", label: "\u{1F9ED} Wind Correction", isCalc: true },
        { id: "calcClimbGradient", label: "\u2197\uFE0F Climb Gradient", isCalc: true },
        { id: "calcDescentRate", label: "\u2B07\uFE0F Descent Rate", isCalc: true },
        { id: "calcTOD", label: "\u{1F3AF} Top of Descent", isCalc: true },
        { id: "calcGlideslope", label: "\u{1F6EC} Glideslope", isCalc: true },
        { id: "calcKnotsToMph", label: "\u{1F504} Knots\u2194MPH", isCalc: true },
        { id: "rhoOverview", label: "\u{1F4E1} Overview", isRhotheta: true },
        { id: "rhoControls", label: "\u{1F39B}\uFE0F Controls", isRhotheta: true },
        { id: "rhoFrequencies", label: "\u{1F4FB} Frequencies", isRhotheta: true },
        { id: "rhoDisplay", label: "\u{1F5A5}\uFE0F Display", isRhotheta: true },
        { id: "rhoSetup406", label: "\u{1F6F0}\uFE0F 406 Setup", isRhotheta: true },
        { id: "rhoSetup121", label: "\u{1F4CD} 121.5 Setup", isRhotheta: true },
        { id: "rhoOperation", label: "\u2708\uFE0F Operation", isRhotheta: true },
        { id: "rhoDecode", label: "\u{1F50D} 406 Decode", isRhotheta: true },
        { id: "rhoRange", label: "\u{1F4CF} Range", isRhotheta: true },
        { id: "rhoTroubleshoot", label: "\u{1F527} Troubleshoot", isRhotheta: true },
        { id: "rhoQuickRef", label: "\u26A1 Quick Ref", isRhotheta: true },
        { id: "g1000Setup", label: "\u{1F5A5}\uFE0F G1000 Setup", isG1000: true },
        { id: "g1000Waypoints", label: "\u{1F4CD} Waypoints", isG1000: true },
        { id: "g1000FlightPlan", label: "\u2708\uFE0F Flight Plans", isG1000: true },
        { id: "g1000SAR", label: "\u{1F50E} SAR Patterns", isG1000: true },
        { id: "g1000Navigation", label: "\u{1F9ED} Navigation", isG1000: true },
        { id: "g1000Marking", label: "\u{1F3AF} Mark Target", isG1000: true },
        { id: "g1000Utilities", label: "\u2699\uFE0F Utilities", isG1000: true },
        { id: "gpsConverter", label: "\u{1F6F0}\uFE0F GPS Converter", isG1000: true }
      ];
      const renderRefContent = () => {
        const data = referenceData[activeRefSection];
        if (!data) return null;
        switch (activeRefSection) {
          case "radioFrequencies":
          case "radioReports":
            return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("table", { style: styles.refTable }, /* @__PURE__ */ React.createElement("thead", null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Item"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Value"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Note"))), /* @__PURE__ */ React.createElement("tbody", null, data.items.map((item, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, item.label), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "600", color: "#68d391" } }, item.value), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontSize: "11px", color: "#a0aec0" } }, item.note))))));
          case "callSigns":
          case "sterileCockpit":
          case "gridSystem":
            return /* @__PURE__ */ React.createElement("div", { style: styles.pre }, data.content);
          case "densityAltitude":
            return /* @__PURE__ */ React.createElement(DensityAltitudeCalculator, null);
          case "searchPatterns":
            return /* @__PURE__ */ React.createElement("div", null, data.patterns.map((pattern, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "16px" } }, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "700", color: "#f6e05e", marginBottom: "8px", fontSize: "14px" } }, pattern.name), /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "8px" } }, /* @__PURE__ */ React.createElement("span", { style: styles.label }, "Use:"), " ", /* @__PURE__ */ React.createElement("span", { style: { color: "#e2e8f0" } }, pattern.use)), /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "8px" } }, /* @__PURE__ */ React.createElement("span", { style: styles.label }, "Altitude:"), " ", /* @__PURE__ */ React.createElement("span", { style: { color: "#68d391" } }, pattern.altitude)), /* @__PURE__ */ React.createElement("div", { style: { marginBottom: "8px" } }, /* @__PURE__ */ React.createElement("span", { style: styles.label }, "Method:"), " ", /* @__PURE__ */ React.createElement("span", { style: { color: "#e2e8f0" } }, pattern.method)), /* @__PURE__ */ React.createElement("pre", { style: { ...styles.pre, fontSize: "10px", color: "#68d391" } }, pattern.diagram))));
          case "trackSpacing":
            return /* @__PURE__ */ React.createElement("table", { style: styles.refTable }, /* @__PURE__ */ React.createElement("thead", null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Terrain"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Visibility"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Spacing"))), /* @__PURE__ */ React.createElement("tbody", null, data.items.map((item, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, item.terrain), /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, item.visibility), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "600", color: "#68d391" } }, item.spacing)))));
          case "altitudes":
            return /* @__PURE__ */ React.createElement("table", { style: styles.refTable }, /* @__PURE__ */ React.createElement("thead", null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Condition"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Altitude"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Notes"))), /* @__PURE__ */ React.createElement("tbody", null, data.items.map((item, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, item.condition), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "600", color: "#68d391" } }, item.altitude), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontSize: "11px", color: "#a0aec0" } }, item.notes)))));
          case "vfrMinimums":
            return /* @__PURE__ */ React.createElement("table", { style: styles.refTable }, /* @__PURE__ */ React.createElement("thead", null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Airspace"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Visibility"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Cloud Clearance"))), /* @__PURE__ */ React.createElement("tbody", null, data.items.map((item, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, item.airspace), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, color: "#68d391" } }, item.visibility), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontSize: "11px" } }, item.cloudClearance)))));
          case "phonetic":
            return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "8px" } }, "Alphabet"), /* @__PURE__ */ React.createElement("table", { style: { ...styles.refTable, marginBottom: "16px" } }, /* @__PURE__ */ React.createElement("tbody", null, data.alphabet.map((row, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "700", color: "#68d391" } }, row[0]), /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, row[1]), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "700", color: "#68d391" } }, row[2]), /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, row[3]))))), /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "8px" } }, "Numbers"), /* @__PURE__ */ React.createElement("table", { style: styles.refTable }, /* @__PURE__ */ React.createElement("tbody", null, data.numbers.map((row, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "700", color: "#68d391" } }, row[0]), /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, row[1]), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "700", color: "#68d391" } }, row[2]), /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, row[3]))))));
          case "eltSearch":
            return /* @__PURE__ */ React.createElement("div", null, data.methods.map((method, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "12px" } }, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "700", color: "#f6e05e", marginBottom: "4px" } }, method.name), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginBottom: "8px" } }, method.description), /* @__PURE__ */ React.createElement("ol", { style: { margin: 0, paddingLeft: "20px", fontSize: "12px" } }, method.steps.map((step, j) => /* @__PURE__ */ React.createElement("li", { key: j, style: { marginBottom: "4px" } }, step))))), /* @__PURE__ */ React.createElement("div", { style: { ...styles.refCard, background: "rgba(221,107,32,0.1)", borderColor: "rgba(221,107,32,0.3)" } }, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "8px" } }, "Tips"), /* @__PURE__ */ React.createElement("ul", { style: { margin: 0, paddingLeft: "20px", fontSize: "12px" } }, data.tips.map((tip, i) => /* @__PURE__ */ React.createElement("li", { key: i, style: { marginBottom: "4px" } }, tip)))));
          case "rhoOverview":
            return React.createElement("div", null,
              React.createElement("div", { style: { ...styles.refCard, marginBottom: "12px", background: "rgba(246,224,94,0.1)", borderColor: "rgba(246,224,94,0.3)" } },
                React.createElement("div", { style: { fontSize: ts(13), color: "#e2e8f0", lineHeight: "1.6" } }, data.description)
              ),
              React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "8px", fontSize: ts(13) } }, "System Components"),
              React.createElement("table", { style: styles.refTable },
                React.createElement("thead", null,
                  React.createElement("tr", null,
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(12) } }, "Component"),
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(12) } }, "Location")
                  )
                ),
                React.createElement("tbody", null,
                  data.components.map((c, i) => 
                    React.createElement("tr", { key: i },
                      React.createElement("td", { style: { ...styles.refTd, fontWeight: "600", color: "#68d391", fontSize: ts(12) } }, c.name),
                      React.createElement("td", { style: { ...styles.refTd, fontSize: ts(12) } }, c.location)
                    )
                  )
                )
              )
            );
          case "rhoControls":
            return React.createElement("div", null,
              React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "10px", fontSize: ts(14) } }, "\u{1F39B}\uFE0F Knobs"),
              data.knobs.map((k, i) =>
                React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "8px", padding: "10px" } },
                  React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "4px" } },
                    React.createElement("span", { style: { fontWeight: "700", color: "#68d391", fontSize: ts(13) } }, k.name),
                    React.createElement("span", { style: { fontSize: ts(11), color: "#a0aec0", background: "rgba(0,0,0,0.3)", padding: "2px 8px", borderRadius: "4px" } }, k.location)
                  ),
                  React.createElement("div", { style: { fontSize: ts(12), color: "#e2e8f0" } }, k.function)
                )
              ),
              React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "10px", marginTop: "16px", fontSize: ts(14) } }, "\u{1F518} Buttons"),
              data.buttons.map((b, i) =>
                React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "8px", padding: "10px" } },
                  React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "4px" } },
                    React.createElement("span", { style: { fontWeight: "700", color: "#63b3ed", fontSize: ts(13) } }, b.name),
                    React.createElement("span", { style: { fontSize: ts(11), color: "#a0aec0", background: "rgba(0,0,0,0.3)", padding: "2px 8px", borderRadius: "4px" } }, b.location)
                  ),
                  React.createElement("div", { style: { fontSize: ts(12), color: "#e2e8f0" } }, b.function)
                )
              )
            );
          case "rhoFrequencies":
            return React.createElement("div", null,
              React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "10px", fontSize: ts(14) } }, "Frequency Bands"),
              React.createElement("table", { style: { ...styles.refTable, marginBottom: "16px" } },
                React.createElement("thead", null,
                  React.createElement("tr", null,
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11) } }, "Range"),
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11) } }, "Step"),
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11) } }, "Use")
                  )
                ),
                React.createElement("tbody", null,
                  data.bands.map((b, i) =>
                    React.createElement("tr", { key: i },
                      React.createElement("td", { style: { ...styles.refTd, fontFamily: "monospace", color: "#68d391", fontSize: ts(11) } }, b.range),
                      React.createElement("td", { style: { ...styles.refTd, fontSize: ts(11) } }, b.step),
                      React.createElement("td", { style: { ...styles.refTd, fontSize: ts(11) } }, b.use)
                    )
                  )
                )
              ),
              React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "10px", fontSize: ts(14) } }, "Common Frequencies"),
              React.createElement("table", { style: styles.refTable },
                React.createElement("thead", null,
                  React.createElement("tr", null,
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11) } }, "Frequency"),
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11) } }, "Name"),
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11) } }, "Notes")
                  )
                ),
                React.createElement("tbody", null,
                  data.common.map((f, i) =>
                    React.createElement("tr", { key: i },
                      React.createElement("td", { style: { ...styles.refTd, fontFamily: "monospace", fontWeight: "700", color: "#fc8181", fontSize: ts(12) } }, f.freq),
                      React.createElement("td", { style: { ...styles.refTd, fontWeight: "600", fontSize: ts(11) } }, f.name),
                      React.createElement("td", { style: { ...styles.refTd, color: "#a0aec0", fontSize: ts(11) } }, f.notes)
                    )
                  )
                )
              )
            );
          case "rhoDisplay":
            return React.createElement("div", null,
              data.elements.map((e, i) =>
                React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "8px", padding: "10px" } },
                  React.createElement("div", { style: { fontWeight: "700", color: "#68d391", marginBottom: "4px", fontSize: ts(13) } }, e.name),
                  React.createElement("div", { style: { fontSize: ts(12), color: "#e2e8f0" } }, e.description)
                )
              )
            );
          case "rhoSetup406":
            const formatRhoStep406 = (step) => step.replace(/\b(PAGE|SQL|FREQ|ON\/OFF|CLR|STORE|REP|DIM|MEM|DF)\b/g, '<span style="display:inline-block;padding:1px 6px;background:linear-gradient(180deg, #4a5568, #2d3748);border-radius:3px;font-family:monospace;font-weight:700;color:#f6e05e;border:1px solid #718096;margin:0 2px;font-size:11px">$1</span>');
            return React.createElement("div", null,
              React.createElement("ol", { style: { margin: 0, paddingLeft: "24px", fontSize: ts(13), lineHeight: "2.0" } },
                data.steps.map((step, i) =>
                  React.createElement("li", { key: i, style: { marginBottom: "8px", color: "#e2e8f0" } },
                    React.createElement("span", { dangerouslySetInnerHTML: { __html: formatRhoStep406(step) } })
                  )
                )
              ),
              React.createElement("div", { style: { ...styles.refCard, marginTop: "12px", background: "rgba(104,211,145,0.1)", borderColor: "rgba(104,211,145,0.3)" } },
                React.createElement("div", { style: { fontSize: ts(12), color: "#68d391" } }, "\u{1F4A1} ", data.notes)
              )
            );
          case "rhoSetup121":
            const formatRhoStep121 = (step) => step.replace(/\b(PAGE|SQL|FREQ|ON\/OFF|CLR|STORE|REP|DIM|MEM|DF|AUX|MHz|kHz)\b/g, '<span style="display:inline-block;padding:1px 6px;background:linear-gradient(180deg, #4a5568, #2d3748);border-radius:3px;font-family:monospace;font-weight:700;color:#f6e05e;border:1px solid #718096;margin:0 2px;font-size:11px">$1</span>');
            return React.createElement("div", null,
              React.createElement("ol", { style: { margin: 0, paddingLeft: "24px", fontSize: ts(13), lineHeight: "2.0" } },
                data.steps.map((step, i) =>
                  React.createElement("li", { key: i, style: { marginBottom: "8px", color: "#e2e8f0" } },
                    React.createElement("span", { dangerouslySetInnerHTML: { __html: formatRhoStep121(step) } })
                  )
                )
              ),
              React.createElement("div", { style: { ...styles.refCard, marginTop: "12px", background: "rgba(104,211,145,0.1)", borderColor: "rgba(104,211,145,0.3)" } },
                React.createElement("div", { style: { fontSize: ts(12), color: "#68d391" } }, "\u{1F4A1} ", data.notes)
              )
            );
          case "rhoOperation":
            const formatRhoOp = (step) => {
              let s = step.replace(/\b(STORE|F2|CLR|F1)\b/g, '<span style="display:inline-block;padding:1px 6px;background:linear-gradient(180deg, #4a5568, #2d3748);border-radius:3px;font-family:monospace;font-weight:700;color:#f6e05e;border:1px solid #718096;margin:0 2px;font-size:11px">$1</span>');
              s = s.replace(/(\d+,?\d*' AGL|12 o'clock|180\u00b0)/g, '<span style="color:#fc8181;font-weight:600">$1</span>');
              s = s.replace(/(121\.5|406)/g, '<span style="color:#68d391;font-weight:600">$1</span>');
              return s;
            };
            return React.createElement("div", null,
              React.createElement("ol", { style: { margin: 0, paddingLeft: "24px", fontSize: ts(13), lineHeight: "1.9" } },
                data.procedure.map((step, i) =>
                  React.createElement("li", { key: i, style: { marginBottom: "10px", color: "#e2e8f0" } },
                    React.createElement("span", { dangerouslySetInnerHTML: { __html: formatRhoOp(step) } })
                  )
                )
              )
            );
          case "rhoDecode":
            const formatRhoDec = (step) => step.replace(/\b(CLR|F1|DECODE|EXIT)\b/g, '<span style="display:inline-block;padding:1px 6px;background:linear-gradient(180deg, #4a5568, #2d3748);border-radius:3px;font-family:monospace;font-weight:700;color:#f6e05e;border:1px solid #718096;margin:0 2px;font-size:11px">$1</span>');
            return React.createElement("div", null,
              React.createElement("ol", { style: { margin: 0, paddingLeft: "24px", fontSize: ts(13), lineHeight: "1.9" } },
                data.steps.map((step, i) =>
                  React.createElement("li", { key: i, style: { marginBottom: "6px", color: "#e2e8f0" } },
                    React.createElement("span", { dangerouslySetInnerHTML: { __html: formatRhoDec(step) } })
                  )
                )
              ),
              React.createElement("div", { style: { ...styles.refCard, marginTop: "12px", background: "rgba(104,211,145,0.1)", borderColor: "rgba(104,211,145,0.3)" } },
                React.createElement("div", { style: { fontSize: ts(12), color: "#68d391" } }, "\u{1F4A1} ", data.notes)
              )
            );
          case "rhoRange":
            return React.createElement("div", null,
              React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "10px", fontSize: ts(14) } }, "Detection Ranges (Flat Terrain)"),
              React.createElement("table", { style: styles.refTable },
                React.createElement("thead", null,
                  React.createElement("tr", null,
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11) } }, "Altitude"),
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11), color: "#f6e05e" } }, "406 MHz"),
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11), color: "#63b3ed" } }, "121.5 MHz")
                  )
                ),
                React.createElement("tbody", null,
                  data.ranges.map((r, i) =>
                    React.createElement("tr", { key: i, style: { background: r.recommended ? "rgba(104,211,145,0.15)" : "transparent" } },
                      React.createElement("td", { style: { ...styles.refTd, fontWeight: "600", fontSize: ts(12) } }, r.altitude, r.recommended ? " \u2605" : ""),
                      React.createElement("td", { style: { ...styles.refTd, color: "#f6e05e", fontWeight: "600", fontSize: ts(12) } }, r.range406),
                      React.createElement("td", { style: { ...styles.refTd, color: "#63b3ed", fontSize: ts(12) } }, r.range121)
                    )
                  )
                )
              ),
              React.createElement("div", { style: { ...styles.refCard, marginTop: "12px", background: "rgba(221,107,32,0.1)", borderColor: "rgba(221,107,32,0.3)" } },
                React.createElement("div", { style: { fontSize: ts(11), color: "#ed8936" } }, "\u26A0\uFE0F ", data.notes)
              ),
              React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "10px", marginTop: "16px", fontSize: ts(14) } }, "Signal Characteristics"),
              data.signalTypes.map((t, i) =>
                React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "8px", padding: "10px" } },
                  React.createElement("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "4px" } },
                    React.createElement("span", { style: { fontWeight: "700", color: "#68d391", fontSize: ts(12) } }, t.type),
                    React.createElement("span", { style: { fontSize: ts(11), color: "#fc8181", fontWeight: "600" } }, t.power)
                  ),
                  React.createElement("div", { style: { fontSize: ts(11), color: "#a0aec0" } }, t.pattern)
                )
              )
            );
          case "rhoTroubleshoot":
            return React.createElement("div", null,
              data.issues.map((issue, i) =>
                React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "10px", padding: "12px" } },
                  React.createElement("div", { style: { fontWeight: "700", color: "#fc8181", marginBottom: "8px", fontSize: ts(13) } }, "\u26A0\uFE0F ", issue.problem),
                  React.createElement("ul", { style: { margin: 0, paddingLeft: "20px", fontSize: ts(12) } },
                    issue.solutions.map((s, j) =>
                      React.createElement("li", { key: j, style: { marginBottom: "4px", color: "#68d391" } }, s)
                    )
                  )
                )
              )
            );
          case "rhoQuickRef":
            const formatRhoQR = (keys) => keys.replace(/\b(PAGE|SQL|FREQ|ON\/OFF|CLR|STORE|REP|DIM|MEM|DF|F1|F2)\b/g, '<span style="display:inline-block;padding:1px 5px;background:linear-gradient(180deg, #4a5568, #2d3748);border-radius:3px;font-family:monospace;font-weight:700;color:#f6e05e;border:1px solid #718096;margin:0 1px;font-size:10px">$1</span>');
            return React.createElement("div", null,
              React.createElement("table", { style: styles.refTable },
                React.createElement("thead", null,
                  React.createElement("tr", null,
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11) } }, "Action"),
                    React.createElement("th", { style: { ...styles.refTh, fontSize: ts(11) } }, "Button/Knob")
                  )
                ),
                React.createElement("tbody", null,
                  data.items.map((item, i) =>
                    React.createElement("tr", { key: i },
                      React.createElement("td", { style: { ...styles.refTd, fontWeight: "600", fontSize: ts(12) } }, item.action),
                      React.createElement("td", { style: { ...styles.refTd, fontSize: ts(12) } },
                        React.createElement("span", { dangerouslySetInnerHTML: { __html: formatRhoQR(item.keys) } })
                      )
                    )
                  )
                )
              )
            );
          // AVIATION CALCULATOR CASES
          case "calcPressureAlt":
            const calcPA = () => {
              const fe = parseFloat(calcState.paFieldElev);
              const alt = parseFloat(calcState.paAltSetting);
              if (!isNaN(fe) && !isNaN(alt)) {
                const pa = Math.round((29.92 - alt) * 1000 + fe);
                updateCalc('paResult', pa);
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "PA = (29.92 - Altimeter Setting)  1,000 + Field Elevation"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Field Elevation (ft MSL)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.paFieldElev, onChange: (e) => updateCalc('paFieldElev', e.target.value), placeholder: "e.g., 5000", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Altimeter Setting (inHg)"),
                React.createElement("input", { type: "number", inputMode: "decimal", step: "0.01", value: calcState.paAltSetting, onChange: (e) => updateCalc('paAltSetting', e.target.value), placeholder: "e.g., 29.92", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcPA, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE PRESSURE ALTITUDE"),
              calcState.paResult !== null && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Pressure Altitude"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.paResult.toLocaleString(), " ft")
              ),
              React.createElement("div", { style: { marginTop: "16px", padding: "12px", background: "rgba(246,224,94,0.1)", borderRadius: "8px", fontSize: ts(11), color: "#f6e05e" } }, 
                " Tip: Set altimeter to 29.92 to read PA directly on your altimeter"
              )
            );
          case "calcDensityAlt":
            const calcDA = () => {
              const pa = parseFloat(calcState.daFieldElev);
              const oat = parseFloat(calcState.daOAT);
              if (!isNaN(pa) && !isNaN(oat)) {
                const isa = 15 - (pa / 1000) * 2;
                const da = Math.round(pa + (120 * (oat - isa)));
                updateCalc('daResult', { da, isa: isa.toFixed(1), diff: (oat - isa).toFixed(1) });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "DA = PA + [120  (OAT - Standard Temp)]"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Pressure Altitude (ft)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.daFieldElev, onChange: (e) => updateCalc('daFieldElev', e.target.value), placeholder: "Enter pressure altitude", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Outside Air Temp (C)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.daOAT, onChange: (e) => updateCalc('daOAT', e.target.value), placeholder: "Enter OAT", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcDA, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE DENSITY ALTITUDE"),
              calcState.daResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Density Altitude"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: calcState.daResult.da > parseFloat(calcState.daFieldElev) + 2000 ? "#fc8181" : "#68d391" } }, calcState.daResult.da.toLocaleString(), " ft"),
                React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginTop: "8px" } }, "ISA at this altitude: ", calcState.daResult.isa, "C | Deviation: ", calcState.daResult.diff, "C")
              )
            );
          case "calcTAS":
            const calcTAS = () => {
              const ias = parseFloat(calcState.tasIAS);
              const alt = parseFloat(calcState.tasAlt);
              if (ias > 0 && alt >= 0) {
                const tas = Math.round(ias + (ias * 0.02 * (alt / 1000)));
                updateCalc('tasResult', tas);
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "TAS = IAS + (IAS  2% per 1,000 ft PA)"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Indicated Airspeed (kts)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.tasIAS, onChange: (e) => updateCalc('tasIAS', e.target.value), placeholder: "Enter IAS", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Pressure Altitude (ft)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.tasAlt, onChange: (e) => updateCalc('tasAlt', e.target.value), placeholder: "Enter altitude", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcTAS, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE TAS"),
              calcState.tasResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "True Airspeed"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.tasResult, " kts")
              )
            );
          case "calcGroundSpeed":
            const calcGS = () => {
              const dist = parseFloat(calcState.gsDistance);
              const time = parseFloat(calcState.gsTime);
              if (dist > 0 && time > 0) {
                const gs = Math.round((dist / time) * 60);
                updateCalc('gsResult', gs);
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "Ground Speed = (Distance  Time)  60"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Distance (NM)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.gsDistance, onChange: (e) => updateCalc('gsDistance', e.target.value), placeholder: "Enter distance", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Time (minutes)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.gsTime, onChange: (e) => updateCalc('gsTime', e.target.value), placeholder: "Enter time", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcGS, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE GROUND SPEED"),
              calcState.gsResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Ground Speed"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.gsResult, " kts")
              )
            );
          case "calcETE":
            const calcETE = () => {
              const dist = parseFloat(calcState.eteDistance);
              const gs = parseFloat(calcState.eteGs);
              if (dist > 0 && gs > 0) {
                const timeHrs = dist / gs;
                const hrs = Math.floor(timeHrs);
                const mins = Math.round((timeHrs - hrs) * 60);
                updateCalc('eteResult', { hrs, mins, total: Math.round(timeHrs * 60) });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "ETE = Distance  Ground Speed"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Distance (NM)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.eteDistance, onChange: (e) => updateCalc('eteDistance', e.target.value), placeholder: "Enter distance", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Ground Speed (kts)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.eteGs, onChange: (e) => updateCalc('eteGs', e.target.value), placeholder: "Enter ground speed", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcETE, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE TIME ENROUTE"),
              calcState.eteResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Estimated Time Enroute"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.eteResult.hrs, ":", calcState.eteResult.mins.toString().padStart(2, '0')),
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginTop: "4px" } }, "(", calcState.eteResult.total, " minutes)")
              )
            );
          case "calcDistance":
            const calcDist = () => {
              const gs = parseFloat(calcState.distGs);
              const time = parseFloat(calcState.distTime);
              if (gs > 0 && time > 0) {
                const dist = (gs * time / 60).toFixed(1);
                updateCalc('distResult', dist);
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "Distance = Ground Speed  (Time  60)"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Ground Speed (kts)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.distGs, onChange: (e) => updateCalc('distGs', e.target.value), placeholder: "Enter ground speed", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Time (minutes)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.distTime, onChange: (e) => updateCalc('distTime', e.target.value), placeholder: "Enter time", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcDist, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE DISTANCE"),
              calcState.distResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Distance"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.distResult, " NM")
              )
            );
          case "calcFuelBurn":
            const calcFuel = () => {
              const time = parseFloat(calcState.fuelTime);
              const gph = parseFloat(calcState.fuelGph);
              if (time > 0 && gph > 0) {
                const fuel = ((time / 60) * gph).toFixed(1);
                updateCalc('fuelResult', fuel);
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "Fuel = (Time  60)  GPH"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Flight Time (minutes)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.fuelTime, onChange: (e) => updateCalc('fuelTime', e.target.value), placeholder: "Enter time", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Fuel Burn Rate (GPH)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.fuelGph, onChange: (e) => updateCalc('fuelGph', e.target.value), placeholder: "Enter GPH", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcFuel, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE FUEL REQUIRED"),
              calcState.fuelResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Fuel Required"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.fuelResult, " gal")
              )
            );
          case "calcHeadwind":
            const calcHW = () => {
              const ws = parseFloat(calcState.hwWindSpeed);
              const wd = parseFloat(calcState.hwWindDir);
              const rwy = parseFloat(calcState.hwRunway) * 10;
              if (ws > 0 && !isNaN(wd) && !isNaN(rwy)) {
                const angle = (wd - rwy) * (Math.PI / 180);
                const hw = ws * Math.cos(angle);
                updateCalc('hwResult', { value: Math.abs(hw).toFixed(0), type: hw >= 0 ? "Headwind" : "Tailwind" });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "Headwind = Wind Speed  cos(Wind Angle)"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Wind Speed (kts)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.hwWindSpeed, onChange: (e) => updateCalc('hwWindSpeed', e.target.value), placeholder: "Enter wind speed", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Wind Direction ()"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.hwWindDir, onChange: (e) => updateCalc('hwWindDir', e.target.value), placeholder: "e.g., 270", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Runway (e.g., 27 for Rwy 27)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.hwRunway, onChange: (e) => updateCalc('hwRunway', e.target.value), placeholder: "Enter runway number", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcHW, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE HEADWIND"),
              calcState.hwResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, calcState.hwResult.type),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: calcState.hwResult.type === "Headwind" ? "#68d391" : "#fc8181" } }, calcState.hwResult.value, " kts")
              )
            );
          case "calcCrosswind":
            const calcXW = () => {
              const ws = parseFloat(calcState.xwWindSpeed);
              const wd = parseFloat(calcState.xwWindDir);
              const rwy = parseFloat(calcState.xwRunway) * 10;
              if (ws > 0 && !isNaN(wd) && !isNaN(rwy)) {
                const angle = (wd - rwy) * (Math.PI / 180);
                const xw = ws * Math.sin(angle);
                updateCalc('xwResult', { value: Math.abs(xw).toFixed(0), dir: xw > 0 ? "from Right" : "from Left" });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "Crosswind = Wind Speed  sin(Wind Angle)"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Wind Speed (kts)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.xwWindSpeed, onChange: (e) => updateCalc('xwWindSpeed', e.target.value), placeholder: "Enter wind speed", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Wind Direction ()"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.xwWindDir, onChange: (e) => updateCalc('xwWindDir', e.target.value), placeholder: "e.g., 270", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Runway (e.g., 27 for Rwy 27)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.xwRunway, onChange: (e) => updateCalc('xwRunway', e.target.value), placeholder: "Enter runway number", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcXW, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE CROSSWIND"),
              calcState.xwResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Crosswind ", calcState.xwResult.dir),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#f6e05e" } }, calcState.xwResult.value, " kts")
              )
            );
          case "calcWindCorrection":
            const calcWCA = () => {
              const tas = parseFloat(calcState.wcaTAS);
              const ws = parseFloat(calcState.wcaWindSpeed);
              const course = parseFloat(calcState.wcaCourse);
              const wd = parseFloat(calcState.wcaWindDir);
              if (tas > 0 && ws >= 0 && !isNaN(course) && !isNaN(wd)) {
                const windAngle = (wd - course) * (Math.PI / 180);
                const sinWCA = (ws * Math.sin(windAngle)) / tas;
                const wca = Math.asin(Math.max(-1, Math.min(1, sinWCA))) * (180 / Math.PI);
                const heading = (course - wca + 360) % 360;
                const gs = Math.round(tas * Math.cos(wca * Math.PI / 180) - ws * Math.cos(windAngle));
                updateCalc('wcaResult', { wca: Math.abs(wca).toFixed(0), dir: wca > 0 ? "Left" : "Right", heading: Math.round(heading), gs: Math.abs(gs) });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(11), color: "#a0aec0" } }, 
                "WCA = arcsin((Wind  sin(Angle))  TAS)"
              ),
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", marginBottom: "16px" } },
                React.createElement("div", null,
                  React.createElement("label", { style: { display: "block", marginBottom: "6px", fontSize: ts(13), fontWeight: "600", color: "#e2e8f0" } }, "TAS (kts)"),
                  React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.wcaTAS, onChange: (e) => updateCalc('wcaTAS', e.target.value), placeholder: "TAS", style: { width: "100%", padding: "14px", fontSize: "20px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { display: "block", marginBottom: "6px", fontSize: ts(13), fontWeight: "600", color: "#e2e8f0" } }, "Course ()"),
                  React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.wcaCourse, onChange: (e) => updateCalc('wcaCourse', e.target.value), placeholder: "Course", style: { width: "100%", padding: "14px", fontSize: "20px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { display: "block", marginBottom: "6px", fontSize: ts(13), fontWeight: "600", color: "#e2e8f0" } }, "Wind (kts)"),
                  React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.wcaWindSpeed, onChange: (e) => updateCalc('wcaWindSpeed', e.target.value), placeholder: "Wind", style: { width: "100%", padding: "14px", fontSize: "20px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
                ),
                React.createElement("div", null,
                  React.createElement("label", { style: { display: "block", marginBottom: "6px", fontSize: ts(13), fontWeight: "600", color: "#e2e8f0" } }, "Wind From ()"),
                  React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.wcaWindDir, onChange: (e) => updateCalc('wcaWindDir', e.target.value), placeholder: "From", style: { width: "100%", padding: "14px", fontSize: "20px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
                )
              ),
              React.createElement("button", { onClick: calcWCA, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE WIND CORRECTION"),
              calcState.wcaResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: "12px" } },
                  React.createElement("div", null,
                    React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0" } }, "WCA (", calcState.wcaResult.dir, ")"),
                    React.createElement("div", { style: { fontSize: "28px", fontWeight: "700", color: "#f6e05e" } }, calcState.wcaResult.wca, "")
                  ),
                  React.createElement("div", null,
                    React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0" } }, "Heading"),
                    React.createElement("div", { style: { fontSize: "28px", fontWeight: "700", color: "#68d391" } }, calcState.wcaResult.heading, "")
                  ),
                  React.createElement("div", null,
                    React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0" } }, "Ground Speed"),
                    React.createElement("div", { style: { fontSize: "28px", fontWeight: "700", color: "#63b3ed" } }, calcState.wcaResult.gs, " kts")
                  )
                )
              )
            );
          case "calcClimbGradient":
            const calcCG = () => {
              const ftNm = parseFloat(calcState.cgFtPerNm);
              const gs = parseFloat(calcState.cgGs);
              if (ftNm > 0 && gs > 0) {
                const nmPerMin = gs / 60;
                const fpm = Math.round(ftNm * nmPerMin);
                updateCalc('cgResult', { fpm, nmPerMin: nmPerMin.toFixed(2) });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "FPM = (ft/NM requirement)  (GS  60)"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Required Climb (ft/NM)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.cgFtPerNm, onChange: (e) => updateCalc('cgFtPerNm', e.target.value), placeholder: "e.g., 300", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Ground Speed (kts)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.cgGs, onChange: (e) => updateCalc('cgGs', e.target.value), placeholder: "Enter ground speed", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcCG, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE CLIMB RATE"),
              calcState.cgResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Required Climb Rate"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.cgResult.fpm.toLocaleString(), " FPM"),
                React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginTop: "8px" } }, "At ", calcState.cgResult.nmPerMin, " NM/min")
              )
            );
          case "calcDescentRate":
            const calcDR = () => {
              const altLose = parseFloat(calcState.drAltLose);
              const dist = parseFloat(calcState.drDistance);
              const gs = parseFloat(calcState.drGs);
              if (altLose > 0 && dist > 0 && gs > 0) {
                const ftPerNm = altLose / dist;
                const nmPerMin = gs / 60;
                const fpm = Math.round(ftPerNm * nmPerMin);
                updateCalc('drResult', { fpm, ftPerNm: Math.round(ftPerNm), nmPerMin: nmPerMin.toFixed(2) });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "FPM = (Alt  Dist)  (GS  60)"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Altitude to Lose (ft)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.drAltLose, onChange: (e) => updateCalc('drAltLose', e.target.value), placeholder: "e.g., 6000", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Distance to Descend (NM)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.drDistance, onChange: (e) => updateCalc('drDistance', e.target.value), placeholder: "e.g., 20", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Ground Speed (kts)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.drGs, onChange: (e) => updateCalc('drGs', e.target.value), placeholder: "Enter ground speed", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcDR, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE DESCENT RATE"),
              calcState.drResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Required Descent Rate"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.drResult.fpm.toLocaleString(), " FPM"),
                React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginTop: "8px" } }, calcState.drResult.ftPerNm, " ft/NM at ", calcState.drResult.nmPerMin, " NM/min")
              )
            );
          case "calcTOD":
            const calcTOD = () => {
              const current = parseFloat(calcState.todCurrentAlt);
              const target = parseFloat(calcState.todTargetAlt);
              if (current > target) {
                const altLose = (current - target) / 1000;
                const todNm = Math.round(altLose * 3);
                const todWithBuffer = todNm + 3;
                updateCalc('todResult', { todNm, todWithBuffer, altLose: Math.round(altLose * 1000) });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "TOD = (Alt to lose in 1000s)  3 NM"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Current Altitude (ft)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.todCurrentAlt, onChange: (e) => updateCalc('todCurrentAlt', e.target.value), placeholder: "e.g., 9000", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Target Altitude (ft)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.todTargetAlt, onChange: (e) => updateCalc('todTargetAlt', e.target.value), placeholder: "e.g., 1000", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcTOD, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE TOP OF DESCENT"),
              calcState.todResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "Begin Descent"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.todResult.todNm, " NM out"),
                React.createElement("div", { style: { fontSize: "16px", color: "#f6e05e", marginTop: "8px", fontWeight: "600" } }, "With 3 NM buffer: ", calcState.todResult.todWithBuffer, " NM"),
                React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginTop: "4px" } }, "Descending ", calcState.todResult.altLose.toLocaleString(), " ft at 3 angle")
              ),
              React.createElement("div", { style: { marginTop: "12px", padding: "12px", background: "rgba(246,224,94,0.1)", borderRadius: "8px", fontSize: ts(11), color: "#f6e05e" } }, 
                " Tip: Add 3 NM to arrive level before your target (e.g., traffic pattern)"
              )
            );
          case "calcGlideslope":
            const calcGLS = () => {
              const gs = parseFloat(calcState.glsGs);
              if (gs > 0) {
                const fpm = Math.round((gs * 10) / 2);
                const fpmAlt = Math.round(gs * 5);
                updateCalc('glsResult', { fpm, fpmAlt });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "3 Glideslope FPM = (GS  10)  2  OR  GS  5"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Ground Speed (kts)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.glsGs, onChange: (e) => updateCalc('glsGs', e.target.value), placeholder: "Enter ground speed", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcGLS, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CALCULATE GLIDESLOPE RATE"),
              calcState.glsResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { fontSize: "14px", color: "#a0aec0", marginBottom: "4px" } }, "3 Glideslope Descent Rate"),
                React.createElement("div", { style: { fontSize: "40px", fontWeight: "700", color: "#68d391" } }, calcState.glsResult.fpm, " FPM")
              ),
              React.createElement("div", { style: { marginTop: "12px", padding: "12px", background: "rgba(246,224,94,0.1)", borderRadius: "8px", fontSize: ts(11), color: "#f6e05e" } }, 
                " Quick mental math: GS  5 = FPM for 3 glideslope"
              )
            );
          case "calcKnotsToMph":
            const calcKM = () => {
              const kts = parseFloat(calcState.ktsMph);
              if (kts > 0) {
                const mph = (kts * 1.15).toFixed(1);
                const ktsFromMph = (kts / 1.15).toFixed(1);
                updateCalc('ktsMphResult', { mph, ktsFromMph });
              }
            };
            return React.createElement("div", null,
              React.createElement("div", { style: { padding: "12px", background: "rgba(99,179,237,0.1)", borderRadius: "8px", marginBottom: "16px", fontSize: ts(12), color: "#a0aec0" } }, 
                "MPH = Knots  1.15  |  Knots = MPH  1.15"
              ),
              React.createElement("div", { style: { marginBottom: "16px" } },
                React.createElement("label", { style: { display: "block", marginBottom: "8px", fontSize: ts(14), fontWeight: "600", color: "#e2e8f0" } }, "Enter Speed (Knots OR MPH)"),
                React.createElement("input", { type: "number", inputMode: "decimal", value: calcState.ktsMph, onChange: (e) => updateCalc('ktsMph', e.target.value), placeholder: "Enter speed", style: { width: "100%", padding: "16px", fontSize: "22px", fontWeight: "700", background: "rgba(0,0,0,0.4)", border: "2px solid rgba(99,179,237,0.4)", borderRadius: "8px", color: "#fff", textAlign: "center" } })
              ),
              React.createElement("button", { onClick: calcKM, style: { width: "100%", padding: "20px", fontSize: "18px", fontWeight: "700", background: "linear-gradient(135deg, #38a169, #2f855a)", border: "none", borderRadius: "8px", color: "#fff", cursor: "pointer" } }, "CONVERT"),
              calcState.ktsMphResult && React.createElement("div", { style: { marginTop: "16px", padding: "20px", background: "rgba(104,211,145,0.2)", borderRadius: "8px", border: "2px solid rgba(104,211,145,0.5)", textAlign: "center" } },
                React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "16px" } },
                  React.createElement("div", null,
                    React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginBottom: "4px" } }, "If input is Knots:"),
                    React.createElement("div", { style: { fontSize: "32px", fontWeight: "700", color: "#68d391" } }, calcState.ktsMphResult.mph, " MPH")
                  ),
                  React.createElement("div", null,
                    React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginBottom: "4px" } }, "If input is MPH:"),
                    React.createElement("div", { style: { fontSize: "32px", fontWeight: "700", color: "#63b3ed" } }, calcState.ktsMphResult.ktsFromMph, " kts")
                  )
                )
              )
            );
          case "observerDuties":
            return /* @__PURE__ */ React.createElement("div", null, data.phases.map((phase, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "12px" } }, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "700", color: "#f6e05e", marginBottom: "8px" } }, phase.phase), /* @__PURE__ */ React.createElement("ul", { style: { margin: 0, paddingLeft: "20px", fontSize: "12px" } }, phase.duties.map((duty, j) => /* @__PURE__ */ React.createElement("li", { key: j, style: { marginBottom: "4px" } }, duty))))));
          case "emergencies":
            return /* @__PURE__ */ React.createElement("div", null, data.procedures.map((proc, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "12px" } }, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "700", color: "#c53030", marginBottom: "8px" } }, proc.type), /* @__PURE__ */ React.createElement("ol", { style: { margin: 0, paddingLeft: "20px", fontSize: "12px" } }, proc.steps.map((step, j) => /* @__PURE__ */ React.createElement("li", { key: j, style: { marginBottom: "4px" } }, step))))), /* @__PURE__ */ React.createElement("div", { style: { ...styles.refCard, background: "rgba(197,48,48,0.1)", borderColor: "rgba(197,48,48,0.3)" } }, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "600", color: "#fc8181", marginBottom: "8px" } }, "Emergency Squawk Codes"), /* @__PURE__ */ React.createElement("table", { style: styles.refTable }, /* @__PURE__ */ React.createElement("tbody", null, data.squawkCodes.map((item, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "700", color: "#fc8181", fontSize: "16px" } }, item.code), /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, item.meaning)))))));
          case "timeConversion":
            return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("table", { style: styles.refTable }, /* @__PURE__ */ React.createElement("thead", null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Time Zone"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Standard"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Daylight"))), /* @__PURE__ */ React.createElement("tbody", null, data.zones.map((zone, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, zone.zone), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, color: "#68d391" } }, zone.offset), /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, color: "#f6e05e" } }, zone.dst))))), /* @__PURE__ */ React.createElement("div", { style: { ...styles.refCard, marginTop: "12px", background: "rgba(104,211,145,0.1)", borderColor: "rgba(104,211,145,0.3)" } }, /* @__PURE__ */ React.createElement("div", { style: { fontSize: "12px" } }, /* @__PURE__ */ React.createElement("strong", null, "To convert:"), " Add offset to local time = Zulu time"), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginTop: "4px" } }, data.note)));
          case "distressSignals":
            return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "8px" } }, "Ground-to-Air Signals"), /* @__PURE__ */ React.createElement("table", { style: { ...styles.refTable, marginBottom: "16px" } }, /* @__PURE__ */ React.createElement("thead", null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Symbol"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Meaning"))), /* @__PURE__ */ React.createElement("tbody", null, data.ground.map((item, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "700", fontSize: "18px", color: "#fc8181", textAlign: "center" } }, item.symbol), /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, item.meaning))))), /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "600", color: "#f6e05e", marginBottom: "8px" } }, "Air-to-Ground Acknowledgment"), /* @__PURE__ */ React.createElement("table", { style: styles.refTable }, /* @__PURE__ */ React.createElement("thead", null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Action"), /* @__PURE__ */ React.createElement("th", { style: styles.refTh }, "Meaning"))), /* @__PURE__ */ React.createElement("tbody", null, data.air.map((item, i) => /* @__PURE__ */ React.createElement("tr", { key: i }, /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, color: "#68d391" } }, item.action), /* @__PURE__ */ React.createElement("td", { style: styles.refTd }, item.meaning))))));
          case "g1000Setup":
            const g1000SetupTs = g1000RefTextSize || 1;
            return /* @__PURE__ */ React.createElement("div", null, 
              // Text Size Controls
              React.createElement("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "16px", padding: "10px 12px", background: "rgba(0,0,0,0.3)", borderRadius: "8px" } },
                React.createElement("span", { style: { fontSize: "11px", color: "#a0aec0", fontWeight: "600" } }, "TEXT SIZE"),
                React.createElement("div", { style: { display: "flex", gap: "4px" } },
                  [0.85, 1, 1.2, 1.4].map(size => 
                    React.createElement("button", {
                      key: size,
                      style: {
                        width: "36px",
                        height: "36px",
                        background: g1000SetupTs === size ? "rgba(99,179,237,0.3)" : "rgba(255,255,255,0.1)",
                        border: g1000SetupTs === size ? "2px solid #63b3ed" : "1px solid rgba(255,255,255,0.2)",
                        borderRadius: "6px",
                        color: "#fff",
                        fontSize: (12 + (size - 0.85) * 8) + "px",
                        fontWeight: "700",
                        cursor: "pointer"
                      },
                      onClick: () => setG1000RefTextSize(size)
                    }, "A")
                  )
                )
              ),
              /* @__PURE__ */ React.createElement("div", { style: { ...styles.refCard, marginBottom: "16px", background: "linear-gradient(135deg, rgba(49,130,206,0.15), rgba(56,178,172,0.15))", borderColor: "rgba(49,130,206,0.4)" } }, 
                /* @__PURE__ */ React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" } }, 
                  /* @__PURE__ */ React.createElement("span", { style: { fontSize: "20px" } }, "\u{1F5A5}\uFE0F"), 
                  /* @__PURE__ */ React.createElement("span", { style: { fontWeight: "700", color: "#63b3ed", fontSize: (15 * g1000SetupTs) + "px" } }, "Garmin G1000 SAR Configuration")
                ), 
                /* @__PURE__ */ React.createElement("div", { style: { fontSize: (12 * g1000SetupTs) + "px", color: "#a0aec0" } }, "Recommended settings for CAP search and rescue operations")
              ), 
              data.sections.map((section, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "12px", padding: (14 * g1000SetupTs) + "px" } }, 
                /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "700", color: "#f6e05e", marginBottom: (10 * g1000SetupTs) + "px", fontSize: (14 * g1000SetupTs) + "px" } }, section.name), 
                /* @__PURE__ */ React.createElement("table", { style: { ...styles.refTable, fontSize: (13 * g1000SetupTs) + "px" } }, 
                  /* @__PURE__ */ React.createElement("tbody", null, section.items.map((item, j) => /* @__PURE__ */ React.createElement("tr", { key: j }, 
                    /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, fontWeight: "600", color: "#e2e8f0", width: "45%", padding: (10 * g1000SetupTs) + "px" } }, item.label), 
                    /* @__PURE__ */ React.createElement("td", { style: { ...styles.refTd, color: "#68d391", fontFamily: "monospace", padding: (10 * g1000SetupTs) + "px" } }, item.value)
                  )))
                ), 
                section.note && /* @__PURE__ */ React.createElement("div", { style: { fontSize: (12 * g1000SetupTs) + "px", color: "#a0aec0", marginTop: (10 * g1000SetupTs) + "px", fontStyle: "italic" } }, "\u{1F4A1} ", section.note)
              ))
            );
          case "g1000Waypoints":
          case "g1000FlightPlan":
          case "g1000Navigation":
          case "g1000Marking":
          case "g1000Utilities":
            const g1000ts = g1000RefTextSize || 1;
            // Helper to style step text with knob/button formatting
            const formatG1000Step = (step) => {
              let formatted = step;
              // Style physical buttons (FPL, MENU, ENTER, CLR, etc.)
              formatted = formatted.replace(/\b(FPL|MENU|ENTER|CLR|ENT|OBS|CDI|NRST|NEW|ACTIVE|CHRT|APR|INSET|PFD|BRG1|BRG2|DME)\b/g, 
                '<span style="display:inline-block;padding:2px 8px;background:linear-gradient(180deg, #4a5568, #2d3748);border-radius:4px;font-family:monospace;font-weight:700;color:#f6e05e;border:1px solid #718096;margin:0 2px;font-size:' + (12 * g1000ts) + 'px">$1</span>');
              // Style "Direct To" button
              formatted = formatted.replace(/Direct To \(D\)/g, 
                '<span style="display:inline-block;padding:2px 8px;background:linear-gradient(180deg, #4a5568, #2d3748);border-radius:4px;font-family:monospace;font-weight:700;color:#f6e05e;border:1px solid #718096;margin:0 2px;font-size:' + (12 * g1000ts) + 'px">D</span>');
              // Style LARGE (outer) knob references
              formatted = formatted.replace(/LARGE \(outer\) knob/g, 
                '<span style="color:#68d391;font-weight:700">LARGE (outer)</span> knob');
              formatted = formatted.replace(/LARGE knob/g, 
                '<span style="color:#68d391;font-weight:700">LARGE</span> knob');
              // Style SMALL (inner) knob references  
              formatted = formatted.replace(/SMALL \(inner\) knob/g, 
                '<span style="color:#f6e05e;font-weight:700">SMALL (inner)</span> knob');
              formatted = formatted.replace(/SMALL knob/g, 
                '<span style="color:#f6e05e;font-weight:700">SMALL</span> knob');
              // Style Range-Pan knob
              formatted = formatted.replace(/Range-Pan knob/g, 
                '<span style="color:#b794f4;font-weight:700">Range-Pan knob</span>');
              formatted = formatted.replace(/Range \(small\) knob/g, 
                '<span style="color:#b794f4;font-weight:700">Range (small) knob</span>');
              formatted = formatted.replace(/CRS SMALL knob/g, 
                '<span style="color:#f6e05e;font-weight:700">CRS (small)</span> knob');
              // Style directions
              formatted = formatted.replace(/ RIGHT/g, 
                '<span style="color:#63b3ed;font-weight:700">  RIGHT</span>');
              formatted = formatted.replace(/ LEFT/g, 
                '<span style="color:#fc8181;font-weight:700">  LEFT</span>');
              // Style Push actions
              formatted = formatted.replace(/Push SMALL/g, 
                '<span style="color:#f6e05e;font-weight:700">Push SMALL</span>');
              formatted = formatted.replace(/Push LARGE/g, 
                '<span style="color:#68d391;font-weight:700">Push LARGE</span>');
              formatted = formatted.replace(/Push the Range-Pan/g, 
                '<span style="color:#b794f4;font-weight:700">Push the Range-Pan</span>');
              formatted = formatted.replace(/Push Range/g, 
                '<span style="color:#b794f4;font-weight:700">Push Range</span>');
              // Style Hold CLR
              formatted = formatted.replace(/Hold CLR/g, 
                '<span style="font-weight:700;color:#fc8181">Hold CLR</span>');
              // Style arrows
              formatted = formatted.replace(//g, '<span style="color:#f6e05e;font-weight:600">  </span>');
              return formatted;
            };
            return /* @__PURE__ */ React.createElement("div", null,
              // Text Size Controls
              React.createElement("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "16px", padding: "10px 12px", background: "rgba(0,0,0,0.3)", borderRadius: "8px" } },
                React.createElement("span", { style: { fontSize: "11px", color: "#a0aec0", fontWeight: "600" } }, "TEXT SIZE"),
                React.createElement("div", { style: { display: "flex", gap: "4px" } },
                  [0.85, 1, 1.2, 1.4].map(size => 
                    React.createElement("button", {
                      key: size,
                      style: {
                        width: "36px",
                        height: "36px",
                        background: g1000ts === size ? "rgba(99,179,237,0.3)" : "rgba(255,255,255,0.1)",
                        border: g1000ts === size ? "2px solid #63b3ed" : "1px solid rgba(255,255,255,0.2)",
                        borderRadius: "6px",
                        color: "#fff",
                        fontSize: (12 + (size - 0.85) * 8) + "px",
                        fontWeight: "700",
                        cursor: "pointer"
                      },
                      onClick: () => setG1000RefTextSize(size)
                    }, "A")
                  )
                )
              ),
              // Knob Legend
              React.createElement("div", { style: { marginBottom: "16px", padding: "12px", background: "rgba(0,0,0,0.2)", borderRadius: "8px", border: "1px solid rgba(255,255,255,0.1)" } },
                React.createElement("div", { style: { fontSize: (11 * g1000ts) + "px", color: "#a0aec0", marginBottom: "8px", fontWeight: "600" } }, "FMS KNOB REFERENCE"),
                React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px", fontSize: (12 * g1000ts) + "px" } },
                  React.createElement("div", null, React.createElement("span", { style: { color: "#68d391", fontWeight: "700" } }, "LARGE (outer)"), React.createElement("span", { style: { color: "#a0aec0" } }, " = scroll/select")),
                  React.createElement("div", null, React.createElement("span", { style: { color: "#f6e05e", fontWeight: "700" } }, "SMALL (inner)"), React.createElement("span", { style: { color: "#a0aec0" } }, " = change values")),
                  React.createElement("div", null, React.createElement("span", { style: { color: "#63b3ed", fontWeight: "700" } }, " RIGHT"), React.createElement("span", { style: { color: "#a0aec0" } }, " = clockwise")),
                  React.createElement("div", null, React.createElement("span", { style: { color: "#fc8181", fontWeight: "700" } }, " LEFT"), React.createElement("span", { style: { color: "#a0aec0" } }, " = counter-clockwise"))
                )
              ),
              // Procedures
              data.procedures.map((proc, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "16px", padding: (14 * g1000ts) + "px" } }, 
                /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "700", color: "#63b3ed", marginBottom: (12 * g1000ts) + "px", fontSize: (15 * g1000ts) + "px", display: "flex", alignItems: "center", gap: "10px" } }, 
                  /* @__PURE__ */ React.createElement("span", { style: { background: "linear-gradient(135deg, #3182ce, #2b6cb0)", padding: (6 * g1000ts) + "px " + (10 * g1000ts) + "px", borderRadius: "6px", fontSize: (13 * g1000ts) + "px", color: "#fff", fontWeight: "700" } }, i + 1), 
                  proc.name
                ), 
                /* @__PURE__ */ React.createElement("ol", { style: { margin: 0, paddingLeft: (28 * g1000ts) + "px", fontSize: (13 * g1000ts) + "px", lineHeight: "2.0" } }, 
                  proc.steps.map((step, j) => /* @__PURE__ */ React.createElement("li", { key: j, style: { marginBottom: (8 * g1000ts) + "px", color: "#e2e8f0" } }, 
                    /* @__PURE__ */ React.createElement("span", { dangerouslySetInnerHTML: { __html: formatG1000Step(step) } })
                  ))
                ), 
                proc.note && /* @__PURE__ */ React.createElement("div", { style: { marginTop: (12 * g1000ts) + "px", padding: (10 * g1000ts) + "px " + (14 * g1000ts) + "px", background: "rgba(246,224,94,0.1)", borderLeft: "4px solid #f6e05e", borderRadius: "0 6px 6px 0", fontSize: (12 * g1000ts) + "px", color: "#f6e05e" } }, "\u26A0\uFE0F ", proc.note)
              ))
            );
          case "g1000SAR":
            const g1000SarTs = g1000RefTextSize || 1;
            // Helper to style step text with knob/button formatting
            const formatG1000SarStep = (step) => {
              let formatted = step;
              // Style physical buttons
              formatted = formatted.replace(/\b(FPL|MENU|ENTER|CLR|ENT|OBS|CDI|NRST|NEW|ACTIVE)\b/g, 
                '<span style="display:inline-block;padding:2px 8px;background:linear-gradient(180deg, #4a5568, #2d3748);border-radius:4px;font-family:monospace;font-weight:700;color:#f6e05e;border:1px solid #718096;margin:0 2px;font-size:' + (12 * g1000SarTs) + 'px">$1</span>');
              // Style LARGE (outer) knob references
              formatted = formatted.replace(/LARGE \(outer\) knob/g, 
                '<span style="color:#68d391;font-weight:700">LARGE (outer)</span> knob');
              formatted = formatted.replace(/LARGE knob/g, 
                '<span style="color:#68d391;font-weight:700">LARGE</span> knob');
              // Style SMALL (inner) knob references  
              formatted = formatted.replace(/SMALL \(inner\) knob/g, 
                '<span style="color:#f6e05e;font-weight:700">SMALL (inner)</span> knob');
              formatted = formatted.replace(/SMALL knob/g, 
                '<span style="color:#f6e05e;font-weight:700">SMALL</span> knob');
              // Style directions
              formatted = formatted.replace(/ RIGHT/g, 
                '<span style="color:#63b3ed;font-weight:700">  RIGHT</span>');
              formatted = formatted.replace(/ LEFT/g, 
                '<span style="color:#fc8181;font-weight:700">  LEFT</span>');
              // Style Push actions
              formatted = formatted.replace(/Push SMALL/g, 
                '<span style="color:#f6e05e;font-weight:700">Push SMALL</span>');
              // Style Turn LARGE/SMALL
              formatted = formatted.replace(/Turn LARGE knob to/g, 
                'Turn <span style="color:#68d391;font-weight:700">LARGE</span> knob to');
              formatted = formatted.replace(/Turn SMALL knob/g, 
                'Turn <span style="color:#f6e05e;font-weight:700">SMALL</span> knob');
              // Style quoted menu items
              formatted = formatted.replace(/'([^']+)'/g, 
                '<span style="color:#68d391;font-weight:600">\'$1\'</span>');
              // Style arrows
              formatted = formatted.replace(//g, '<span style="color:#f6e05e;font-weight:600">  </span>');
              return formatted;
            };
            return /* @__PURE__ */ React.createElement("div", null, 
              // Text Size Controls
              React.createElement("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: "16px", padding: "10px 12px", background: "rgba(0,0,0,0.3)", borderRadius: "8px" } },
                React.createElement("span", { style: { fontSize: "11px", color: "#a0aec0", fontWeight: "600" } }, "TEXT SIZE"),
                React.createElement("div", { style: { display: "flex", gap: "4px" } },
                  [0.85, 1, 1.2, 1.4].map(size => 
                    React.createElement("button", {
                      key: size,
                      style: {
                        width: "36px",
                        height: "36px",
                        background: g1000SarTs === size ? "rgba(99,179,237,0.3)" : "rgba(255,255,255,0.1)",
                        border: g1000SarTs === size ? "2px solid #63b3ed" : "1px solid rgba(255,255,255,0.2)",
                        borderRadius: "6px",
                        color: "#fff",
                        fontSize: (12 + (size - 0.85) * 8) + "px",
                        fontWeight: "700",
                        cursor: "pointer"
                      },
                      onClick: () => setG1000RefTextSize(size)
                    }, "A")
                  )
                )
              ),
              // SAR Unlock Warning
              /* @__PURE__ */ React.createElement("div", { style: { ...styles.refCard, marginBottom: "16px", background: "rgba(229,62,62,0.15)", borderColor: "rgba(229,62,62,0.4)", padding: (14 * g1000SarTs) + "px" } }, 
                /* @__PURE__ */ React.createElement("div", { style: { fontSize: (13 * g1000SarTs) + "px", color: "#fc8181", fontWeight: "600", lineHeight: "1.5" } },
                  " IMPORTANT: G1000 SAR feature requires a Garmin SAR unlock card inserted in the TOP SD card slot on the MFD."
                )
              ),
              // Header Card
              /* @__PURE__ */ React.createElement("div", { style: { ...styles.refCard, marginBottom: "16px", background: "linear-gradient(135deg, rgba(237,137,54,0.15), rgba(246,224,94,0.15))", borderColor: "rgba(237,137,54,0.4)" } }, 
                /* @__PURE__ */ React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" } }, 
                  /* @__PURE__ */ React.createElement("span", { style: { fontSize: "20px" } }, "\u{1F50E}"), 
                  /* @__PURE__ */ React.createElement("span", { style: { fontWeight: "700", color: "#ed8936", fontSize: (15 * g1000SarTs) + "px" } }, "G1000 Search & Rescue Pattern Setup")
                ), 
                /* @__PURE__ */ React.createElement("div", { style: { fontSize: (12 * g1000SarTs) + "px", color: "#a0aec0" } }, "Access via: FPL  MENU  Search and Rescue")
              ), 
              // Knob Legend
              React.createElement("div", { style: { marginBottom: "16px", padding: "12px", background: "rgba(0,0,0,0.2)", borderRadius: "8px", border: "1px solid rgba(255,255,255,0.1)" } },
                React.createElement("div", { style: { fontSize: (11 * g1000SarTs) + "px", color: "#a0aec0", marginBottom: "8px", fontWeight: "600" } }, "FMS KNOB REFERENCE"),
                React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px", fontSize: (12 * g1000SarTs) + "px" } },
                  React.createElement("div", null, React.createElement("span", { style: { color: "#68d391", fontWeight: "700" } }, "LARGE (outer)"), React.createElement("span", { style: { color: "#a0aec0" } }, " = scroll/select")),
                  React.createElement("div", null, React.createElement("span", { style: { color: "#f6e05e", fontWeight: "700" } }, "SMALL (inner)"), React.createElement("span", { style: { color: "#a0aec0" } }, " = change values")),
                  React.createElement("div", null, React.createElement("span", { style: { color: "#63b3ed", fontWeight: "700" } }, " RIGHT"), React.createElement("span", { style: { color: "#a0aec0" } }, " = clockwise")),
                  React.createElement("div", null, React.createElement("span", { style: { color: "#fc8181", fontWeight: "700" } }, " LEFT"), React.createElement("span", { style: { color: "#a0aec0" } }, " = counter-clockwise"))
                )
              ),
              // Procedures
              data.procedures.map((proc, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { ...styles.refCard, marginBottom: "16px", padding: (14 * g1000SarTs) + "px" } }, 
                /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "700", color: "#f6e05e", marginBottom: (12 * g1000SarTs) + "px", fontSize: (15 * g1000SarTs) + "px" } }, proc.name), 
                /* @__PURE__ */ React.createElement("ol", { style: { margin: 0, paddingLeft: (28 * g1000SarTs) + "px", fontSize: (13 * g1000SarTs) + "px", lineHeight: "2.0" } }, 
                  proc.steps.map((step, j) => /* @__PURE__ */ React.createElement("li", { key: j, style: { marginBottom: (8 * g1000SarTs) + "px", color: "#e2e8f0" } }, 
                    /* @__PURE__ */ React.createElement("span", { dangerouslySetInnerHTML: { __html: formatG1000SarStep(step) } })
                  ))
                ), 
                proc.note && /* @__PURE__ */ React.createElement("div", { style: { marginTop: (12 * g1000SarTs) + "px", padding: (10 * g1000SarTs) + "px " + (14 * g1000SarTs) + "px", background: "rgba(246,224,94,0.1)", borderLeft: "4px solid #f6e05e", borderRadius: "0 6px 6px 0", fontSize: (12 * g1000SarTs) + "px", color: "#f6e05e" } }, "\u{1F4DD} ", proc.note), 
                proc.diagram && /* @__PURE__ */ React.createElement("pre", { style: { ...styles.pre, marginTop: (14 * g1000SarTs) + "px", fontSize: (11 * g1000SarTs) + "px", color: "#68d391", background: "rgba(0,0,0,0.3)", padding: (14 * g1000SarTs) + "px", borderRadius: "6px" } }, proc.diagram)
              ))
            );
          case "gpsConverter":
            return /* @__PURE__ */ React.createElement(GpsConverterWidget, null);
          default:
            return /* @__PURE__ */ React.createElement("div", { style: { color: "#a0aec0" } }, "Select a reference section");
        }
      };
      return /* @__PURE__ */ React.createElement("div", null, 
        // GENERAL QUICK REFERENCE SECTION
        /* @__PURE__ */ React.createElement("div", { style: styles.section }, 
          /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u{1F4DA} Quick Reference Guide"), 
          /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, 
            /* @__PURE__ */ React.createElement("div", { style: styles.refNav }, refSections.filter((s) => !s.isG1000 && !s.isRhotheta && !s.isCalc).map((section) => /* @__PURE__ */ React.createElement("button", { key: section.id, style: { ...styles.refNavBtn, ...activeRefSection === section.id ? styles.refNavActive : styles.refNavInactive }, onClick: () => setActiveRefSection(section.id) }, section.label))),
            // Show content here if a general section is selected
            !refSections.find(s => s.id === activeRefSection)?.isG1000 && !refSections.find(s => s.id === activeRefSection)?.isRhotheta && !refSections.find(s => s.id === activeRefSection)?.isCalc && /* @__PURE__ */ React.createElement("div", { style: { ...styles.section, marginBottom: 0, marginTop: "12px" } }, 
              /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, referenceData[activeRefSection]?.icon, " ", referenceData[activeRefSection]?.title), 
              /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, renderRefContent())
            )
          )
        ),
        // AVIATION CALCULATIONS SECTION
        /* @__PURE__ */ React.createElement("div", { style: { ...styles.section, marginTop: "16px" } }, 
          /* @__PURE__ */ React.createElement("div", { style: { ...styles.sectionHeader, background: "linear-gradient(135deg, rgba(104,211,145,0.2), rgba(56,178,172,0.15))", borderColor: "rgba(104,211,145,0.4)" } }, "\u{1F9EE} Aviation Calculations"), 
          /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, 
            /* @__PURE__ */ React.createElement("div", { style: styles.refNav }, refSections.filter((s) => s.isCalc).map((section) => /* @__PURE__ */ React.createElement("button", { key: section.id, style: { ...styles.refNavBtn, ...activeRefSection === section.id ? { ...styles.refNavActive, background: "linear-gradient(135deg, rgba(104,211,145,0.4), rgba(56,178,172,0.3))", borderColor: "rgba(104,211,145,0.5)" } : { ...styles.refNavInactive, borderColor: "rgba(104,211,145,0.2)" } }, onClick: () => setActiveRefSection(section.id) }, section.label))),
            // Show content here if a Calc section is selected
            refSections.find(s => s.id === activeRefSection)?.isCalc && /* @__PURE__ */ React.createElement("div", { style: { ...styles.section, marginBottom: 0, marginTop: "12px" } }, 
              /* @__PURE__ */ React.createElement("div", { style: { ...styles.sectionHeader, background: "linear-gradient(135deg, rgba(104,211,145,0.15), rgba(56,178,172,0.1))", borderColor: "rgba(104,211,145,0.3)" } }, referenceData[activeRefSection]?.icon, " ", referenceData[activeRefSection]?.title), 
              /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, renderRefContent())
            )
          )
        ),
        // RHOTHETA RT-600 SECTION
        /* @__PURE__ */ React.createElement("div", { style: { ...styles.section, marginTop: "16px" } }, 
          /* @__PURE__ */ React.createElement("div", { style: { ...styles.sectionHeader, background: "linear-gradient(135deg, rgba(246,224,94,0.2), rgba(237,137,54,0.15))", borderColor: "rgba(246,224,94,0.4)" } }, "\u{1F4E1} Rhotheta RT-600 Direction Finder"), 
          /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, 
            /* @__PURE__ */ React.createElement("div", { style: styles.refNav }, refSections.filter((s) => s.isRhotheta).map((section) => /* @__PURE__ */ React.createElement("button", { key: section.id, style: { ...styles.refNavBtn, ...activeRefSection === section.id ? { ...styles.refNavActive, background: "linear-gradient(135deg, rgba(246,224,94,0.4), rgba(237,137,54,0.3))", borderColor: "rgba(246,224,94,0.5)" } : { ...styles.refNavInactive, borderColor: "rgba(246,224,94,0.2)" } }, onClick: () => setActiveRefSection(section.id) }, section.label))),
            // Show content here if a Rhotheta section is selected
            refSections.find(s => s.id === activeRefSection)?.isRhotheta && /* @__PURE__ */ React.createElement("div", { style: { ...styles.section, marginBottom: 0, marginTop: "12px" } }, 
              /* @__PURE__ */ React.createElement("div", { style: { ...styles.sectionHeader, background: "linear-gradient(135deg, rgba(246,224,94,0.15), rgba(237,137,54,0.1))", borderColor: "rgba(246,224,94,0.3)" } }, referenceData[activeRefSection]?.icon, " ", referenceData[activeRefSection]?.title), 
              /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, renderRefContent())
            )
          )
        ),
        // GARMIN G1000 SECTION
        /* @__PURE__ */ React.createElement("div", { style: { ...styles.section, marginTop: "16px" } }, 
          /* @__PURE__ */ React.createElement("div", { style: { ...styles.sectionHeader, background: "linear-gradient(135deg, rgba(49,130,206,0.2), rgba(56,178,172,0.15))", borderColor: "rgba(99,179,237,0.4)" } }, "\u{1F5A5}\uFE0F Garmin G1000 Quick Reference"), 
          /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, 
            /* @__PURE__ */ React.createElement("div", { style: styles.refNav }, refSections.filter((s) => s.isG1000).map((section) => /* @__PURE__ */ React.createElement("button", { key: section.id, style: { ...styles.refNavBtn, ...activeRefSection === section.id ? { ...styles.refNavActive, background: "linear-gradient(135deg, rgba(49,130,206,0.4), rgba(56,178,172,0.3))", borderColor: "rgba(99,179,237,0.5)" } : { ...styles.refNavInactive, borderColor: "rgba(99,179,237,0.2)" } }, onClick: () => setActiveRefSection(section.id) }, section.label))),
            // Show content here if a G1000 section is selected
            refSections.find(s => s.id === activeRefSection)?.isG1000 && /* @__PURE__ */ React.createElement("div", { style: { ...styles.section, marginBottom: 0, marginTop: "12px" } }, 
              /* @__PURE__ */ React.createElement("div", { style: { ...styles.sectionHeader, background: "linear-gradient(135deg, rgba(49,130,206,0.15), rgba(56,178,172,0.1))", borderColor: "rgba(99,179,237,0.3)" } }, referenceData[activeRefSection]?.icon, " ", referenceData[activeRefSection]?.title), 
              /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, renderRefContent())
            )
          )
        )
      );
    };
    const renderCoCommsTab = () => {
      const stateData = stateCommsData.states["CO"];
      const commsStyles = {
        header: { background: "linear-gradient(135deg, rgba(246,224,94,0.2), rgba(237,137,54,0.15))", border: "1px solid rgba(246,224,94,0.4)", borderRadius: "12px", padding: "16px", marginBottom: "16px", textAlign: "center" },
        headerTitle: { fontSize: "18px", fontWeight: "700", color: "#f6e05e", marginBottom: "4px", display: "flex", alignItems: "center", justifyContent: "center", gap: "8px" },
        headerSub: { fontSize: "11px", color: "#a0aec0" },
        viewTabs: { display: "flex", gap: "6px", marginBottom: "16px" },
        viewTab: { flex: 1, padding: "12px", borderRadius: "8px", border: "2px solid", cursor: "pointer", fontWeight: "600", fontSize: "12px", fontFamily: "inherit", textAlign: "center" },
        searchBox: { background: "rgba(0,0,0,0.3)", border: "1px solid rgba(255,255,255,0.15)", borderRadius: "8px", padding: "12px", color: "#fff", width: "100%", marginBottom: "16px", fontSize: "14px" },
        table: { width: "100%", borderCollapse: "collapse", fontSize: "12px" },
        th: { background: "rgba(246,224,94,0.15)", padding: "10px 8px", textAlign: "left", borderBottom: "2px solid rgba(246,224,94,0.3)", fontSize: "11px", fontWeight: "700", color: "#f6e05e" },
        td: { padding: "10px 8px", borderBottom: "1px solid rgba(255,255,255,0.05)" },
        chNum: { fontFamily: "monospace", fontWeight: "700", color: "#68d391", fontSize: "13px", minWidth: "50px" },
        chName: { fontWeight: "600", color: "#e2e8f0" },
        chNote: { fontSize: "11px", color: "#a0aec0" },
        callsignBadge: { background: "linear-gradient(135deg, #dd6b20, #c05621)", padding: "4px 10px", borderRadius: "6px", fontWeight: "700", fontSize: "13px", fontFamily: "monospace", display: "inline-block", minWidth: "40px", textAlign: "center" },
        section: { marginBottom: "16px", padding: "12px", background: "rgba(0,0,0,0.2)", borderRadius: "8px", border: "1px solid rgba(255,255,255,0.1)" },
        sectionTitle: { fontSize: "13px", fontWeight: "700", color: "#f6e05e", marginBottom: "12px", display: "flex", alignItems: "center", gap: "8px" }
      };
      const filteredChannels = stateData.channels.allChannels.filter(
        (ch) => channelSearch === "" || ch.ch.toLowerCase().includes(channelSearch.toLowerCase()) || ch.name.toLowerCase().includes(channelSearch.toLowerCase()) || ch.note.toLowerCase().includes(channelSearch.toLowerCase())
      );
      const filteredCallsigns = stateData.allCallsigns.filter(
        (cs) => callsignSearch === "" || cs.callsign.includes(callsignSearch) || cs.name.toLowerCase().includes(callsignSearch.toLowerCase()) || cs.capid && cs.capid.toLowerCase().includes(callsignSearch.toLowerCase())
      );
      return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { style: commsStyles.header }, /* @__PURE__ */ React.createElement("div", { style: commsStyles.headerTitle }, /* @__PURE__ */ React.createElement("span", null, "\u{1F3D4}\uFE0F"), " Colorado Wing Communications"), /* @__PURE__ */ React.createElement("div", { style: commsStyles.headerSub }, stateData.abbreviation, " \u2022 Updated: ", stateData.updated)), /* @__PURE__ */ React.createElement("div", { style: commsStyles.viewTabs }, /* @__PURE__ */ React.createElement(
        "button",
        {
          style: {
            ...commsStyles.viewTab,
            background: commsView === "channels" ? "linear-gradient(135deg, #dd6b20, #c05621)" : "rgba(0,0,0,0.3)",
            borderColor: commsView === "channels" ? "#f6ad55" : "rgba(255,255,255,0.2)",
            color: commsView === "channels" ? "#fff" : "#a0aec0"
          },
          onClick: () => setCommsView("channels")
        },
        "\u{1F4FB} TDFM Channels"
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          style: {
            ...commsStyles.viewTab,
            background: commsView === "callsigns" ? "linear-gradient(135deg, #dd6b20, #c05621)" : "rgba(0,0,0,0.3)",
            borderColor: commsView === "callsigns" ? "#f6ad55" : "rgba(255,255,255,0.2)",
            color: commsView === "callsigns" ? "#fff" : "#a0aec0"
          },
          onClick: () => setCommsView("callsigns")
        },
        "\u{1F4CB} Callsigns"
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          style: {
            ...commsStyles.viewTab,
            background: commsView === "bases" ? "linear-gradient(135deg, #dd6b20, #c05621)" : "rgba(0,0,0,0.3)",
            borderColor: commsView === "bases" ? "#f6ad55" : "rgba(255,255,255,0.2)",
            color: commsView === "bases" ? "#fff" : "#a0aec0"
          },
          onClick: () => setCommsView("bases")
        },
        "\u{1F3E2} Bases"
      )), commsView === "channels" && /* @__PURE__ */ React.createElement("div", { style: styles.section }, /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u{1F4FB} TDFM-136 P25 VHF Channel Plan"), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, /* @__PURE__ */ React.createElement(
        "input",
        {
          style: commsStyles.searchBox,
          type: "text",
          placeholder: "\u{1F50D} Search channels by number, name, or location...",
          value: channelSearch,
          onChange: (e) => setChannelSearch(e.target.value)
        }
      ), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "12px" } }, "Version: ", stateData.channels.version, " \u2022 ", stateData.channels.note), /* @__PURE__ */ React.createElement("div", { style: { maxHeight: "60vh", overflow: "auto" } }, /* @__PURE__ */ React.createElement("table", { style: commsStyles.table }, /* @__PURE__ */ React.createElement("thead", { style: { position: "sticky", top: 0 } }, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", { style: commsStyles.th }, "CH"), /* @__PURE__ */ React.createElement("th", { style: commsStyles.th }, "NAME"), /* @__PURE__ */ React.createElement("th", { style: commsStyles.th }, "NOTE"))), /* @__PURE__ */ React.createElement("tbody", null, filteredChannels.map((ch, i) => /* @__PURE__ */ React.createElement("tr", { key: i, style: { background: ch.note ? "rgba(104,211,145,0.05)" : "transparent" } }, /* @__PURE__ */ React.createElement("td", { style: { ...commsStyles.td, ...commsStyles.chNum } }, ch.ch), /* @__PURE__ */ React.createElement("td", { style: { ...commsStyles.td, ...commsStyles.chName } }, ch.name), /* @__PURE__ */ React.createElement("td", { style: { ...commsStyles.td, ...commsStyles.chNote } }, ch.note)))))), /* @__PURE__ */ React.createElement("div", { style: { marginTop: "12px", fontSize: "11px", color: "#a0aec0", textAlign: "center" } }, "Showing ", filteredChannels.length, " of ", stateData.channels.allChannels.length, " channels"))), commsView === "callsigns" && /* @__PURE__ */ React.createElement("div", { style: styles.section }, /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u{1F4CB} Blue Mesa Callsign Roster"), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, /* @__PURE__ */ React.createElement(
        "input",
        {
          style: commsStyles.searchBox,
          type: "text",
          placeholder: "\u{1F50D} Search by callsign, name, or CAPID...",
          value: callsignSearch,
          onChange: (e) => setCallsignSearch(e.target.value)
        }
      ), /* @__PURE__ */ React.createElement("div", { style: { ...commsStyles.section, background: "rgba(246,224,94,0.05)", borderColor: "rgba(246,224,94,0.2)", marginBottom: "16px" } }, /* @__PURE__ */ React.createElement("div", { style: { fontSize: "11px", fontWeight: "600", color: "#f6e05e", marginBottom: "8px" } }, "CALLSIGN BLOCKS"), /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "6px", fontSize: "11px" } }, stateData.callsignRanges.ranges.map((r, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { display: "flex", justifyContent: "space-between", padding: "4px 8px", background: "rgba(0,0,0,0.2)", borderRadius: "4px" } }, /* @__PURE__ */ React.createElement("span", { style: { fontFamily: "monospace", fontWeight: "700", color: "#68d391" } }, r.range), /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0" } }, r.assignment))))), /* @__PURE__ */ React.createElement("div", { style: { maxHeight: "50vh", overflow: "auto" } }, /* @__PURE__ */ React.createElement("table", { style: commsStyles.table }, /* @__PURE__ */ React.createElement("thead", { style: { position: "sticky", top: 0 } }, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("th", { style: commsStyles.th }, "CALL"), /* @__PURE__ */ React.createElement("th", { style: commsStyles.th }, "NAME"), /* @__PURE__ */ React.createElement("th", { style: commsStyles.th }, "CAPID/CODE"), /* @__PURE__ */ React.createElement("th", { style: commsStyles.th }, "NOTE"))), /* @__PURE__ */ React.createElement("tbody", null, filteredCallsigns.map((cs, i) => /* @__PURE__ */ React.createElement("tr", { key: i, style: { background: cs.note ? "rgba(246,224,94,0.05)" : "transparent" } }, /* @__PURE__ */ React.createElement("td", { style: commsStyles.td }, /* @__PURE__ */ React.createElement("span", { style: commsStyles.callsignBadge }, cs.callsign)), /* @__PURE__ */ React.createElement("td", { style: { ...commsStyles.td, ...commsStyles.chName } }, cs.name), /* @__PURE__ */ React.createElement("td", { style: { ...commsStyles.td, fontSize: "11px", fontFamily: "monospace", color: "#a0aec0" } }, cs.capid), /* @__PURE__ */ React.createElement("td", { style: { ...commsStyles.td, ...commsStyles.chNote } }, cs.note || "")))))), /* @__PURE__ */ React.createElement("div", { style: { marginTop: "12px", fontSize: "11px", color: "#a0aec0", textAlign: "center" } }, "Showing ", filteredCallsigns.length, " of ", stateData.allCallsigns.length, " callsigns"))), commsView === "bases" && /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { style: styles.section }, /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u{1F3E2} Mission Bases & ICPs"), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, stateData.missionBases.bases.map((base, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { display: "grid", gridTemplateColumns: "70px 1fr auto", gap: "12px", alignItems: "center", padding: "12px", background: "rgba(0,0,0,0.2)", borderRadius: "8px", marginBottom: "8px" } }, /* @__PURE__ */ React.createElement("div", { style: commsStyles.callsignBadge }, base.callsign), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "600", color: "#e2e8f0", fontSize: "14px" } }, base.name), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0" } }, base.code)), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "11px", color: "#68d391", fontWeight: "600" } }, "ICP/ICC"))))), /* @__PURE__ */ React.createElement("div", { style: styles.section }, /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u{1F465} Group Commanders"), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, stateData.groupCommanders.groups.map((grp, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { display: "grid", gridTemplateColumns: "70px 1fr auto", gap: "12px", alignItems: "center", padding: "12px", background: "rgba(0,0,0,0.2)", borderRadius: "8px", marginBottom: "8px" } }, /* @__PURE__ */ React.createElement("div", { style: commsStyles.callsignBadge }, grp.callsign), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "600", color: "#e2e8f0", fontSize: "14px" } }, grp.name), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0" } }, grp.commander)), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "11px", color: "#f6e05e", fontWeight: "600" } }, "CC"))))), /* @__PURE__ */ React.createElement("div", { style: styles.section }, /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u{1F690} Ground Vehicles"), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, /* @__PURE__ */ React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", marginBottom: "12px" } }, stateData.vehicles.note), /* @__PURE__ */ React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(2, 1fr)", gap: "8px" } }, stateData.vehicles.vehicles.map((v, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { display: "flex", alignItems: "center", gap: "10px", padding: "10px", background: "rgba(0,0,0,0.2)", borderRadius: "6px" } }, /* @__PURE__ */ React.createElement("span", { style: { ...commsStyles.callsignBadge, padding: "4px 8px", fontSize: "12px" } }, v.callsign), /* @__PURE__ */ React.createElement("span", { style: { fontSize: "12px", color: "#a0aec0", fontFamily: "monospace" } }, v.tailNumber)))))), /* @__PURE__ */ React.createElement("div", { style: styles.section }, /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u2B50 Special Callsigns"), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, stateData.specialCallsigns.callsigns.map((s, i) => /* @__PURE__ */ React.createElement("div", { key: i, style: { display: "grid", gridTemplateColumns: "70px 1fr", gap: "12px", alignItems: "center", padding: "10px", background: "rgba(0,0,0,0.2)", borderRadius: "6px", marginBottom: "6px" } }, /* @__PURE__ */ React.createElement("div", { style: commsStyles.callsignBadge }, s.callsign), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { style: { fontWeight: "600", color: "#e2e8f0" } }, s.name), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0" } }, s.person || s.code || s.note))))))), /* @__PURE__ */ React.createElement("div", { style: { padding: "12px", background: "rgba(0,0,0,0.2)", borderRadius: "8px", border: "1px dashed rgba(246,224,94,0.3)", textAlign: "center", fontSize: "10px", color: "#a0aec0", marginTop: "16px" } }, /* @__PURE__ */ React.createElement("strong", { style: { color: "#f6e05e" } }, "Close Hold Information"), " \u2014 Contact Wing Communications Officer for updates"));
    };
    const renderEmergencyTab = () => {
      const aircraft = emergencyProcedures.aircraft[selectedAircraft];
      const availableAircraft = Object.entries(emergencyProcedures.aircraft);
      const emergencyStyles = {
        header: {
          background: "linear-gradient(135deg, rgba(197,48,48,0.3), rgba(155,44,44,0.2))",
          border: "2px solid #c53030",
          borderRadius: "12px",
          padding: "16px",
          marginBottom: "16px",
          textAlign: "center"
        },
        headerTitle: {
          fontSize: "20px",
          fontWeight: "700",
          color: "#fc8181",
          marginBottom: "4px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          gap: "8px"
        },
        headerSub: {
          fontSize: "12px",
          color: "#feb2b2"
        },
        aircraftSelector: {
          display: "flex",
          gap: "8px",
          marginBottom: "16px",
          flexWrap: "wrap",
          justifyContent: "center"
        },
        aircraftBtn: {
          padding: "10px 16px",
          borderRadius: "8px",
          border: "2px solid",
          cursor: "pointer",
          fontWeight: "600",
          fontSize: "12px",
          fontFamily: "inherit",
          transition: "all 0.2s"
        },
        categoryNav: {
          display: "flex",
          gap: "6px",
          marginBottom: "16px",
          flexWrap: "wrap"
        },
        categoryBtn: {
          padding: "10px 14px",
          borderRadius: "8px",
          border: "2px solid",
          cursor: "pointer",
          fontWeight: "600",
          fontSize: "11px",
          fontFamily: "inherit",
          display: "flex",
          alignItems: "center",
          gap: "6px"
        },
        procedureCard: {
          borderRadius: "10px",
          marginBottom: "12px",
          overflow: "hidden",
          border: "1px solid rgba(255,255,255,0.1)"
        },
        procedureHeader: {
          padding: "14px 16px",
          cursor: "pointer",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        },
        procedureTitle: {
          fontWeight: "700",
          fontSize: "14px",
          display: "flex",
          alignItems: "center",
          gap: "8px"
        },
        criticalBadge: {
          background: "#c53030",
          color: "#fff",
          padding: "2px 8px",
          borderRadius: "4px",
          fontSize: "9px",
          fontWeight: "700",
          textTransform: "uppercase",
          letterSpacing: "0.5px"
        },
        procedureBody: {
          padding: "0 16px 16px 16px"
        },
        stepRow: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "flex-start",
          padding: "10px 0",
          borderBottom: "1px solid rgba(255,255,255,0.05)"
        },
        stepAction: {
          flex: 1,
          fontSize: "13px",
          color: "#e2e8f0"
        },
        stepValue: {
          fontWeight: "700",
          fontSize: "13px",
          color: "#68d391",
          textAlign: "right",
          maxWidth: "50%"
        },
        stepHeader: {
          padding: "12px 0 6px 0",
          fontSize: "11px",
          fontWeight: "700",
          color: "#f6e05e",
          textTransform: "uppercase",
          letterSpacing: "1px",
          borderBottom: "none"
        },
        noteBox: {
          marginTop: "12px",
          padding: "10px 12px",
          background: "rgba(99,179,237,0.1)",
          borderLeft: "3px solid #63b3ed",
          borderRadius: "0 6px 6px 0",
          fontSize: "12px",
          color: "#90cdf4"
        },
        warningBox: {
          marginTop: "12px",
          padding: "10px 12px",
          background: "rgba(197,48,48,0.15)",
          borderLeft: "3px solid #fc8181",
          borderRadius: "0 6px 6px 0",
          fontSize: "12px",
          color: "#feb2b2"
        },
        quickCodes: {
          display: "grid",
          gridTemplateColumns: "repeat(3, 1fr)",
          gap: "8px",
          marginTop: "16px"
        },
        quickCode: {
          textAlign: "center",
          padding: "12px",
          background: "rgba(0,0,0,0.3)",
          borderRadius: "8px",
          border: "1px solid rgba(255,255,255,0.1)"
        },
        quickCodeValue: {
          fontSize: "20px",
          fontWeight: "700",
          fontFamily: "monospace"
        }
      };
      const selectedCategory = aircraft?.categories.find((c) => c.id === selectedEmergencyCategory);
      return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.header }, /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.headerTitle }, /* @__PURE__ */ React.createElement("span", { style: { fontSize: "28px" } }, "\u{1F6A8}"), "EMERGENCY PROCEDURES"), /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.headerSub }, "Quick reference checklist - NOT for training")), /* @__PURE__ */ React.createElement("div", { style: styles.section }, /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u2708\uFE0F Select Aircraft"), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.aircraftSelector }, availableAircraft.map(([id, ac]) => /* @__PURE__ */ React.createElement(
        "button",
        {
          key: id,
          style: {
            ...emergencyStyles.aircraftBtn,
            background: selectedAircraft === id ? "linear-gradient(135deg, #dd6b20, #c05621)" : "rgba(0,0,0,0.3)",
            borderColor: selectedAircraft === id ? "#f6ad55" : "rgba(255,255,255,0.2)",
            color: selectedAircraft === id ? "#fff" : "#a0aec0"
          },
          onClick: () => setSelectedAircraft(id)
        },
        ac.icon,
        " ",
        ac.name
      ))), aircraft && /* @__PURE__ */ React.createElement("div", { style: { textAlign: "center", fontSize: "12px", color: "#a0aec0" } }, aircraft.variant))), /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.quickCodes }, /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.quickCode }, /* @__PURE__ */ React.createElement("div", { style: { ...emergencyStyles.quickCodeValue, color: "#fc8181" } }, "7700"), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", marginTop: "4px" } }, "EMERGENCY")), /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.quickCode }, /* @__PURE__ */ React.createElement("div", { style: { ...emergencyStyles.quickCodeValue, color: "#f6e05e" } }, "7600"), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", marginTop: "4px" } }, "LOST COMM")), /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.quickCode }, /* @__PURE__ */ React.createElement("div", { style: { ...emergencyStyles.quickCodeValue, color: "#68d391" } }, "121.5"), /* @__PURE__ */ React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", marginTop: "4px" } }, "GUARD"))), aircraft && /* @__PURE__ */ React.createElement("div", { style: { ...styles.section, marginTop: "16px" } }, /* @__PURE__ */ React.createElement("div", { style: styles.sectionHeader }, "\u{1F4CB} Procedure Categories"), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.categoryNav }, aircraft.categories.map((cat) => /* @__PURE__ */ React.createElement(
        "button",
        {
          key: cat.id,
          style: {
            ...emergencyStyles.categoryBtn,
            background: selectedEmergencyCategory === cat.id ? `linear-gradient(135deg, ${cat.color}40, ${cat.color}20)` : "rgba(0,0,0,0.2)",
            borderColor: selectedEmergencyCategory === cat.id ? cat.color : "rgba(255,255,255,0.1)",
            color: selectedEmergencyCategory === cat.id ? "#fff" : "#a0aec0"
          },
          onClick: () => {
            setSelectedEmergencyCategory(cat.id);
            setExpandedProcedure(null);
          }
        },
        /* @__PURE__ */ React.createElement("span", null, cat.icon),
        cat.name
      ))))), selectedCategory && /* @__PURE__ */ React.createElement("div", { style: styles.section }, /* @__PURE__ */ React.createElement("div", { style: { ...styles.sectionHeader, background: `linear-gradient(135deg, ${selectedCategory.color}60, ${selectedCategory.color}30)` } }, selectedCategory.icon, " ", selectedCategory.name), /* @__PURE__ */ React.createElement("div", { style: styles.sectionBody }, selectedCategory.procedures.map((proc) => {
        const isExpanded = expandedProcedure === proc.id;
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            key: proc.id,
            style: {
              ...emergencyStyles.procedureCard,
              background: isExpanded ? `linear-gradient(135deg, ${selectedCategory.color}15, ${selectedCategory.color}05)` : "rgba(0,0,0,0.2)",
              borderColor: isExpanded ? selectedCategory.color : "rgba(255,255,255,0.1)"
            }
          },
          /* @__PURE__ */ React.createElement(
            "div",
            {
              style: {
                ...emergencyStyles.procedureHeader,
                background: isExpanded ? `${selectedCategory.color}20` : "transparent"
              },
              onClick: () => setExpandedProcedure(isExpanded ? null : proc.id)
            },
            /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.procedureTitle }, proc.critical && /* @__PURE__ */ React.createElement("span", { style: emergencyStyles.criticalBadge }, "Critical"), /* @__PURE__ */ React.createElement("span", { style: { color: isExpanded ? "#fff" : "#e2e8f0" } }, proc.name)),
            /* @__PURE__ */ React.createElement("span", { style: { color: "#a0aec0", fontSize: "18px" } }, isExpanded ? "\u25BC" : "\u25B6")
          ),
          isExpanded && /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.procedureBody }, proc.steps.map((step, idx) => step.isHeader ? /* @__PURE__ */ React.createElement("div", { key: idx, style: emergencyStyles.stepHeader }, step.action) : /* @__PURE__ */ React.createElement("div", { key: idx, style: emergencyStyles.stepRow }, /* @__PURE__ */ React.createElement("span", { style: emergencyStyles.stepAction }, step.action), /* @__PURE__ */ React.createElement("span", { style: emergencyStyles.stepValue }, step.value))), proc.notes && /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.noteBox }, /* @__PURE__ */ React.createElement("strong", null, "\u{1F4DD} Note:"), " ", proc.notes), proc.warning && /* @__PURE__ */ React.createElement("div", { style: emergencyStyles.warningBox }, /* @__PURE__ */ React.createElement("strong", null, "\u26A0\uFE0F Warning:"), " ", proc.warning))
        );
      }))), /* @__PURE__ */ React.createElement("div", { style: {
        marginTop: "16px",
        padding: "12px",
        background: "rgba(0,0,0,0.3)",
        borderRadius: "8px",
        border: "1px dashed rgba(252,129,129,0.3)",
        textAlign: "center",
        fontSize: "11px",
        color: "#a0aec0"
      } }, /* @__PURE__ */ React.createElement("strong", { style: { color: "#fc8181" } }, "\u26A0\uFE0F Reference Only"), " \u2014 Always refer to the official POH for your specific aircraft. This checklist is a guide only."));
    };
    
    const renderSearchPlannerTab = () => {
      const handlePoiChange = (v) => { const p = spParseCoordinate(v); setSpState(s => ({ ...s, poiInput: v, poi: p, detectedGrid: p ? spDetectCapGrid(p.latDD, p.lonDD) : null })); };
      
      const generate = () => {
        const { poi, detectedGrid, spacing, groundspeed, entryCorner, initialHeading, turnDirection, numLegs, clDirection, clStartSide, poiNumTracks, poiTrackLength, poiHeading, clMode, clCreepDirection, clLegLength, clNumLegs, clG1000Mode, gpLegLength, gpNumTracks, gpUseDefaults } = spState;
        if (!poi) { alert('Enter valid POI'); return; }
        let plan;
        if (spState.patternType === 'gridParallelTrack') {
          if (!detectedGrid) { alert('Could not detect CAP grid for this location'); return; }
          plan = spGenGridParallel({ 
            poi, 
            gridInfo: detectedGrid, 
            spacing, 
            entryCorner, 
            groundspeed,
            legLengthOverride: gpUseDefaults ? null : gpLegLength,
            numTracksOverride: gpUseDefaults ? null : gpNumTracks
          });
        } else if (spState.patternType === 'creepingLine') {
          if (clMode === 'grid') {
            if (!detectedGrid) { alert('Could not detect CAP grid for this location'); return; }
            plan = spGenCreepingLine({ poi, gridInfo: detectedGrid, spacing, direction: clDirection, startSide: clStartSide, groundspeed });
          } else {
            // Custom creeping line mode (ForeFlight compatible) - uses common spacing field
            plan = spGenCreepingLineCustom({ 
              poi, 
              creepDirection: clCreepDirection || 25, 
              legLength: clLegLength || 8, 
              spacing: spacing,  // Use common Track Spacing field
              numLegs: clNumLegs || 10, 
              g1000Mode: clG1000Mode || false,
              groundspeed 
            });
          }
        } else if (spState.patternType === 'poiCenteredParallel') {
          plan = spGenPoiCenteredParallel({ poi, spacing, numTracks: poiNumTracks, trackLength: poiTrackLength, heading: poiHeading, groundspeed });
        } else {
          plan = spGenExpandingSquare({ poi, spacing, initialHeading, turnDirection, numLegs, groundspeed });
        }
        if (plan && !plan.error) {
          // Add timestamp and store plan
          plan.generatedAt = new Date().toISOString();
          plan.generatedAtZ = getZuluTimeOnly();
          plan.generatedDateZ = getZuluDate();
          setSpState(s => ({ 
            ...s, 
            lastPlan: plan,
            planHistory: [...(s.planHistory || []), plan].slice(-10) // Keep last 10 plans
          }));
          
          // Log the search plan generation as an event
          const poiCoord = spFormatCoordDDM(poi.latDD, poi.lonDD);
          const gridId = plan.gridInfo?.gridId || 'Custom';
          const eventNum = events.length > 0 ? Math.max(...events.map(e => e.eventNum || 0)) + 1 : 1;
          const totalDist = typeof plan.summary.totalDistance === 'number' ? plan.summary.totalDistance.toFixed(1) : '?';
          const totalTime = typeof plan.summary.timeMinutes === 'number' ? plan.summary.timeMinutes.toFixed(0) : '?';
          const newEvent = {
            id: Date.now(),
            eventNum,
            type: 'Search Pattern',
            dateZ: getZuluDate(),
            timeZ: getZuluTimeOnly(),
            notes: `${plan.patternType} generated for ${gridId}. POI: ${poiCoord}. ${plan.summary.numTracks || plan.summary.numLegs} tracks, ${plan.summary.spacing} NM spacing, ${totalDist} NM total, est. ${totalTime} min at ${groundspeed} kts.`
          };
          setEvents(prev => [newEvent, ...prev]);
        } else {
          alert('Error: ' + (plan && plan.error ? plan.error : 'Unknown'));
        }
      };
      
      const copyFF = () => { if (!spState.lastPlan) return; navigator.clipboard.writeText(spState.lastPlan.waypoints.map(w => w.foreflight).join(' ')); alert('ForeFlight route copied!'); };
      const exportKML = () => { if (!spState.lastPlan) return; const b = new Blob([spGenKML(spState.lastPlan)], { type: 'application/vnd.google-earth.kml+xml' }); const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'CAP_Search_' + (spState.lastPlan.gridInfo?.gridId?.replace(/\s+/g,'_') || 'Pattern') + '.kml'; a.click(); };
      const exportFPL = () => { if (!spState.lastPlan) return; const b = new Blob([spGenFPL(spState.lastPlan)], { type: 'application/xml' }); const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'CAP_SAR_' + new Date().toISOString().replace(/[^0-9]/g,'').substring(0,14) + '.fpl'; a.click(); alert('FPL file downloaded! Import via AirDrop, email, or iTunes to ForeFlight.'); };
      const openMap = () => { 
        if (!spState.lastPlan) { alert('No search plan to display. Generate a pattern first.'); return; }
        if (typeof L === 'undefined') { alert('Map library not loaded. Please refresh the page.'); return; }
        const planToShow = spState.lastPlan; // Capture the plan in closure
        setSpState(s => ({ ...s, showMap: true })); 
        setTimeout(() => { 
          try {
            if (typeof L === 'undefined') { console.error('Leaflet not available'); return; }
            if (spMap) { try { spMap.remove(); } catch(e) {} spMap = null; } 
            const el = document.getElementById('spMapDiv'); 
            if (!el) { console.error('Map container not found'); return; }
            if (!planToShow || !planToShow.waypoints || planToShow.waypoints.length === 0) {
              console.error('Invalid plan data');
              return;
            }
            
            // Get center coordinates
            let ctrLat = planToShow.poi?.latDD;
            let ctrLon = planToShow.poi?.lonDD;
            if (planToShow.dimensions) {
              ctrLat = planToShow.dimensions.centerLat || ctrLat;
              ctrLon = planToShow.dimensions.centerLon || ctrLon;
            }
            if (!ctrLat || !ctrLon) {
              // Fallback to first waypoint
              ctrLat = planToShow.waypoints[0].lat;
              ctrLon = planToShow.waypoints[0].lon;
            }
            
            spMap = L.map('spMapDiv').setView([ctrLat, ctrLon], 11); 
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: ' OSM' }).addTo(spMap); 
            
            // Standard Map Colors for high visibility on OSM:
            // Grid boundaries: magenta (#ff00ff), dashed
            // Search area: black dashed
            // Flight path: black solid
            // Waypoints: white fill with colored border
            // POI: dark red
            
            // Draw grid corners if available (for grid-based patterns) - magenta
            if (planToShow.gridInfo?.corners) { 
              const c = planToShow.gridInfo.corners; 
              L.polygon([[c.nw.lat, c.nw.lon], [c.ne.lat, c.ne.lon], [c.se.lat, c.se.lon], [c.sw.lat, c.sw.lon]], { color: '#ff00ff', weight: 3, fillOpacity: 0.05, dashArray: '8,6' }).addTo(spMap); 
            }
            
            // Draw custom search area if available (for custom creeping line)
            if (planToShow.searchArea) {
              // Draw search area polygon - black dashed
              if (planToShow.searchArea.corners && planToShow.searchArea.corners.length === 4) {
                const corners = planToShow.searchArea.corners;
                L.polygon(corners.map(c => [c.lat, c.lon]), { 
                  color: '#000000', 
                  weight: 3, 
                  fillOpacity: 0.05, 
                  fillColor: '#000000',
                  dashArray: '10,6' 
                }).addTo(spMap);
              }
              
              // Draw creeping line (axis) as a dashed line - dark red
              if (planToShow.searchArea.creepLine) {
                const cl = planToShow.searchArea.creepLine;
                L.polyline([[cl.start.lat, cl.start.lon], [cl.end.lat, cl.end.lon]], { 
                  color: '#cc0000', 
                  weight: 4, 
                  dashArray: '12,8',
                  opacity: 1.0
                }).addTo(spMap).bindPopup('Creep Direction: ' + (planToShow.dimensions?.creepDirection || '?') + '');
              }
            }
            
            // Draw flight path - black solid for high visibility
            const path = planToShow.waypoints.map(w => [w.lat, w.lon]); 
            L.polyline(path, { color: '#000000', weight: 4, opacity: 1.0 }).addTo(spMap); 
            
            // Draw waypoint markers - white fill with colored borders
            planToShow.waypoints.forEach((w, i) => {
              const isStart = i === 0;
              const isEnd = i === planToShow.waypoints.length - 1;
              L.circleMarker([w.lat, w.lon], { 
                radius: isStart ? 10 : (isEnd ? 9 : 6), 
                fillColor: '#ffffff', 
                color: isStart ? '#cc0000' : (isEnd ? '#660099' : '#000000'), 
                weight: 3, 
                fillOpacity: 1.0 
              }).addTo(spMap).bindPopup('WP' + w.number + ': ' + w.ddm + (w.note ? '<br>' + w.note : ''));
            });
            
            // Draw POI marker - dark red with white border
            if (planToShow.poi) {
              L.marker([planToShow.poi.latDD, planToShow.poi.lonDD], {
                icon: L.divIcon({
                  className: 'poi-marker',
                  html: '<div style="background:#cc0000;color:white;padding:4px 8px;border-radius:4px;font-size:12px;font-weight:bold;white-space:nowrap;border:2px solid white;box-shadow:0 2px 6px rgba(0,0,0,0.4)">POI</div>',
                  iconSize: [40, 24],
                  iconAnchor: [20, 12]
                })
              }).addTo(spMap);
            }
            
            // Fit map to show all waypoints
            if (path.length > 0) {
              spMap.fitBounds(path, { padding: [30, 30] }); 
            }
          } catch (err) {
            console.error('Map error:', err);
            alert('Error displaying map: ' + err.message);
          }
        }, 150); 
      };
      
      const setPattern = (p) => setSpState(s => ({ ...s, patternType: p }));
      const setCorner = (c) => setSpState(s => ({ ...s, entryCorner: c }));
      const setTurn = (t) => setSpState(s => ({ ...s, turnDirection: t }));
      const setClDir = (d) => setSpState(s => ({ ...s, clDirection: d }));
      const setClSide = (side) => setSpState(s => ({ ...s, clStartSide: side }));
      
      const { poi, detectedGrid, lastPlan, patternType, spacing, groundspeed, entryCorner, initialHeading, turnDirection, numLegs, clDirection, clStartSide, poiNumTracks, poiTrackLength, poiHeading, showMap: sm } = spState;
      const dims = detectedGrid ? spCalcGridDims(detectedGrid.corners) : null;
      
      const patternBtnStyle = (active) => ({ 
        padding: "12px 8px", 
        border: active ? "2px solid #805ad5" : "1px solid rgba(255,255,255,0.2)", 
        borderRadius: "8px", 
        background: active ? "linear-gradient(135deg, #805ad5, #6b46c1)" : "rgba(0,0,0,0.3)",
        color: active ? "#fff" : "#a0aec0",
        cursor: "pointer",
        fontSize: "0.85em",
        fontWeight: active ? "bold" : "normal",
        textAlign: "center",
        transition: "all 0.2s"
      });
      
      const optionBtnStyle = (active) => ({
        padding: "10px 12px",
        border: active ? "2px solid #38a169" : "1px solid rgba(255,255,255,0.2)",
        borderRadius: "6px",
        background: active ? "rgba(56,161,105,0.3)" : "rgba(0,0,0,0.2)",
        color: active ? "#68d391" : "#a0aec0",
        cursor: "pointer",
        fontSize: "0.9em",
        fontWeight: active ? "bold" : "normal",
        flex: 1,
        textAlign: "center"
      });
      
      // Reusable stepper button style
      const stepperBtnStyle = { 
        padding: "8px 12px", 
        background: "rgba(255,255,255,0.1)", 
        border: "1px solid rgba(255,255,255,0.2)", 
        borderRadius: "4px", 
        color: "#e2e8f0", 
        fontSize: "16px", 
        cursor: "pointer" 
      };
      
      // Reusable StepperInput component for iPad-friendly numeric inputs
      const StepperInput = ({ label, value, onChange, onDecrement, onIncrement, inputMode = "decimal" }) => 
        React.createElement("div", { style: styles.formGroup },
          React.createElement("label", { style: styles.label }, label),
          React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "4px" } },
            React.createElement("button", { style: stepperBtnStyle, onClick: onDecrement }, "-"),
            React.createElement("input", { 
              type: "text", 
              inputMode,
              style: { ...styles.input, flex: 1, textAlign: "center" }, 
              value, 
              onChange: e => onChange(e.target.value)
            }),
            React.createElement("button", { style: stepperBtnStyle, onClick: onIncrement }, "+")
          )
        );
      
      return React.createElement("div", { style: { padding: "10px" } },
        React.createElement("h3", { style: { color: "#b794f4", marginBottom: "15px" } }, " Search Pattern Planner"),
        
        // POI Input
        React.createElement("div", { style: styles.formGroup }, 
          React.createElement("label", { style: styles.label }, "Point of Interest (POI)"), 
          React.createElement("div", { style: { display: "flex", gap: "8px" } },
            React.createElement("input", { type: "text", style: { ...styles.input, flex: 1 }, placeholder: "DEN 25C or 39.87, -104.93 or N 39 15.7' W 104 23.1'", value: spState.poiInput, onChange: e => handlePoiChange(e.target.value) }),
            React.createElement("button", { 
              style: { ...styles.button, padding: "12px 16px", minWidth: "50px", background: "linear-gradient(135deg, #38a169, #2f855a)" }, 
              onClick: () => {
                if (navigator.geolocation) {
                  navigator.geolocation.getCurrentPosition(
                    (position) => {
                      const lat = position.coords.latitude.toFixed(6);
                      const lon = position.coords.longitude.toFixed(6);
                      handlePoiChange(lat + ", " + lon);
                    },
                    (error) => {
                      alert("GPS Error: " + error.message);
                    },
                    { enableHighAccuracy: true, timeout: 10000 }
                  );
                } else {
                  alert("GPS not available on this device");
                }
              }
            }, "")
          ),
          // Show parsed result or format help
          poi ? React.createElement("div", { style: { color: "#68d391", fontSize: "0.85em", marginTop: "5px" } }, 
            "\u2714 ", spFormatCoordDDM(poi.latDD, poi.lonDD), 
            poi.fromGrid ? React.createElement("span", { style: { color: "#90cdf4", marginLeft: "8px" } }, "(from " + poi.fromGrid + ")") : null
          ) : spState.poiInput && React.createElement("div", { style: { color: "#fc8181", fontSize: "0.8em", marginTop: "5px" } }, 
            " Could not parse. Try: DEN 25C, 39.87 -104.93, or N 39 15' W 104 23'"
          ),
          // Format examples (collapsible)
          !poi && React.createElement("details", { style: { marginTop: "8px", fontSize: "0.8em", color: "#a0aec0" } },
            React.createElement("summary", { style: { cursor: "pointer", color: "#90cdf4" } }, " Supported input formats"),
            React.createElement("div", { style: { marginTop: "6px", padding: "8px", background: "rgba(0,0,0,0.3)", borderRadius: "6px", lineHeight: "1.6" } },
              React.createElement("div", null, React.createElement("strong", null, "CAP Grid:"), " DEN 25C, DEN-25C, DEN25C, DEN 25"),
              React.createElement("div", null, React.createElement("strong", null, "Decimal:"), " 39.873, -104.936"),
              React.createElement("div", null, React.createElement("strong", null, "DDM:"), " N 39 15.733' W 104 23.134'"),
              React.createElement("div", null, React.createElement("strong", null, "DDM:"), " 39 15.733N 104 23.134W"),
              React.createElement("div", null, React.createElement("strong", null, "DMS:"), " 3915'44\"N 10423'08\"W")
            )
          )
        ),
        
        // Grid Info
        detectedGrid && React.createElement("div", { className: "sp-grid-info" }, 
          React.createElement("div", { style: { fontWeight: "bold", color: "#63b3ed", marginBottom: "8px" } }, " " + detectedGrid.gridId), 
          React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "8px", fontSize: "0.85em" } }, 
            React.createElement("div", null, "Quarter: ", React.createElement("strong", null, detectedGrid.quarterGrid)), 
            React.createElement("div", null, "Mag Var: ", React.createElement("strong", null, detectedGrid.magVariation + "" + (detectedGrid.magVariation >= 0 ? "E" : "W"))), 
            dims && React.createElement("div", null, "Size: ", React.createElement("strong", null, dims.widthNM.toFixed(2) + "  " + dims.heightNM.toFixed(2) + " NM"))
          )
        ),
        
        // Pattern Type Buttons
        React.createElement("div", { style: { marginBottom: "15px" } },
          React.createElement("label", { style: { ...styles.label, marginBottom: "8px", display: "block" } }, "Search Pattern Type"),
          React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "8px" } },
            React.createElement("button", { style: patternBtnStyle(patternType === 'gridParallelTrack'), onClick: () => setPattern('gridParallelTrack') }, " Grid Parallel", React.createElement("br"), React.createElement("span", { style: { fontSize: "0.75em", opacity: 0.8 } }, "Quarter Grid")),
            React.createElement("button", { style: patternBtnStyle(patternType === 'poiCenteredParallel'), onClick: () => setPattern('poiCenteredParallel') }, " POI Parallel", React.createElement("br"), React.createElement("span", { style: { fontSize: "0.75em", opacity: 0.8 } }, "Centered on POI")),
            React.createElement("button", { style: patternBtnStyle(patternType === 'expandingSquare'), onClick: () => setPattern('expandingSquare') }, " Expanding Sq", React.createElement("br"), React.createElement("span", { style: { fontSize: "0.75em", opacity: 0.8 } }, "Point Source")),
            React.createElement("button", { style: patternBtnStyle(patternType === 'creepingLine'), onClick: () => setPattern('creepingLine') }, "\u3030 Creeping Line", React.createElement("br"), React.createElement("span", { style: { fontSize: "0.75em", opacity: 0.8 } }, "Route/Corridor"))
          )
        ),
        
        // Common Parameters - using StepperInput component
        React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "10px", marginBottom: "15px" } }, 
          React.createElement(StepperInput, {
            label: "Track Spacing (NM)",
            value: spacing,
            onChange: v => setSpState(s => ({ ...s, spacing: parseFloat(v) || 0.5 })),
            onDecrement: () => setSpState(s => ({ ...s, spacing: Math.max(0.1, Math.round((s.spacing - 0.1) * 10) / 10) })),
            onIncrement: () => setSpState(s => ({ ...s, spacing: Math.round((s.spacing + 0.1) * 10) / 10 })),
            inputMode: "decimal"
          }),
          React.createElement(StepperInput, {
            label: "Groundspeed (kts)",
            value: groundspeed,
            onChange: v => setSpState(s => ({ ...s, groundspeed: parseInt(v) || 90 })),
            onDecrement: () => setSpState(s => ({ ...s, groundspeed: Math.max(60, s.groundspeed - 5) })),
            onIncrement: () => setSpState(s => ({ ...s, groundspeed: s.groundspeed + 5 })),
            inputMode: "numeric"
          })
        ),
        
        // POI-Centered Parallel Options - using StepperInput component
        patternType === 'poiCenteredParallel' && React.createElement("div", { style: { marginBottom: "15px" } },
          React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: "10px", marginBottom: "10px" } },
            React.createElement(StepperInput, {
              label: "# Tracks",
              value: poiNumTracks,
              onChange: v => setSpState(s => ({ ...s, poiNumTracks: parseInt(v) || 6 })),
              onDecrement: () => setSpState(s => ({ ...s, poiNumTracks: Math.max(2, (s.poiNumTracks || 6) - 1) })),
              onIncrement: () => setSpState(s => ({ ...s, poiNumTracks: Math.min(20, (s.poiNumTracks || 6) + 1) })),
              inputMode: "numeric"
            }),
            React.createElement(StepperInput, {
              label: "Track Len (NM)",
              value: poiTrackLength,
              onChange: v => setSpState(s => ({ ...s, poiTrackLength: parseFloat(v) || 3 })),
              onDecrement: () => setSpState(s => ({ ...s, poiTrackLength: Math.max(0.5, (s.poiTrackLength || 3) - 0.5) })),
              onIncrement: () => setSpState(s => ({ ...s, poiTrackLength: (s.poiTrackLength || 3) + 0.5 })),
              inputMode: "decimal"
            }),
            React.createElement(StepperInput, {
              label: "Heading ()",
              value: poiHeading,
              onChange: v => setSpState(s => ({ ...s, poiHeading: parseInt(v) || 0 })),
              onDecrement: () => setSpState(s => ({ ...s, poiHeading: (s.poiHeading - 5 + 360) % 360 })),
              onIncrement: () => setSpState(s => ({ ...s, poiHeading: (s.poiHeading + 5) % 360 })),
              inputMode: "numeric"
            })
          ),
          React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", background: "rgba(0,0,0,0.2)", padding: "8px", borderRadius: "6px" } },
            "Creates parallel tracks centered on POI. Coverage: ~", (poiNumTracks && spacing ? (poiNumTracks * spacing).toFixed(1) : "?"), "  ", poiTrackLength || "?", " NM"
          )
        ),
        
        // Parallel Track Options
        patternType === 'gridParallelTrack' && React.createElement("div", { style: { marginBottom: "15px" } },
          React.createElement("label", { style: { ...styles.label, marginBottom: "8px", display: "block" } }, "Entry Corner"),
          React.createElement("div", { style: { display: "flex", gap: "8px", marginBottom: "12px" } },
            React.createElement("button", { style: optionBtnStyle(entryCorner === 'NW'), onClick: () => setCorner('NW') }, " NW"),
            React.createElement("button", { style: optionBtnStyle(entryCorner === 'NE'), onClick: () => setCorner('NE') }, " NE"),
            React.createElement("button", { style: optionBtnStyle(entryCorner === 'SW'), onClick: () => setCorner('SW') }, " SW"),
            React.createElement("button", { style: optionBtnStyle(entryCorner === 'SE'), onClick: () => setCorner('SE') }, " SE")
          ),
          // Default/Custom mode toggle
          React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "10px", marginBottom: "12px", padding: "8px", background: "rgba(0,0,0,0.2)", borderRadius: "6px" } },
            React.createElement("label", { style: { display: "flex", alignItems: "center", gap: "8px", cursor: "pointer", flex: 1 } },
              React.createElement("input", { 
                type: "checkbox", 
                checked: !spState.gpUseDefaults, 
                onChange: e => {
                  const useCustom = e.target.checked;
                  if (useCustom && detectedGrid) {
                    // Initialize with grid defaults when switching to custom
                    const dims = spCalcGridDims(detectedGrid.corners);
                    const off = spCalcOffset(dims.widthNM, spacing);
                    setSpState(s => ({ 
                      ...s, 
                      gpUseDefaults: false, 
                      gpLegLength: Math.round(dims.heightNM * 10) / 10,
                      gpNumTracks: off.numTracks 
                    }));
                  } else {
                    setSpState(s => ({ ...s, gpUseDefaults: true }));
                  }
                },
                style: { width: "18px", height: "18px" }
              }),
              React.createElement("span", { style: { color: "#e2e8f0", fontSize: "13px" } }, "Customize leg length & track count")
            )
          ),
          // Custom inputs (only show when not using defaults)
          !spState.gpUseDefaults && React.createElement("div", { style: { background: "rgba(237,137,54,0.1)", border: "1px solid rgba(237,137,54,0.3)", borderRadius: "8px", padding: "12px", marginBottom: "10px" } },
            React.createElement("div", { style: { fontSize: "11px", color: "#f6e05e", marginBottom: "10px", fontWeight: "600" } }, "CUSTOM QUARTER GRID PARAMETERS"),
            React.createElement("div", { style: { display: "flex", gap: "12px" } },
              React.createElement(StepperInput, {
                label: "Leg Length (NM)",
                value: spState.gpLegLength || 7.5,
                onChange: v => setSpState(s => ({ ...s, gpLegLength: parseFloat(v) || 7.5 })),
                onDecrement: () => setSpState(s => ({ ...s, gpLegLength: Math.max(1, Math.round(((s.gpLegLength || 7.5) - 0.5) * 10) / 10) })),
                onIncrement: () => setSpState(s => ({ ...s, gpLegLength: Math.round(((s.gpLegLength || 7.5) + 0.5) * 10) / 10 })),
                inputMode: "decimal"
              }),
              React.createElement(StepperInput, {
                label: "# of Tracks",
                value: spState.gpNumTracks || 15,
                onChange: v => setSpState(s => ({ ...s, gpNumTracks: parseInt(v) || 15 })),
                onDecrement: () => setSpState(s => ({ ...s, gpNumTracks: Math.max(2, (s.gpNumTracks || 15) - 1) })),
                onIncrement: () => setSpState(s => ({ ...s, gpNumTracks: (s.gpNumTracks || 15) + 1 })),
                inputMode: "numeric"
              })
            ),
            React.createElement("div", { style: { fontSize: "10px", color: "#a0aec0", marginTop: "8px" } },
              " Custom values override standard quarter grid dimensions (~7.5  7.5 NM)"
            )
          ),
          // Grid info display
          detectedGrid && React.createElement("div", { style: { fontSize: "11px", color: "#a0aec0", background: "rgba(0,0,0,0.2)", padding: "8px", borderRadius: "6px" } },
            "Quarter Grid: ", detectedGrid.quarterGrid || "?", " | ",
            "Standard size: ~7.5  7.5 NM | ",
            spState.gpUseDefaults ? "Using grid defaults" : ("Custom: " + (spState.gpLegLength || 7.5) + " NM legs  " + (spState.gpNumTracks || 15) + " tracks")
          )
        ),
        
        // Creeping Line Options
        // ENHANCED Creeping Line Options
        patternType === 'creepingLine' && React.createElement("div", { style: { marginBottom: "15px" } },
          // Mode selector
          React.createElement("label", { style: { ...styles.label, marginBottom: "8px", display: "block" } }, "Definition Mode"),
          React.createElement("div", { style: { display: "flex", gap: "8px", marginBottom: "15px" } },
            React.createElement("button", { 
              style: { 
                padding: "8px 12px",
                border: spState.clMode === 'custom' ? "2px solid #ed8936" : "1px solid rgba(255,255,255,0.2)",
                borderRadius: "6px",
                background: spState.clMode === 'custom' ? "rgba(237,137,54,0.3)" : "rgba(0,0,0,0.2)",
                color: spState.clMode === 'custom' ? "#fbd38d" : "#a0aec0",
                cursor: "pointer",
                fontSize: "0.85em",
                fontWeight: spState.clMode === 'custom' ? "bold" : "normal",
                flex: 1,
                textAlign: "center"
              }, 
              onClick: () => setSpState(s => ({ ...s, clMode: 'custom' })) 
            }, " Custom Corridor"),
            React.createElement("button", { 
              style: { 
                padding: "8px 12px",
                border: spState.clMode === 'grid' ? "2px solid #ed8936" : "1px solid rgba(255,255,255,0.2)",
                borderRadius: "6px",
                background: spState.clMode === 'grid' ? "rgba(237,137,54,0.3)" : "rgba(0,0,0,0.2)",
                color: spState.clMode === 'grid' ? "#fbd38d" : "#a0aec0",
                cursor: "pointer",
                fontSize: "0.85em",
                fontWeight: spState.clMode === 'grid' ? "bold" : "normal",
                flex: 1,
                textAlign: "center"
              }, 
              onClick: () => setSpState(s => ({ ...s, clMode: 'grid' })) 
            }, " Grid-Aligned")
          ),
          
          // Grid-aligned mode (original)
          spState.clMode === 'grid' && React.createElement("div", { style: { background: "rgba(0,0,0,0.2)", borderRadius: "8px", padding: "12px", marginBottom: "12px", border: "1px solid rgba(255,255,255,0.1)" } },
            React.createElement("div", { style: { fontSize: "11px", color: "#f6e05e", marginBottom: "10px", fontWeight: "600" } }, "GRID-ALIGNED MODE"),
            React.createElement("label", { style: { ...styles.label, marginBottom: "8px", display: "block" } }, "Search Direction"),
            React.createElement("div", { style: { display: "flex", gap: "8px", marginBottom: "10px" } },
              React.createElement("button", { style: optionBtnStyle(clDirection === 0), onClick: () => setClDir(0) }, " N-S"),
              React.createElement("button", { style: optionBtnStyle(clDirection === 90), onClick: () => setClDir(90) }, " E-W")
            ),
            React.createElement("label", { style: { ...styles.label, marginBottom: "8px", display: "block" } }, "Start Side"),
            React.createElement("div", { style: { display: "flex", gap: "8px" } },
              React.createElement("button", { style: optionBtnStyle(clStartSide === 'Left'), onClick: () => setClSide('Left') }, " Left"),
              React.createElement("button", { style: optionBtnStyle(clStartSide === 'Right'), onClick: () => setClSide('Right') }, " Right")
            )
          ),
          
          // Custom corridor mode (ForeFlight SAR compatible)
          spState.clMode === 'custom' && React.createElement("div", { style: { background: "rgba(0,0,0,0.2)", borderRadius: "8px", padding: "12px", marginBottom: "12px", border: "1px solid rgba(255,255,255,0.1)" } },
            React.createElement("div", { style: { fontSize: "11px", color: "#f6e05e", marginBottom: "10px", fontWeight: "600" } }, "CUSTOM CREEPING LINE (ForeFlight SAR Compatible)"),
            
            // Creep Direction with steppers and track info
            React.createElement("div", { style: styles.formGroup },
              React.createElement("label", { style: styles.label }, "Creep Direction ()  Direction search advances"),
              React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "4px" } },
                React.createElement("button", { style: stepperBtnStyle, onClick: () => setSpState(s => ({ ...s, clCreepDirection: ((s.clCreepDirection || 25) - 5 + 360) % 360 })) }, "-"),
                React.createElement("input", { 
                  type: "text",
                  inputMode: "numeric",
                  style: { ...styles.input, flex: 1, textAlign: "center" }, 
                  value: spState.clCreepDirection || 25, 
                  onChange: e => setSpState(s => ({ ...s, clCreepDirection: parseInt(e.target.value) || 0 })) 
                }),
                React.createElement("button", { style: stepperBtnStyle, onClick: () => setSpState(s => ({ ...s, clCreepDirection: ((s.clCreepDirection || 25) + 5) % 360 })) }, "+"),
                React.createElement("span", { style: { color: "#a0aec0", fontSize: "11px", whiteSpace: "nowrap", marginLeft: "8px" } }, 
                  "Trks: ", ((spState.clCreepDirection || 25) + 270) % 360, "/", ((spState.clCreepDirection || 25) + 90) % 360, ""
                )
              )
            ),
            
            // Leg Length and Number of Legs - using StepperInput component
            React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "10px", marginBottom: "12px" } },
              React.createElement(StepperInput, {
                label: "Leg Length (NM)",
                value: spState.clLegLength,
                onChange: v => setSpState(s => ({ ...s, clLegLength: parseFloat(v) || 8 })),
                onDecrement: () => setSpState(s => ({ ...s, clLegLength: Math.max(0.5, (s.clLegLength || 8) - 0.5) })),
                onIncrement: () => setSpState(s => ({ ...s, clLegLength: (s.clLegLength || 8) + 0.5 })),
                inputMode: "decimal"
              }),
              React.createElement(StepperInput, {
                label: "Number of Legs",
                value: spState.clNumLegs || 10,
                onChange: v => setSpState(s => ({ ...s, clNumLegs: parseInt(v) || 10 })),
                onDecrement: () => setSpState(s => ({ ...s, clNumLegs: Math.max(1, (s.clNumLegs || 10) - 1) })),
                onIncrement: () => setSpState(s => ({ ...s, clNumLegs: Math.min(50, (s.clNumLegs || 10) + 1) })),
                inputMode: "numeric"
              })
            ),
            
            // G1000 Mode Toggle
            React.createElement("div", { style: { marginBottom: "12px" } },
              React.createElement("label", { style: { ...styles.label, marginBottom: "8px", display: "block" } }, "Aircraft/GPS Mode"),
              React.createElement("div", { style: { display: "flex", gap: "8px" } },
                React.createElement("button", { 
                  style: { 
                    padding: "10px 16px",
                    border: !spState.clG1000Mode ? "2px solid #38a169" : "1px solid rgba(255,255,255,0.2)",
                    borderRadius: "6px",
                    background: !spState.clG1000Mode ? "rgba(56,161,105,0.3)" : "rgba(0,0,0,0.2)",
                    color: !spState.clG1000Mode ? "#68d391" : "#a0aec0",
                    cursor: "pointer",
                    fontSize: "0.85em",
                    fontWeight: !spState.clG1000Mode ? "bold" : "normal",
                    flex: 1,
                    textAlign: "center"
                  }, 
                  onClick: () => setSpState(s => ({ ...s, clG1000Mode: false })) 
                }, " ForeFlight/CAP"),
                React.createElement("button", { 
                  style: { 
                    padding: "10px 16px",
                    border: spState.clG1000Mode ? "2px solid #ed8936" : "1px solid rgba(255,255,255,0.2)",
                    borderRadius: "6px",
                    background: spState.clG1000Mode ? "rgba(237,137,54,0.3)" : "rgba(0,0,0,0.2)",
                    color: spState.clG1000Mode ? "#fbd38d" : "#a0aec0",
                    cursor: "pointer",
                    fontSize: "0.85em",
                    fontWeight: spState.clG1000Mode ? "bold" : "normal",
                    flex: 1,
                    textAlign: "center"
                  }, 
                  onClick: () => setSpState(s => ({ ...s, clG1000Mode: true })) 
                }, " Garmin G1000")
              ),
              spState.clG1000Mode && React.createElement("div", { style: { fontSize: "11px", color: "#fbd38d", background: "rgba(237,137,54,0.15)", padding: "8px", borderRadius: "6px", marginTop: "8px", borderLeft: "3px solid #ed8936" } },
                "G1000 Mode adds an initial waypoint to create a full first leg (G1000 doesn't support half-legs)"
              )
            ),
            
            // Estimated coverage info
            React.createElement("div", { style: { fontSize: "11px", color: "#68d391", background: "rgba(56,161,105,0.15)", padding: "10px", borderRadius: "6px", marginTop: "8px" } },
              React.createElement("div", { style: { fontWeight: "600", marginBottom: "4px" } }, " Estimated Coverage:"),
              (() => {
                const numLegsVal = spState.clNumLegs || 10;
                const legLen = spState.clLegLength || 8;
                const legSpacing = spacing;  // Use common spacing field
                const corridorLen = (numLegsVal - 1) * legSpacing;
                const estTotalDist = spState.clG1000Mode 
                  ? (numLegsVal * legLen)  // G1000: all full legs
                  : (legLen / 2) + ((numLegsVal - 1) * legLen);  // ForeFlight: first half + rest full
                const estTime = groundspeed ? (estTotalDist / groundspeed) * 60 : 0;
                return React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "4px" } },
                  React.createElement("span", null, "Tracks: ", React.createElement("strong", null, numLegsVal)),
                  React.createElement("span", null, "Corridor: ", React.createElement("strong", null, corridorLen.toFixed(1), " NM")),
                  React.createElement("span", null, "Distance: ", React.createElement("strong", null, estTotalDist.toFixed(1), " NM")),
                  React.createElement("span", null, "Time: ", React.createElement("strong", null, estTime.toFixed(0), " min")),
                  React.createElement("span", null, "Area: ", React.createElement("strong", null, (legLen * corridorLen).toFixed(1), " sq NM"))
                );
              })()
            ),
            
            // Pattern description
            React.createElement("div", { style: { fontSize: "11px", color: "#90cdf4", background: "rgba(99,179,237,0.15)", padding: "10px", borderRadius: "6px", marginTop: "8px", borderLeft: "3px solid #63b3ed" } },
              React.createElement("div", { style: { fontWeight: "600", marginBottom: "4px" } }, " Pattern Structure:"),
              spState.clG1000Mode 
                ? React.createElement("div", null,
                    React.createElement("div", null, " G1000 start point added before POI"),
                    React.createElement("div", null, " First leg: full-length (", spState.clLegLength || 8, " NM) ending at POI + ", ((spState.clLegLength || 8) / 2).toFixed(1), " NM"),
                    React.createElement("div", null, " All tracks: full-length (", spState.clLegLength || 8, " NM) alternating"),
                    React.createElement("div", null, " Creep ", spacing, " NM on heading ", spState.clCreepDirection || 25, " between tracks")
                  )
                : React.createElement("div", null,
                    React.createElement("div", null, " POI is the starting corner"),
                    React.createElement("div", null, " First track: half-length (", ((spState.clLegLength || 8) / 2).toFixed(1), " NM) on hdg ", ((spState.clCreepDirection || 25) + 270) % 360, ""),
                    React.createElement("div", null, " Subsequent tracks: full-length (", spState.clLegLength || 8, " NM) alternating"),
                    React.createElement("div", null, " Creep ", spacing, " NM on heading ", spState.clCreepDirection || 25, " between tracks")
                  )
            )
          )
        ),
        
        // Expanding Square Options - using StepperInput component
        patternType === 'expandingSquare' && React.createElement("div", { style: { marginBottom: "15px" } },
          React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "10px", marginBottom: "10px" } },
            React.createElement(StepperInput, {
              label: "Initial Heading ()",
              value: initialHeading,
              onChange: v => setSpState(s => ({ ...s, initialHeading: parseInt(v) || 0 })),
              onDecrement: () => setSpState(s => ({ ...s, initialHeading: (s.initialHeading - 5 + 360) % 360 })),
              onIncrement: () => setSpState(s => ({ ...s, initialHeading: (s.initialHeading + 5) % 360 })),
              inputMode: "numeric"
            }),
            React.createElement(StepperInput, {
              label: "Number of Legs",
              value: numLegs,
              onChange: v => setSpState(s => ({ ...s, numLegs: parseInt(v) || 8 })),
              onDecrement: () => setSpState(s => ({ ...s, numLegs: Math.max(2, (s.numLegs || 8) - 2) })),
              onIncrement: () => setSpState(s => ({ ...s, numLegs: Math.min(20, (s.numLegs || 8) + 2) })),
              inputMode: "numeric"
            })
          ),
          React.createElement("label", { style: { ...styles.label, marginBottom: "8px", display: "block" } }, "Turn Direction"),
          React.createElement("div", { style: { display: "flex", gap: "8px" } },
            React.createElement("button", { style: optionBtnStyle(turnDirection === 'Right'), onClick: () => setTurn('Right') }, " Right (CW)"),
            React.createElement("button", { style: optionBtnStyle(turnDirection === 'Left'), onClick: () => setTurn('Left') }, " Left (CCW)")
          )
        ),
        
        // Generate Button
        React.createElement("button", { style: { ...styles.button, width: "100%", marginTop: "10px", marginBottom: "20px", padding: "15px", fontSize: "1.1em", background: "linear-gradient(135deg, #805ad5, #6b46c1)" }, onClick: generate }, " Generate Search Pattern"),
        
        // Results
        lastPlan && React.createElement("div", null,
          React.createElement("div", { className: "sp-coverage" }, 
            React.createElement("div", { style: { fontWeight: "bold", color: "#68d391", marginBottom: "8px" } }, "\u2714 " + lastPlan.patternType), 
            React.createElement("div", { style: { display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: "8px", fontSize: "0.85em" } }, 
              React.createElement("div", null, "Tracks: ", React.createElement("strong", null, lastPlan.summary.numTracks || lastPlan.summary.numLegs)), 
              React.createElement("div", null, "Dist: ", React.createElement("strong", null, (typeof lastPlan.summary.totalDistance === 'number' ? lastPlan.summary.totalDistance.toFixed(1) : '?') + " NM")), 
              React.createElement("div", null, "Time: ", React.createElement("strong", null, (typeof lastPlan.summary.timeMinutes === 'number' ? lastPlan.summary.timeMinutes.toFixed(0) : '?') + " min")), 
              lastPlan.coverage && lastPlan.coverage.efficiency !== undefined && React.createElement("div", null, "Eff: ", React.createElement("strong", null, lastPlan.coverage.efficiency.toFixed(1) + "%"))
            )
          ), 
          
          // Export buttons - row 1
          React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: "10px", marginTop: "15px" } }, 
            React.createElement("button", { style: { ...styles.button, ...styles.buttonSecondary, padding: "12px" }, onClick: openMap }, " Map"), 
            React.createElement("button", { style: { ...styles.button, background: "linear-gradient(135deg, #ed8936, #dd6b20)", padding: "12px" }, onClick: exportKML }, " KML"), 
            React.createElement("button", { style: { ...styles.button, background: "linear-gradient(135deg, #805ad5, #6b46c1)", padding: "12px" }, onClick: copyFF }, " Copy WPs")
          ),
          
          // Export buttons - row 2 (ForeFlight specific)
          React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "10px", marginTop: "10px" } }, 
            React.createElement("button", { 
              style: { ...styles.button, background: "linear-gradient(135deg, #3182ce, #2b6cb0)", padding: "14px", fontSize: "14px" }, 
              onClick: exportFPL 
            }, " ForeFlight FPL"),
            React.createElement("button", { 
              style: { ...styles.button, background: "linear-gradient(135deg, #38a169, #2f855a)", padding: "14px", fontSize: "14px" }, 
              onClick: () => { if (!spState.lastPlan) return; const wps = spState.lastPlan.waypoints.map(w => w.ddm).join('\\n'); navigator.clipboard.writeText(wps); alert('DDM coordinates copied!'); }
            }, " Copy DDM")
          ), 
          
          // G1000 SAR Programming Guide Button
          React.createElement("div", { style: { marginTop: "12px" } },
            React.createElement("button", { 
              style: { 
                width: "100%",
                padding: "14px 20px",
                background: "linear-gradient(135deg, #d69e2e, #b7791f)",
                border: "2px solid #ecc94b",
                borderRadius: "8px",
                color: "#fff",
                fontSize: "15px",
                fontWeight: "700",
                cursor: "pointer",
                boxShadow: "0 4px 12px rgba(214,158,46,0.4)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "10px"
              }, 
              onClick: () => setSpState(s => ({ ...s, showG1000Guide: true }))
            }, " G1000 SAR Programming Guide")
          ), 
          
          // Waypoints table
          React.createElement("div", { style: { marginTop: "15px", maxHeight: "250px", overflowY: "auto" } }, 
            React.createElement("table", { style: { width: "100%", borderCollapse: "collapse", fontSize: "0.75em" } }, 
              React.createElement("thead", null, 
                React.createElement("tr", { style: { background: "rgba(128,90,213,0.2)" } }, 
                  React.createElement("th", { style: { padding: "6px", textAlign: "left", color: "#cbd5e0" } }, "WP"), 
                  React.createElement("th", { style: { padding: "6px", textAlign: "left", color: "#cbd5e0" } }, "Coordinates"), 
                  React.createElement("th", { style: { padding: "6px", textAlign: "left", color: "#cbd5e0" } }, "ForeFlight"), 
                  React.createElement("th", { style: { padding: "6px", textAlign: "left", color: "#cbd5e0" } }, "Hdg")
                )
              ), 
              React.createElement("tbody", null, 
                lastPlan.waypoints.map((w, i) => React.createElement("tr", { key: i, style: { borderBottom: "1px solid rgba(255,255,255,0.1)" } }, 
                  React.createElement("td", { style: { padding: "4px", color: "#e2e8f0" } }, "WP" + String(w.number).padStart(2, '0')), 
                  React.createElement("td", { style: { padding: "4px", color: "#e2e8f0", fontSize: "0.9em" } }, w.ddm), 
                  React.createElement("td", { style: { padding: "4px", color: "#b794f4", fontFamily: "monospace", fontSize: "0.85em" } }, w.foreflight), 
                  React.createElement("td", { style: { padding: "4px", color: "#e2e8f0" } }, w.heading !== null ? w.heading + "" : "-")
                ))
              )
            )
          )
        ),
        
        // Map Modal
        sm && React.createElement("div", { style: { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.85)", zIndex: 1000, display: "flex", justifyContent: "center", alignItems: "center" }, onClick: () => setSpState(s => ({ ...s, showMap: false })) }, 
          React.createElement("div", { style: { background: "#1a2c42", borderRadius: "12px", padding: "20px", width: "95%", maxWidth: "800px" }, onClick: e => e.stopPropagation() }, 
            React.createElement("div", { style: { display: "flex", justifyContent: "space-between", marginBottom: "10px" } }, 
              React.createElement("h3", { style: { color: "#e2e8f0", margin: 0 } }, " Search Pattern Map"), 
              React.createElement("button", { style: { background: "rgba(229,62,62,0.3)", border: "none", color: "#fc8181", padding: "8px 12px", borderRadius: "4px", cursor: "pointer", fontSize: "1em" }, onClick: () => setSpState(s => ({ ...s, showMap: false })) }, " Close")
            ), 
            React.createElement("div", { id: "spMapDiv", style: { height: "400px", borderRadius: "8px" } })
          )
        ),
        
        // G1000 SAR Programming Guide Modal
        spState.showG1000Guide && lastPlan && React.createElement("div", { 
          style: { 
            position: "fixed", 
            top: 0, 
            left: 0, 
            right: 0, 
            bottom: 0, 
            background: "rgba(0,0,0,0.95)", 
            zIndex: 10000, 
            overflow: "auto", 
            padding: "12px" 
          }
        },
          React.createElement("div", {
            style: {
              maxWidth: "700px",
              margin: "0 auto",
              background: "linear-gradient(180deg, #1a365d, #0c1929)",
              borderRadius: "12px",
              border: "2px solid rgba(99,179,237,0.4)"
            }
          },
            // Header with Text Size Controls
            React.createElement("div", {
              style: {
                padding: "12px 16px",
                borderBottom: "2px solid rgba(255,255,255,0.15)",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                flexWrap: "wrap",
                gap: "10px",
                background: "rgba(0,0,0,0.3)",
                borderRadius: "10px 10px 0 0"
              }
            },
              React.createElement("div", null,
                React.createElement("div", { style: { fontSize: "20px", fontWeight: "700", color: "#63b3ed" }}, 
                  " G1000 SAR Programming"
                ),
                React.createElement("div", { style: { fontSize: "12px", color: "#a0aec0", marginTop: "2px" }},
                  lastPlan.patternType, "  ", lastPlan.waypoints.length, " waypoints"
                )
              ),
              React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "8px" }},
                // Text Size Controls
                React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "4px", background: "rgba(0,0,0,0.3)", padding: "4px 8px", borderRadius: "6px" }},
                  React.createElement("span", { style: { fontSize: "10px", color: "#a0aec0", marginRight: "4px" }}, "TEXT"),
                  React.createElement("button", {
                    style: {
                      width: "32px",
                      height: "32px",
                      background: (spState.g1000TextSize || 1) === 0.85 ? "rgba(99,179,237,0.3)" : "rgba(255,255,255,0.1)",
                      border: (spState.g1000TextSize || 1) === 0.85 ? "2px solid #63b3ed" : "1px solid rgba(255,255,255,0.2)",
                      borderRadius: "4px",
                      color: "#fff",
                      fontSize: "12px",
                      fontWeight: "700",
                      cursor: "pointer"
                    },
                    onClick: () => setSpState(s => ({ ...s, g1000TextSize: 0.85 })),
                    title: "Small text"
                  }, "A"),
                  React.createElement("button", {
                    style: {
                      width: "32px",
                      height: "32px",
                      background: (spState.g1000TextSize || 1) === 1 ? "rgba(99,179,237,0.3)" : "rgba(255,255,255,0.1)",
                      border: (spState.g1000TextSize || 1) === 1 ? "2px solid #63b3ed" : "1px solid rgba(255,255,255,0.2)",
                      borderRadius: "4px",
                      color: "#fff",
                      fontSize: "14px",
                      fontWeight: "700",
                      cursor: "pointer"
                    },
                    onClick: () => setSpState(s => ({ ...s, g1000TextSize: 1 })),
                    title: "Normal text"
                  }, "A"),
                  React.createElement("button", {
                    style: {
                      width: "32px",
                      height: "32px",
                      background: (spState.g1000TextSize || 1) === 1.2 ? "rgba(99,179,237,0.3)" : "rgba(255,255,255,0.1)",
                      border: (spState.g1000TextSize || 1) === 1.2 ? "2px solid #63b3ed" : "1px solid rgba(255,255,255,0.2)",
                      borderRadius: "4px",
                      color: "#fff",
                      fontSize: "16px",
                      fontWeight: "700",
                      cursor: "pointer"
                    },
                    onClick: () => setSpState(s => ({ ...s, g1000TextSize: 1.2 })),
                    title: "Large text"
                  }, "A"),
                  React.createElement("button", {
                    style: {
                      width: "32px",
                      height: "32px",
                      background: (spState.g1000TextSize || 1) === 1.4 ? "rgba(99,179,237,0.3)" : "rgba(255,255,255,0.1)",
                      border: (spState.g1000TextSize || 1) === 1.4 ? "2px solid #63b3ed" : "1px solid rgba(255,255,255,0.2)",
                      borderRadius: "4px",
                      color: "#fff",
                      fontSize: "18px",
                      fontWeight: "700",
                      cursor: "pointer"
                    },
                    onClick: () => setSpState(s => ({ ...s, g1000TextSize: 1.4 })),
                    title: "Extra large text"
                  }, "A")
                ),
                React.createElement("button", {
                  style: {
                    background: "rgba(229,62,62,0.2)",
                    border: "2px solid rgba(229,62,62,0.5)",
                    borderRadius: "8px",
                    padding: "8px 16px",
                    color: "#fc8181",
                    cursor: "pointer",
                    fontSize: "14px",
                    fontWeight: "600"
                  },
                  onClick: () => setSpState(s => ({ ...s, showG1000Guide: false }))
                }, " Close")
              )
            ),
            
            // Scrollable Content Area with dynamic text size
            React.createElement("div", {
              style: {
                fontSize: `${14 * (spState.g1000TextSize || 1)}px`,
                lineHeight: "1.6"
              }
            },
            
            // Important Note about SAR Card
            React.createElement("div", {
              style: {
                margin: "16px",
                padding: `${14 * (spState.g1000TextSize || 1)}px`,
                background: "rgba(229,62,62,0.15)",
                borderRadius: "8px",
                border: "2px solid rgba(229,62,62,0.4)"
              }
            },
              React.createElement("div", { style: { fontSize: `${13 * (spState.g1000TextSize || 1)}px`, color: "#fc8181", fontWeight: "600", lineHeight: "1.5" }},
                " IMPORTANT: The G1000 SAR feature requires a Garmin SAR unlock card inserted in the TOP SD card slot on the MFD. Without this card, the 'Search and Rescue' menu option will not appear."
              )
            ),
            
            // Pattern Summary Card
            React.createElement("div", {
              style: {
                margin: "0 16px 16px",
                padding: `${16 * (spState.g1000TextSize || 1)}px`,
                background: "rgba(246,224,94,0.1)",
                borderRadius: "8px",
                border: "2px solid rgba(246,224,94,0.4)"
              }
            },
              React.createElement("div", { style: { fontSize: `${13 * (spState.g1000TextSize || 1)}px`, color: "#f6e05e", fontWeight: "700", marginBottom: `${14 * (spState.g1000TextSize || 1)}px`, letterSpacing: "0.5px" }},
                " YOUR SEARCH PATTERN PARAMETERS"
              ),
              React.createElement("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: `${12 * (spState.g1000TextSize || 1)}px`, fontSize: `${14 * (spState.g1000TextSize || 1)}px` }},
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", padding: "8px", background: "rgba(0,0,0,0.2)", borderRadius: "4px" }},
                  React.createElement("span", { style: { color: "#a0aec0" }}, "Pattern:"),
                  React.createElement("span", { style: { color: "#68d391", fontWeight: "700" }}, 
                    lastPlan.patternType.includes("Creeping") ? "PARALLEL" : 
                    lastPlan.patternType.includes("Expanding") ? "EXP SQR" : "PARALLEL"
                  )
                ),
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", padding: "8px", background: "rgba(0,0,0,0.2)", borderRadius: "4px" }},
                  React.createElement("span", { style: { color: "#a0aec0" }}, "Legs:"),
                  React.createElement("span", { style: { color: "#68d391", fontWeight: "700" }}, 
                    lastPlan.summary.numTracks || lastPlan.summary.numLegs
                  )
                ),
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", padding: "8px", background: "rgba(0,0,0,0.2)", borderRadius: "4px" }},
                  React.createElement("span", { style: { color: "#a0aec0" }}, "Spacing:"),
                  React.createElement("span", { style: { color: "#68d391", fontWeight: "700" }}, lastPlan.summary.spacing, " NM")
                ),
                React.createElement("div", { style: { display: "flex", justifyContent: "space-between", padding: "8px", background: "rgba(0,0,0,0.2)", borderRadius: "4px" }},
                  React.createElement("span", { style: { color: "#a0aec0" }}, "Initial Hdg:"),
                  React.createElement("span", { style: { color: "#68d391", fontWeight: "700" }}, 
                    (lastPlan.waypoints[0]?.heading || lastPlan.summary.initialHeading || lastPlan.summary.heading || 360), ""
                  )
                )
              ),
              React.createElement("div", { style: { marginTop: `${14 * (spState.g1000TextSize || 1)}px`, paddingTop: `${14 * (spState.g1000TextSize || 1)}px`, borderTop: "2px solid rgba(255,255,255,0.15)" }},
                React.createElement("div", { style: { fontSize: `${12 * (spState.g1000TextSize || 1)}px`, color: "#a0aec0", marginBottom: "6px" }}, "ENTRY POINT (First Waypoint)"),
                React.createElement("div", { style: { fontFamily: "monospace", fontWeight: "700", color: "#fbd38d", fontSize: `${18 * (spState.g1000TextSize || 1)}px`, letterSpacing: "0.5px" }}, 
                  lastPlan.waypoints[0]?.ddm || "N/A"
                )
              )
            ),
            
            // FMS Knob Explanation
            React.createElement("div", {
              style: {
                margin: "0 16px 16px",
                padding: `${14 * (spState.g1000TextSize || 1)}px`,
                background: "rgba(99,179,237,0.1)",
                borderRadius: "8px",
                border: "2px solid rgba(99,179,237,0.3)"
              }
            },
              React.createElement("div", { style: { fontSize: `${13 * (spState.g1000TextSize || 1)}px`, fontWeight: "700", color: "#63b3ed", marginBottom: `${10 * (spState.g1000TextSize || 1)}px` }},
                " G1000 FMS KNOB"
              ),
              React.createElement("div", { style: { fontSize: `${13 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0", lineHeight: "1.6" }},
                "The FMS knob is located on the lower right of the MFD. It has two parts:",
                React.createElement("div", { style: { display: "grid", gridTemplateColumns: "auto 1fr", gap: `${10 * (spState.g1000TextSize || 1)}px`, marginTop: `${12 * (spState.g1000TextSize || 1)}px`, fontSize: `${14 * (spState.g1000TextSize || 1)}px` }},
                  React.createElement("span", { style: { padding: `${6 * (spState.g1000TextSize || 1)}px ${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(104,211,145,0.2)", borderRadius: "4px", color: "#68d391", fontWeight: "700" }}, "LARGE"),
                  React.createElement("span", null, "Outer knob  Moves cursor between fields"),
                  React.createElement("span", { style: { padding: `${6 * (spState.g1000TextSize || 1)}px ${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(246,224,94,0.2)", borderRadius: "4px", color: "#f6e05e", fontWeight: "700" }}, "SMALL"),
                  React.createElement("span", null, "Inner knob  Changes value at cursor")
                ),
                React.createElement("div", { style: { marginTop: `${12 * (spState.g1000TextSize || 1)}px`, display: "grid", gridTemplateColumns: "1fr 1fr", gap: `${10 * (spState.g1000TextSize || 1)}px` }},
                  React.createElement("div", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, background: "rgba(99,179,237,0.15)", borderRadius: "6px", textAlign: "center", border: "1px solid rgba(99,179,237,0.3)" }},
                    React.createElement("div", { style: { fontSize: `${12 * (spState.g1000TextSize || 1)}px`, color: "#63b3ed", fontWeight: "700" }}, " RIGHT"),
                    React.createElement("div", { style: { fontSize: `${11 * (spState.g1000TextSize || 1)}px`, color: "#a0aec0", marginTop: "2px" }}, "Clockwise")
                  ),
                  React.createElement("div", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, background: "rgba(252,129,129,0.15)", borderRadius: "6px", textAlign: "center", border: "1px solid rgba(252,129,129,0.3)" }},
                    React.createElement("div", { style: { fontSize: `${12 * (spState.g1000TextSize || 1)}px`, color: "#fc8181", fontWeight: "700" }}, "\u2190 LEFT"),
                    React.createElement("div", { style: { fontSize: `${11 * (spState.g1000TextSize || 1)}px`, color: "#a0aec0", marginTop: "2px" }}, "Counter-clockwise")
                  )
                ),
                React.createElement("div", { style: { marginTop: `${10 * (spState.g1000TextSize || 1)}px`, padding: `${10 * (spState.g1000TextSize || 1)}px`, background: "rgba(246,224,94,0.1)", borderRadius: "4px", fontSize: `${12 * (spState.g1000TextSize || 1)}px`, color: "#fbd38d" }},
                  " Tip: Push the SMALL knob (click it in) to toggle cursor on/off"
                )
              )
            ),
            
            // Instructions Container
            React.createElement("div", { style: { padding: "0 16px 16px" }},
              React.createElement("div", { style: { fontSize: `${16 * (spState.g1000TextSize || 1)}px`, fontWeight: "700", color: "#e2e8f0", marginBottom: `${14 * (spState.g1000TextSize || 1)}px` }},
                "STEP-BY-STEP INSTRUCTIONS"
              ),
              
              // Step 1
              React.createElement("div", { style: { padding: `${14 * (spState.g1000TextSize || 1)}px`, marginBottom: `${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.3)", borderRadius: "8px", borderLeft: "5px solid #63b3ed" }},
                React.createElement("div", { style: { fontSize: `${15 * (spState.g1000TextSize || 1)}px`, fontWeight: "700", color: "#63b3ed", marginBottom: `${12 * (spState.g1000TextSize || 1)}px` }},
                  "STEP 1: Open the Search and Rescue Menu"
                ),
                React.createElement("div", { style: { fontSize: `${14 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0", lineHeight: "2.2" }},
                  React.createElement("div", { style: { display: "flex", alignItems: "center", marginBottom: "6px" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "1."),
                    "Press ", React.createElement("span", { style: { display: "inline-block", padding: `${4 * (spState.g1000TextSize || 1)}px ${12 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "4px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", margin: "0 4px", fontSize: `${13 * (spState.g1000TextSize || 1)}px` }}, "FPL"), " button"
                  ),
                  React.createElement("div", { style: { display: "flex", alignItems: "center", marginBottom: "6px" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "2."),
                    "Press ", React.createElement("span", { style: { display: "inline-block", padding: `${4 * (spState.g1000TextSize || 1)}px ${12 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "4px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", margin: "0 4px", fontSize: `${13 * (spState.g1000TextSize || 1)}px` }}, "MENU"), " button"
                  ),
                  React.createElement("div", { style: { display: "flex", alignItems: "center", marginBottom: "6px" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "3."),
                    "Turn ", React.createElement("span", { style: { color: "#68d391", fontWeight: "700" }}, "LARGE"), " knob ", React.createElement("span", { style: { color: "#63b3ed", fontWeight: "700" }}, " RIGHT"), " to scroll to ", React.createElement("span", { style: { color: "#68d391", fontWeight: "700" }}, "\"Search and Rescue\"")
                  ),
                  React.createElement("div", { style: { display: "flex", alignItems: "center" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "4."),
                    "Press ", React.createElement("span", { style: { display: "inline-block", padding: `${4 * (spState.g1000TextSize || 1)}px ${12 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "4px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", margin: "0 4px", fontSize: `${13 * (spState.g1000TextSize || 1)}px` }}, "ENTER"), " to open SAR menu"
                  )
                )
              ),
              
              // Step 2
              React.createElement("div", { style: { padding: `${14 * (spState.g1000TextSize || 1)}px`, marginBottom: `${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.3)", borderRadius: "8px", borderLeft: "5px solid #63b3ed" }},
                React.createElement("div", { style: { fontSize: `${15 * (spState.g1000TextSize || 1)}px`, fontWeight: "700", color: "#63b3ed", marginBottom: `${12 * (spState.g1000TextSize || 1)}px` }},
                  "STEP 2: Enter the Starting Waypoint"
                ),
                React.createElement("div", { style: { fontSize: `${14 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0", lineHeight: "1.8" }},
                  "The ", React.createElement("strong", null, "WAYPOINT"), " field will be highlighted. Choose one method:",
                  
                  // Option A - Direct coordinate entry
                  React.createElement("div", { style: { marginTop: `${12 * (spState.g1000TextSize || 1)}px`, marginBottom: `${10 * (spState.g1000TextSize || 1)}px`, padding: `${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.25)", borderRadius: "6px", border: "1px solid rgba(246,224,94,0.3)" }},
                    React.createElement("div", { style: { color: "#f6e05e", fontWeight: "700", marginBottom: `${8 * (spState.g1000TextSize || 1)}px`, fontSize: `${14 * (spState.g1000TextSize || 1)}px` }}, "Option A: Enter coordinates directly"),
                    React.createElement("div", { style: { fontSize: `${13 * (spState.g1000TextSize || 1)}px`, lineHeight: "2.0" }},
                      " Turn ", React.createElement("span", { style: { color: "#f6e05e", fontWeight: "700" }}, "SMALL"), " knob ", React.createElement("span", { style: { color: "#63b3ed", fontWeight: "700" }}, " RIGHT"), " to select each character", React.createElement("br"),
                      " Turn ", React.createElement("span", { style: { color: "#68d391", fontWeight: "700" }}, "LARGE"), " knob ", React.createElement("span", { style: { color: "#63b3ed", fontWeight: "700" }}, " RIGHT"), " to move to next position", React.createElement("br"),
                      " Enter: ", React.createElement("span", { style: { fontFamily: "monospace", color: "#fbd38d", fontWeight: "700", fontSize: `${15 * (spState.g1000TextSize || 1)}px` }}, lastPlan.waypoints[0]?.ddm || "N/A"), React.createElement("br"),
                      " Press ", React.createElement("span", { style: { display: "inline-block", padding: `${3 * (spState.g1000TextSize || 1)}px ${10 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "4px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", fontSize: `${12 * (spState.g1000TextSize || 1)}px` }}, "ENTER"), " to accept"
                    )
                  ),
                  
                  // Option B - Use existing waypoint
                  React.createElement("div", { style: { marginBottom: `${10 * (spState.g1000TextSize || 1)}px`, padding: `${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.25)", borderRadius: "6px", border: "1px solid rgba(104,211,145,0.3)" }},
                    React.createElement("div", { style: { color: "#68d391", fontWeight: "700", marginBottom: `${8 * (spState.g1000TextSize || 1)}px`, fontSize: `${14 * (spState.g1000TextSize || 1)}px` }}, "Option B: Use existing waypoint or navaid"),
                    React.createElement("div", { style: { fontSize: `${13 * (spState.g1000TextSize || 1)}px`, lineHeight: "1.8" }},
                      " Type identifier (airport, VOR, intersection, or User WPT)", React.createElement("br"),
                      " Or turn ", React.createElement("span", { style: { color: "#f6e05e", fontWeight: "700" }}, "SMALL"), " knob ", React.createElement("span", { style: { color: "#fc8181", fontWeight: "700" }}, "\u2190 LEFT"), " for NEAREST/RECENT lists"
                    )
                  ),
                  
                  // Option C - Mark current position
                  React.createElement("div", { style: { padding: `${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.25)", borderRadius: "6px", border: "1px solid rgba(183,148,244,0.3)" }},
                    React.createElement("div", { style: { color: "#b794f4", fontWeight: "700", marginBottom: `${8 * (spState.g1000TextSize || 1)}px`, fontSize: `${14 * (spState.g1000TextSize || 1)}px` }}, "Option C: Create waypoint at map position"),
                    React.createElement("div", { style: { fontSize: `${13 * (spState.g1000TextSize || 1)}px`, lineHeight: "2.0" }},
                      "1. Press ", React.createElement("span", { style: { color: "#63b3ed", fontWeight: "700" }}, "SMALL Range knob"), " (on MFD)", React.createElement("br"),
                      "2. Move pointer using joystick-like motion", React.createElement("br"),
                      "3. Press ", React.createElement("span", { style: { display: "inline-block", padding: `${2 * (spState.g1000TextSize || 1)}px ${8 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "3px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", fontSize: `${11 * (spState.g1000TextSize || 1)}px` }}, "ENTER"), "  \"Create User WPT\"", React.createElement("br"),
                      "4. Name it  ", React.createElement("span", { style: { display: "inline-block", padding: `${2 * (spState.g1000TextSize || 1)}px ${8 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "3px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", fontSize: `${11 * (spState.g1000TextSize || 1)}px` }}, "ENTER")
                    )
                  )
                )
              ),
              
              // Step 3
              React.createElement("div", { style: { padding: `${14 * (spState.g1000TextSize || 1)}px`, marginBottom: `${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.3)", borderRadius: "8px", borderLeft: "5px solid #63b3ed" }},
                React.createElement("div", { style: { fontSize: `${15 * (spState.g1000TextSize || 1)}px`, fontWeight: "700", color: "#63b3ed", marginBottom: `${12 * (spState.g1000TextSize || 1)}px` }},
                  "STEP 3: Select the Pattern Type"
                ),
                React.createElement("div", { style: { fontSize: `${14 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0", lineHeight: "2.0" }},
                  React.createElement("div", { style: { display: "flex", alignItems: "center", marginBottom: "6px" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "1."),
                    "After ENTER, cursor moves to ", React.createElement("strong", null, "PATTERN"), " field"
                  ),
                  React.createElement("div", { style: { display: "flex", alignItems: "center", marginBottom: "6px", flexWrap: "wrap", gap: "4px" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "2."),
                    "Turn ", React.createElement("span", { style: { color: "#f6e05e", fontWeight: "700" }}, "SMALL"), " knob ", 
                    React.createElement("span", { style: { color: "#63b3ed", fontWeight: "700" }}, " RIGHT"), " or ",
                    React.createElement("span", { style: { color: "#fc8181", fontWeight: "700" }}, "\u2190 LEFT"), " to: ",
                    React.createElement("span", { style: { color: "#68d391", fontWeight: "700", fontSize: `${15 * (spState.g1000TextSize || 1)}px` }}, 
                      lastPlan.patternType.includes("Creeping") ? "PARALLEL" : 
                      lastPlan.patternType.includes("Expanding") ? "EXP SQR" : "PARALLEL"
                    )
                  ),
                  React.createElement("div", { style: { display: "flex", alignItems: "center" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "3."),
                    "Press ", React.createElement("span", { style: { display: "inline-block", padding: `${3 * (spState.g1000TextSize || 1)}px ${10 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "4px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", fontSize: `${12 * (spState.g1000TextSize || 1)}px` }}, "ENTER"), " to confirm"
                  )
                ),
                React.createElement("div", { style: { fontSize: `${12 * (spState.g1000TextSize || 1)}px`, color: "#a0aec0", marginTop: `${10 * (spState.g1000TextSize || 1)}px`, padding: `${10 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.2)", borderRadius: "4px", lineHeight: "1.8" }},
                  React.createElement("strong", null, "Pattern options:"), React.createElement("br"),
                  " PARALLEL  Rectangle grid (most common)", React.createElement("br"),
                  " SECTOR  Triangle pattern, 3 sectors", React.createElement("br"),
                  " EXP SQR  Expanding square from center"
                )
              ),
              
              // Step 4
              React.createElement("div", { style: { padding: `${14 * (spState.g1000TextSize || 1)}px`, marginBottom: `${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.3)", borderRadius: "8px", borderLeft: "5px solid #63b3ed" }},
                React.createElement("div", { style: { fontSize: `${15 * (spState.g1000TextSize || 1)}px`, fontWeight: "700", color: "#63b3ed", marginBottom: `${12 * (spState.g1000TextSize || 1)}px` }},
                  "STEP 4: Set Pattern Parameters"
                ),
                React.createElement("div", { style: { fontSize: `${14 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0", marginBottom: `${12 * (spState.g1000TextSize || 1)}px` }},
                  "For each field: Turn ", React.createElement("span", { style: { color: "#f6e05e", fontWeight: "700" }}, "SMALL"), " knob to change  Press ", React.createElement("span", { style: { display: "inline-block", padding: `${3 * (spState.g1000TextSize || 1)}px ${10 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "4px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", fontSize: `${12 * (spState.g1000TextSize || 1)}px` }}, "ENTER"), " to advance"
                ),
                React.createElement("div", { style: { background: "rgba(0,0,0,0.3)", borderRadius: "6px", overflow: "hidden" }},
                  React.createElement("table", { style: { width: "100%", borderCollapse: "collapse", fontSize: `${14 * (spState.g1000TextSize || 1)}px` }},
                    React.createElement("thead", null,
                      React.createElement("tr", { style: { background: "rgba(99,179,237,0.2)" }},
                        React.createElement("th", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "left", color: "#63b3ed", fontWeight: "700" }}, "Field"),
                        React.createElement("th", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#63b3ed", fontWeight: "700" }}, "Set To"),
                        React.createElement("th", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#a0aec0", fontWeight: "400", fontSize: `${11 * (spState.g1000TextSize || 1)}px` }}, "Range")
                      )
                    ),
                    React.createElement("tbody", null,
                      React.createElement("tr", { style: { borderTop: "1px solid rgba(255,255,255,0.1)" }},
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0" }}, "INITIAL DTK"),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#68d391", fontWeight: "700", fontFamily: "monospace", fontSize: `${15 * (spState.g1000TextSize || 1)}px` }}, 
                          (lastPlan.waypoints[0]?.heading || lastPlan.summary.initialHeading || lastPlan.summary.heading || 360), ""
                        ),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#a0aec0", fontSize: `${11 * (spState.g1000TextSize || 1)}px` }}, "1-360")
                      ),
                      React.createElement("tr", { style: { borderTop: "1px solid rgba(255,255,255,0.1)" }},
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0" }}, "INITIAL TURN"),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#68d391", fontWeight: "700", fontFamily: "monospace", fontSize: `${15 * (spState.g1000TextSize || 1)}px` }}, 
                          // Derive turn direction based on pattern type
                          lastPlan.summary.turnDirection || 
                          (lastPlan.summary.startSide === 'Left' ? 'RIGHT' : lastPlan.summary.startSide === 'Right' ? 'LEFT' : null) ||
                          (lastPlan.summary.entryCorner?.includes('W') ? 'RIGHT' : lastPlan.summary.entryCorner?.includes('E') ? 'LEFT' : null) ||
                          "RIGHT"
                        ),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#a0aec0", fontSize: `${11 * (spState.g1000TextSize || 1)}px` }}, "Left/Right")
                      ),
                      !lastPlan.patternType.includes("Expanding") && React.createElement("tr", { style: { borderTop: "1px solid rgba(255,255,255,0.1)" }},
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0" }}, 
                          "LEG LENGTH",
                          React.createElement("span", { style: { color: "#fc8181", fontSize: `${10 * (spState.g1000TextSize || 1)}px`, marginLeft: "4px" }}, "")
                        ),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#68d391", fontWeight: "700", fontFamily: "monospace", fontSize: `${15 * (spState.g1000TextSize || 1)}px` }}, 
                          (lastPlan.summary.legLength || lastPlan.summary.trackLength || lastPlan.dimensions?.corridorLength || lastPlan.dimensions?.actualHeight || 15.0).toFixed ? (lastPlan.summary.legLength || lastPlan.summary.trackLength || lastPlan.dimensions?.corridorLength || lastPlan.dimensions?.actualHeight || 15.0).toFixed(1) : (lastPlan.summary.legLength || lastPlan.summary.trackLength || lastPlan.dimensions?.corridorLength || lastPlan.dimensions?.actualHeight || 15.0), " NM"
                        ),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#a0aec0", fontSize: `${11 * (spState.g1000TextSize || 1)}px` }}, 
                          lastPlan.patternType.includes("Sector") ? "0.5-10 NM" : "1-99.9 NM"
                        )
                      ),
                      React.createElement("tr", { style: { borderTop: "1px solid rgba(255,255,255,0.1)" }},
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0" }}, "SPACING"),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#68d391", fontWeight: "700", fontFamily: "monospace", fontSize: `${15 * (spState.g1000TextSize || 1)}px` }}, 
                          lastPlan.summary.spacing, " NM"
                        ),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#a0aec0", fontSize: `${11 * (spState.g1000TextSize || 1)}px` }}, "0.5-9.9 NM")
                      ),
                      !lastPlan.patternType.includes("Sector") && React.createElement("tr", { style: { borderTop: "1px solid rgba(255,255,255,0.1)" }},
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0" }}, "NUMBER OF LEGS"),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#68d391", fontWeight: "700", fontFamily: "monospace", fontSize: `${15 * (spState.g1000TextSize || 1)}px` }}, 
                          lastPlan.summary.numTracks || lastPlan.summary.numLegs
                        ),
                        React.createElement("td", { style: { padding: `${10 * (spState.g1000TextSize || 1)}px`, textAlign: "right", color: "#a0aec0", fontSize: `${11 * (spState.g1000TextSize || 1)}px` }}, 
                          lastPlan.patternType.includes("Expanding") ? "1-60" : "1-40"
                        )
                      )
                    )
                  )
                ),
                // Important note about leg length
                !lastPlan.patternType.includes("Expanding") && React.createElement("div", { style: { marginTop: `${10 * (spState.g1000TextSize || 1)}px`, padding: `${10 * (spState.g1000TextSize || 1)}px`, background: "rgba(252,129,129,0.15)", borderRadius: "4px", border: "2px solid rgba(252,129,129,0.4)" }},
                  React.createElement("div", { style: { fontSize: `${12 * (spState.g1000TextSize || 1)}px`, color: "#fc8181", fontWeight: "600" }},
                    " IMPORTANT: Leg Length is the FULL length of each leg, not half!"
                  )
                )
              ),
              
              // Step 5
              React.createElement("div", { style: { padding: `${14 * (spState.g1000TextSize || 1)}px`, marginBottom: `${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.3)", borderRadius: "8px", borderLeft: "5px solid #68d391" }},
                React.createElement("div", { style: { fontSize: `${15 * (spState.g1000TextSize || 1)}px`, fontWeight: "700", color: "#68d391", marginBottom: `${12 * (spState.g1000TextSize || 1)}px` }},
                  "STEP 5: Activate the Search Pattern"
                ),
                React.createElement("div", { style: { fontSize: `${14 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0", lineHeight: "2.2" }},
                  React.createElement("div", { style: { display: "flex", alignItems: "center", marginBottom: "6px" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "1."),
                    "After parameters, cursor is on ", React.createElement("strong", { style: { color: "#68d391" }}, "\"ACTIVATE SAR?\"")
                  ),
                  React.createElement("div", { style: { display: "flex", alignItems: "center", marginBottom: "6px" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "2."),
                    "Press ", React.createElement("span", { style: { display: "inline-block", padding: `${4 * (spState.g1000TextSize || 1)}px ${12 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "4px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", margin: "0 4px", fontSize: `${13 * (spState.g1000TextSize || 1)}px` }}, "ENTER"), " to activate"
                  ),
                  React.createElement("div", { style: { display: "flex", alignItems: "center" }},
                    React.createElement("span", { style: { color: "#a0aec0", width: `${28 * (spState.g1000TextSize || 1)}px`, fontWeight: "600" }}, "3."),
                    "SAR Flight Plan is now created and active!"
                  )
                ),
                React.createElement("div", { style: { marginTop: `${12 * (spState.g1000TextSize || 1)}px`, padding: `${10 * (spState.g1000TextSize || 1)}px`, background: "rgba(104,211,145,0.15)", borderRadius: "4px", border: "2px solid rgba(104,211,145,0.4)" }},
                  React.createElement("div", { style: { fontSize: `${12 * (spState.g1000TextSize || 1)}px`, color: "#68d391", lineHeight: "1.8" }},
                    "\u2714 Pattern appears on Navigation Map page", React.createElement("br"),
                    "\u2714 Press ", React.createElement("span", { style: { display: "inline-block", padding: `${2 * (spState.g1000TextSize || 1)}px ${8 * (spState.g1000TextSize || 1)}px`, background: "linear-gradient(180deg, #4a5568, #2d3748)", borderRadius: "3px", fontFamily: "monospace", fontWeight: "700", color: "#f6e05e", border: "1px solid #718096", fontSize: `${10 * (spState.g1000TextSize || 1)}px` }}, "CLR"), " for 2 seconds to return to map"
                  )
                )
              ),
              
              // Step 6 - Flying the Pattern
              React.createElement("div", { style: { padding: `${14 * (spState.g1000TextSize || 1)}px`, marginBottom: `${12 * (spState.g1000TextSize || 1)}px`, background: "rgba(0,0,0,0.3)", borderRadius: "8px", borderLeft: "5px solid #805ad5" }},
                React.createElement("div", { style: { fontSize: `${15 * (spState.g1000TextSize || 1)}px`, fontWeight: "700", color: "#b794f4", marginBottom: `${12 * (spState.g1000TextSize || 1)}px` }},
                  "STEP 6: Flying the Search Pattern"
                ),
                React.createElement("div", { style: { fontSize: `${14 * (spState.g1000TextSize || 1)}px`, color: "#e2e8f0", lineHeight: "2.0" }},
                  React.createElement("div", { style: { marginBottom: "8px" }}, 
                    " Waypoints appear as ", React.createElement("strong", { style: { color: "#fbd38d" }}, "SAR-01, SAR-02, SAR-03"), ", etc."
                  ),
                  React.createElement("div", { style: { marginBottom: "8px" }}, 
                    " Fly to each numbered waypoint in sequence"
                  ),
                  React.createElement("div", { style: { marginBottom: "8px" }}, 
                    " ", React.createElement("strong", null, "Dashed turn leader lines"), " show your turn path at corners"
                  ),
                  React.createElement("div", null, 
                    " Pattern can be hand-flown or coupled to GFC 700 autopilot"
                  )
                )
              ),
              
              // All Waypoints Reference
              React.createElement("div", { 
                style: { 
                  marginTop: `${10 * (spState.g1000TextSize || 1)}px`,
                  padding: `${14 * (spState.g1000TextSize || 1)}px`,
                  background: "rgba(0,0,0,0.25)",
                  borderRadius: "8px",
                  border: "2px solid rgba(255,255,255,0.15)"
                }
              },
                React.createElement("div", { style: { fontSize: `${13 * (spState.g1000TextSize || 1)}px`, fontWeight: "700", color: "#f6e05e", marginBottom: `${10 * (spState.g1000TextSize || 1)}px`, display: "flex", justifyContent: "space-between", alignItems: "center" }},
                  React.createElement("span", null, " ALL WAYPOINTS (G1000 DDM Format)"),
                  React.createElement("span", { style: { color: "#a0aec0", fontWeight: "400" }}, lastPlan.waypoints.length, " total")
                ),
                React.createElement("div", { style: { maxHeight: "200px", overflowY: "auto", fontSize: `${13 * (spState.g1000TextSize || 1)}px`, fontFamily: "monospace" }},
                  lastPlan.waypoints.map((wp, i) => 
                    React.createElement("div", { 
                      key: i, 
                      style: { 
                        padding: `${8 * (spState.g1000TextSize || 1)}px ${10 * (spState.g1000TextSize || 1)}px`, 
                        background: i % 2 === 0 ? "rgba(0,0,0,0.25)" : "transparent",
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "center",
                        borderRadius: "4px"
                      }
                    },
                      React.createElement("span", { style: { color: "#63b3ed", fontWeight: "700" }}, "WP", String(wp.number).padStart(2, '0')),
                      React.createElement("span", { style: { color: "#68d391", fontSize: `${14 * (spState.g1000TextSize || 1)}px` }}, wp.ddm),
                      React.createElement("span", { style: { color: "#fbd38d", minWidth: "50px", textAlign: "right" }}, wp.heading !== null ? wp.heading + "" : "-")
                    )
                  )
                )
              )
            )
            ) // Close content wrapper
          )
        )
      );
    };
    
const tabs = [
      { id: "home", label: "Home", icon: "", isHome: true },
      { id: "mission", label: "Mission", icon: "\u{1F4CB}" },
      { id: "times", label: "Times", icon: "\u23F1\uFE0F" },
      { id: "events", label: "Events", icon: "\u{1F4CD}" },
      { id: "crosshair", label: "Target", icon: "\u{1F3AF}", isTarget: true },
      { id: "eltAssist", label: "ELT", icon: "\u{1F4E1}", isElt: true },
      { id: "searchPlanner", label: "Search", icon: "\u{1F9ED}", isSearch: true },
      { id: "commandTools", label: "Command", icon: "\u{1F4CA}", isCommand: true },
      { id: "radio", label: "Radio", icon: "\u{1F4E2}", isRadio: true },
      { id: "coComms", label: "CO Comms", icon: "\u{1F4E1}", isComms: true },
      { id: "emergency", label: "Emergency", icon: "\u{1F6A8}", isEmergency: true },
      { id: "reference", label: "Reference", icon: "\u{1F4DA}" },
      { id: "proficiency", label: "Profile", icon: "\u2705", isProfile: true },
      { id: "demo", label: "Demos", icon: "\u{1F3AC}", isDemo: true }
    ];
    
    // Format ops timer remaining
    const formatOpsTimer = () => {
      if (opsTimerRemaining === null) return null;
      const mins = Math.floor(opsTimerRemaining / 60);
      const secs = opsTimerRemaining % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    };
    const opsTimerDisplay = formatOpsTimer();
    const opsTimerWarning = opsTimerRemaining !== null && opsTimerRemaining <= 120; // 2 min warning
    const opsTimerExpired = opsTimerRemaining !== null && opsTimerRemaining === 0;
    
    return /* @__PURE__ */ React.createElement("div", { style: styles.container }, 
      /* @__PURE__ */ React.createElement("header", { style: styles.header }, 
        /* @__PURE__ */ React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "12px" } },
          /* @__PURE__ */ React.createElement("button", { 
            style: { 
              background: activeTab === "home" ? "linear-gradient(135deg, #dd6b20, #c05621)" : "rgba(0,0,0,0.3)",
              border: activeTab === "home" ? "2px solid #f6ad55" : "1px solid rgba(255,255,255,0.2)",
              borderRadius: "10px",
              padding: "10px 12px",
              cursor: "pointer",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              fontSize: "20px",
              color: "#fff",
              minWidth: "48px",
              minHeight: "48px"
            },
            onClick: () => switchTab("home"),
            title: "Go to Home Screen"
          }, "\u{1F3E0}"),
          /* @__PURE__ */ React.createElement("div", { style: { ...styles.logo, cursor: "pointer" }, onClick: () => switchTab("home") }, 
            /* @__PURE__ */ React.createElement("img", { 
              src: "https://www.gocivilairpatrol.com/local/public/shared/assets/images/websites/CAP-2017-logo-horizontal-optimized-d73f31575f10142a77f0888cdfb36256.png", 
              alt: "Civil Air Patrol",
              style: { height: "40px", maxWidth: "120px", objectFit: "contain" },
              onError: (e) => { e.target.style.display = 'none'; e.target.nextSibling.style.display = 'flex'; }
            }),
            /* @__PURE__ */ React.createElement("div", { style: { ...styles.logoCircle, display: "none" } }, "CAP"), 
            /* @__PURE__ */ React.createElement("div", null, 
              /* @__PURE__ */ React.createElement("div", { style: styles.title }, "Mission Aircrew Toolkit"), 
              /* @__PURE__ */ React.createElement("div", { style: styles.subtitle }, "CIVIL AIR PATROL")
            )
          )
        ), 
        /* @__PURE__ */ React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "8px" }},
          // Ops Normal Timer
          opsTimerEnabled && React.createElement("div", { 
            style: { 
              ...styles.zuluTime, 
              background: opsTimerExpired ? "#e53e3e" : opsTimerWarning ? "#dd6b20" : "rgba(0,0,0,0.3)",
              color: opsTimerExpired || opsTimerWarning ? "#fff" : "#68d391",
              cursor: "pointer",
              minWidth: "70px",
              textAlign: "center"
            },
            className: opsTimerExpired ? "timer-warning" : "",
            onClick: () => {
              setOpsTimerLastReset(Date.now());
              setOpsTimerRemaining(opsTimerMinutes * 60);
            },
            title: "Click to reset OPS NORMAL timer"
          }, 
            opsTimerExpired ? "OPS!" : opsTimerDisplay || "OPS"
          ),
          // Night Mode Toggle
          React.createElement("button", {
            style: {
              ...styles.zuluTime,
              background: nightMode ? "#7c2d12" : "rgba(0,0,0,0.3)",
              color: nightMode ? "#fca5a5" : "#a0aec0",
              cursor: "pointer",
              border: nightMode ? "1px solid #dc2626" : "1px solid rgba(255,255,255,0.1)",
              padding: "6px 10px"
            },
            onClick: () => setNightMode(!nightMode),
            title: nightMode ? "Switch to Day Mode" : "Switch to Night Mode"
          }, nightMode ? "" : ""),
          // Text Size Toggle
          React.createElement("button", {
            style: {
              ...styles.zuluTime,
              background: textSize !== 'normal' ? "rgba(99,179,237,0.3)" : "rgba(0,0,0,0.3)",
              color: textSize !== 'normal' ? "#63b3ed" : "#a0aec0",
              cursor: "pointer",
              border: textSize !== 'normal' ? "1px solid #63b3ed" : "1px solid rgba(255,255,255,0.1)",
              padding: "6px 10px",
              fontSize: ts("12")
            },
            onClick: () => {
              const sizes = ['normal', 'large', 'xlarge'];
              const currentIndex = sizes.indexOf(textSize);
              setTextSize(sizes[(currentIndex + 1) % sizes.length]);
            },
            title: `Text Size: ${textSize.toUpperCase()} - Click to change`
          }, textSize === 'normal' ? "A" : textSize === 'large' ? "A+" : "A++"),
          // Zulu Clock
          React.createElement("div", { style: styles.zuluTime }, zuluClock, "Z")
        )
      ), 
      activeTab !== "home" && /* @__PURE__ */ React.createElement("nav", { style: styles.tabs }, tabs.filter(tab => tab.id !== "home").map((tab) => /* @__PURE__ */ React.createElement(
      "button",
      {
        key: tab.id,
        style: {
          ...styles.tab,
          ...activeTab === tab.id ? styles.tabActive : styles.tabInactive,
          ...tab.isTarget && activeTab !== tab.id ? {
            background: "linear-gradient(135deg, rgba(56,161,105,0.4), rgba(47,133,90,0.3))",
            border: "1px solid #38a169",
            color: "#68d391"
          } : {},
          ...tab.isTarget && activeTab === tab.id ? {
            background: "linear-gradient(135deg, #38a169, #2f855a)",
            boxShadow: "0 4px 12px rgba(56,161,105,0.5)"
          } : {},
          ...tab.isElt && activeTab !== tab.id ? {
            background: "linear-gradient(135deg, rgba(237,137,54,0.4), rgba(221,107,32,0.3))",
            border: "1px solid #ed8936",
            color: "#fbd38d"
          } : {},
          ...tab.isElt && activeTab === tab.id ? {
            background: "linear-gradient(135deg, #ed8936, #dd6b20)",
            boxShadow: "0 4px 12px rgba(237,137,54,0.5)"
          } : {},
          ...tab.isRadio && activeTab !== tab.id ? {
            background: "linear-gradient(135deg, rgba(99,179,237,0.3), rgba(49,130,206,0.2))",
            border: "1px solid rgba(99,179,237,0.5)",
            color: "#63b3ed"
          } : {},
          ...tab.isRadio && activeTab === tab.id ? {
            background: "linear-gradient(135deg, #3182ce, #2b6cb0)",
            boxShadow: "0 4px 12px rgba(49,130,206,0.5)"
          } : {},
          ...tab.isEmergency && activeTab !== tab.id ? {
            background: "linear-gradient(135deg, rgba(197,48,48,0.4), rgba(155,44,44,0.3))",
            border: "1px solid #c53030",
            color: "#fc8181"
          } : {},
          ...tab.isEmergency && activeTab === tab.id ? {
            background: "linear-gradient(135deg, #c53030, #9b2c2c)",
            boxShadow: "0 4px 12px rgba(197,48,48,0.5)"
          } : {},
          ...tab.isComms && activeTab !== tab.id ? {
            background: "linear-gradient(135deg, rgba(246,224,94,0.3), rgba(237,137,54,0.2))",
            border: "1px solid rgba(246,224,94,0.5)",
            color: "#f6e05e"
          } : {},
          ...tab.isComms && activeTab === tab.id ? {
            background: "linear-gradient(135deg, #d69e2e, #b7791f)",
            boxShadow: "0 4px 12px rgba(214,158,46,0.5)"
          } : {},
          ...tab.isSearch && activeTab !== tab.id ? {
            background: "linear-gradient(135deg, rgba(128,90,213,0.3), rgba(107,70,193,0.2))",
            border: "1px solid rgba(128,90,213,0.5)",
            color: "#b794f4"
          } : {},
          ...tab.isSearch && activeTab === tab.id ? {
            background: "linear-gradient(135deg, #805ad5, #6b46c1)",
            boxShadow: "0 4px 12px rgba(128,90,213,0.5)"
          } : {}
        },
        onClick: () => {
          if (tab.isComms && !commsUnlocked) {
            const code = prompt("Enter passcode to view Communications");
            if (code === null) return;
            if (String(code).trim() !== "1942") {
              alert("Incorrect passcode.");
              return;
            }
            setCommsUnlocked(true);
          }
          switchTab(tab.id);
        }
      },
      tab.icon,
      " ",
      tab.label
    ))), /* @__PURE__ */ React.createElement("main", { style: styles.content }, activeTab === "home" && renderHomeTab(), activeTab === "demo" && renderDemoTab(), activeTab === "mission" && renderMissionTab(), activeTab === "times" && renderTimesTab(), activeTab === "events" && renderEventsTab(), activeTab === "proficiency" && renderProficiencyTab(), activeTab === "crosshair" && renderCrosshairTab(), activeTab === "eltAssist" && renderEltAssistTab(), activeTab === "radio" && renderRadioTab(), activeTab === "coComms" && renderCoCommsTab(), activeTab === "emergency" && renderEmergencyTab(), activeTab === "reference" && renderReferenceTab(), activeTab === "searchPlanner" && renderSearchPlannerTab(), activeTab === "commandTools" && renderCommandToolsTab()), activeTab !== "home" && activeTab !== "demo" && /* @__PURE__ */ React.createElement("footer", { style: styles.footer }, /* @__PURE__ */ React.createElement("button", { style: { ...styles.button, ...styles.buttonSecondary }, onClick: clearAllData }, "Clear"), /* @__PURE__ */ React.createElement("button", { style: { ...styles.button, background: "linear-gradient(135deg, #805ad5, #6b46c1)" }, onClick: () => setShowShareModal(true) }, "\u{1F4E4} Share"), /* @__PURE__ */ React.createElement("button", { style: { ...styles.button, background: "linear-gradient(135deg, #3182ce, #2b6cb0)" }, onClick: exportToCSV }, "\u{1F4CA} CSV"), /* @__PURE__ */ React.createElement("button", { style: styles.button, onClick: generatePDF }, "\u{1F4C4} PDF")), renderShareModal(), renderEnlargeModal());
  };
  ReactDOM.createRoot(document.getElementById("root")).render(/* @__PURE__ */ React.createElement(CAPObserverLog, null));
})();

  </script>
</body>
</html>
